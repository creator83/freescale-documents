###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.3.54009/W32 for ARM     25/Jan/2013  14:41:36 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Profiles\B38350\My Documents\Code                     #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\src\pr #
#                    ojects\KL04_ref_design_demo\KL04_ref_design_demo.c       #
#    Command line =  "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\src\pr #
#                    ojects\KL04_ref_design_demo\KL04_ref_design_demo.c" -D   #
#                    IAR -D KL04_REF_DESIGN -lCN "D:\Profiles\B38350\My       #
#                    Documents\Code Repositories\KL05\KL04_SC_TEMP\dummy_back #
#                    up\dummy\build\iar\KL04_ref_design_demo\FLASH_32KB\List\ #
#                    " -lB "D:\Profiles\B38350\My Documents\Code              #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\FLASH_32KB\List\" -o            #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\FLASH_32KB\Obj\" --no_cse       #
#                    --no_unroll --no_inline --no_code_motion --no_tbaa       #
#                    --no_clustering --no_scheduling --debug --endian=little  #
#                    --cpu=Cortex-M0+ -e --fpu=None --dlib_config             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    6.4\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\projects\KL04_ref_ #
#                    design_demo\" -I "D:\Profiles\B38350\My Documents\Code   #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\common\" -I        #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\cpu\" -I           #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\cpu\headers\" -I   #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\drivers\llwu\" -I  #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\drivers\adc\" -I   #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\drivers\lptmr\"    #
#                    -I "D:\Profiles\B38350\My Documents\Code                 #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\drivers\mcg\" -I   #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\drivers\pmc\" -I   #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\drivers\rcm\" -I   #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\drivers\rtc\" -I   #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\drivers\smc\" -I   #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\drivers\uart\" -I  #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\drivers\wdog\" -I  #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\drivers\uart\" -I  #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\..\..\src\platforms\" -I     #
#                    "D:\Profiles\B38350\My Documents\Code                    #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\..\" -Ol --use_c++_inline       #
#    List file    =  D:\Profiles\B38350\My Documents\Code                     #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\FLASH_32KB\List\KL04_ref_design #
#                    _demo.lst                                                #
#    Object file  =  D:\Profiles\B38350\My Documents\Code                     #
#                    Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\build\ #
#                    iar\KL04_ref_design_demo\FLASH_32KB\Obj\KL04_ref_design_ #
#                    demo.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\Profiles\B38350\My Documents\Code Repositories\KL05\KL04_SC_TEMP\dummy_backup\dummy\src\projects\KL04_ref_design_demo\KL04_ref_design_demo.c
      1          /*
      2           * File:		KL04_ref_design_demo.c
      3           * Purpose:		Main process
      4           *
      5           */
      6          
      7          #include "common.h"
      8          #include "KL04_ref_design_demo.h"
      9          #include "smc.h"
     10          #include "adc.h"
     11          #include "BME.h"
     12          
     13          extern uint16 test_mode, Bgap_V;

   \                                 In section .bss, align 2
     14          uint16 VLLS3_recovery = FALSE, RTC_Alarm = FALSE;
   \                     VLLS3_recovery:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     RTC_Alarm:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     15          uint16 TPM0_flag = FALSE, TPM1_flag = FALSE, LPTMR_flag = FALSE, CMP0_flag = FALSE;
   \                     TPM0_flag:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     TPM1_flag:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     LPTMR_flag:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     CMP0_flag:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
     16          uint16 V0_result, V1_result, RTC_refresh_rate;
   \                     V0_result:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     V1_result:
   \   00000000                      DS8 2

   \                                 In section .bss, align 2
   \                     RTC_refresh_rate:
   \   00000000                      DS8 2
     17          
     18          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     19          int main (void)
     20          {
   \                     main:
   \   00000000   0xB580             PUSH     {R7,LR}
     21            char ch;
     22            uint32 i;
     23                  
     24            FGPIOA_PCOR |= 0x8000;
   \   00000002   0x....             LDR      R0,??DataTable1  ;; 0xf80ff008
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x2180             MOVS     R1,#+128
   \   00000008   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \   0000000A   0x4301             ORRS     R1,R1,R0
   \   0000000C   0x....             LDR      R0,??DataTable1  ;; 0xf80ff008
   \   0000000E   0x6001             STR      R1,[R0, #+0]
     25          #ifdef TEST_BOARD
     26            PORTA_PCR12 = PORT_PCR_MUX(1);
     27            PORTB_PCR6 = PORT_PCR_MUX(1);
     28            
     29            GPIOA_PDDR |= 0x1000;
     30            GPIOA_PSOR |= 0x1000;
     31            
     32            GPIOB_PDDR |= 0x40;
     33            GPIOB_PCOR |= 0x40;
     34            
     35          while(1)
     36             {
     37                 //A12
     38                 GPIOA_PTOR = 0x1000;
     39                 // B6
     40                 GPIOB_PTOR = 0x40;
     41                 for(i=0; i< 0x3FFFFF; i++)
     42                 {}
     43                 //A12
     44                 GPIOA_PTOR = 0x1000;
     45                 // B6
     46                 GPIOB_PTOR = 0x40;
     47                 for(i=0; i< 0x3FFFFF; i++)
     48                 {}
     49             }
     50          
     51          #endif
     52            
     53            switch (test_mode)  {
   \   00000010   0x....             LDR      R0,??DataTable2
   \   00000012   0x8800             LDRH     R0,[R0, #+0]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD00D             BEQ      ??main_0
   \   00000018   0x2802             CMP      R0,#+2
   \   0000001A   0xD005             BEQ      ??main_1
   \   0000001C   0xD307             BCC      ??main_2
   \   0000001E   0x2803             CMP      R0,#+3
   \   00000020   0xD10B             BNE      ??main_3
     54              case 3:
     55                Standby_Test();
   \                     ??main_4:
   \   00000022   0x.... 0x....      BL       Standby_Test
     56                break;
   \   00000026   0xE008             B        ??main_5
     57              case 2:
     58                Alarm_Test();
   \                     ??main_1:
   \   00000028   0x.... 0x....      BL       Alarm_Test
     59                break;
   \   0000002C   0xE005             B        ??main_5
     60              case 1:
     61                Drive_Test();
   \                     ??main_2:
   \   0000002E   0x.... 0x....      BL       Drive_Test
     62                break;
   \   00000032   0xE002             B        ??main_5
     63              case 0:
     64                RF_Test();
   \                     ??main_0:
   \   00000034   0x.... 0x....      BL       RF_Test
     65                break;
   \   00000038   0xE7FF             B        ??main_5
     66              default:
     67                // Turn on both OUT0 and OUT1 GPIO to indicate error state
     68                break;
     69            }
     70          }
   \                     ??main_3:
   \                     ??main_5:
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xBD02             POP      {R1,PC}          ;; return
     71          /********************************************************************/
     72          

   \                                 In section .text, align 4, keep-with-next
     73          void demo_rtc_init(uint8 time)
     74          {
   \                     demo_rtc_init:
   \   00000000   0xB580             PUSH     {R7,LR}
     75              uint32 i;
     76          
     77            // enable the clock to SRTC module register space
     78            SIM_SCGC6 |= SIM_SCGC6_RTC_MASK;
   \   00000002   0x....             LDR      R1,??DataTable1_1  ;; 0x4004803c
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x2280             MOVS     R2,#+128
   \   00000008   0x0592             LSLS     R2,R2,#+22       ;; #+536870912
   \   0000000A   0x430A             ORRS     R2,R2,R1
   \   0000000C   0x....             LDR      R1,??DataTable1_1  ;; 0x4004803c
   \   0000000E   0x600A             STR      R2,[R1, #+0]
     79            
     80            // Configure the LLWU to wakeup from the RTC Alarm interrupt 
     81            LLWU_ME = LLWU_ME_WUME5_MASK;
   \   00000010   0x....             LDR      R1,??DataTable1_2  ;; 0x4007c002
   \   00000012   0x2220             MOVS     R2,#+32
   \   00000014   0x700A             STRB     R2,[R1, #+0]
     82            
     83            /*Only POR has an effect on the SRTC, RESET to the part does not, so you must manually reset the SRTC to make sure everything is in a known state*/
     84            /*clear the software reset bit*/
     85            RTC_CR  = RTC_CR_SWR_MASK;
   \   00000016   0x....             LDR      R1,??DataTable1_3  ;; 0x4003d010
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x600A             STR      R2,[R1, #+0]
     86            RTC_CR  &= ~RTC_CR_SWR_MASK;
   \   0000001C   0x....             LDR      R1,??DataTable1_3  ;; 0x4003d010
   \   0000001E   0x6809             LDR      R1,[R1, #+0]
   \   00000020   0x2201             MOVS     R2,#+1
   \   00000022   0x4391             BICS     R1,R1,R2
   \   00000024   0x....             LDR      R2,??DataTable1_3  ;; 0x4003d010
   \   00000026   0x6011             STR      R1,[R2, #+0]
     87            
     88            // service the COP to provide enough time for OSC initialization
     89            SIM_SRVCOP = 0x55;
   \   00000028   0x....             LDR      R1,??DataTable1_4  ;; 0x40048104
   \   0000002A   0x2255             MOVS     R2,#+85
   \   0000002C   0x600A             STR      R2,[R1, #+0]
     90            SIM_SRVCOP = 0xAA;
   \   0000002E   0x....             LDR      R1,??DataTable1_4  ;; 0x40048104
   \   00000030   0x22AA             MOVS     R2,#+170
   \   00000032   0x600A             STR      R2,[R1, #+0]
     91            /*Enable the oscillator*/
     92            RTC_CR |= RTC_CR_OSCE_MASK;
   \   00000034   0x....             LDR      R1,??DataTable1_3  ;; 0x4003d010
   \   00000036   0x6809             LDR      R1,[R1, #+0]
   \   00000038   0x2280             MOVS     R2,#+128
   \   0000003A   0x0052             LSLS     R2,R2,#+1        ;; #+256
   \   0000003C   0x430A             ORRS     R2,R2,R1
   \   0000003E   0x....             LDR      R1,??DataTable1_3  ;; 0x4003d010
   \   00000040   0x600A             STR      R2,[R1, #+0]
     93            // wait for the OSCINIT bit to set to indicate oscillator is running
     94            while (!(MCG_S & MCG_S_OSCINIT0_MASK));  
   \                     ??demo_rtc_init_0:
   \   00000042   0x....             LDR      R1,??DataTable1_5  ;; 0x40064006
   \   00000044   0x7809             LDRB     R1,[R1, #+0]
   \   00000046   0x0789             LSLS     R1,R1,#+30
   \   00000048   0xD5FB             BPL      ??demo_rtc_init_0
     95            
     96            // service the COP once more as 32kHz OSC can take a while
     97            SIM_SRVCOP = 0x55;
   \   0000004A   0x....             LDR      R1,??DataTable1_4  ;; 0x40048104
   \   0000004C   0x2255             MOVS     R2,#+85
   \   0000004E   0x600A             STR      R2,[R1, #+0]
     98            SIM_SRVCOP = 0xAA;
   \   00000050   0x....             LDR      R1,??DataTable1_4  ;; 0x40048104
   \   00000052   0x22AA             MOVS     R2,#+170
   \   00000054   0x600A             STR      R2,[R1, #+0]
     99            
    100            for(i=0; i<1000; i++);
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0xE000             B        ??demo_rtc_init_1
   \                     ??demo_rtc_init_2:
   \   0000005A   0x1C49             ADDS     R1,R1,#+1
   \                     ??demo_rtc_init_1:
   \   0000005C   0x22FA             MOVS     R2,#+250
   \   0000005E   0x0092             LSLS     R2,R2,#+2        ;; #+1000
   \   00000060   0x4291             CMP      R1,R2
   \   00000062   0xD3FA             BCC      ??demo_rtc_init_2
    101            
    102            //RTC_IER = RTC_IER_TSIE_MASK;
    103            RTC_IER = RTC_IER_TAIE_MASK;
   \   00000064   0x....             LDR      R1,??DataTable1_6  ;; 0x4003d01c
   \   00000066   0x2204             MOVS     R2,#+4
   \   00000068   0x600A             STR      R2,[R1, #+0]
    104            
    105            RTC_TSR = 0x0;
   \   0000006A   0x....             LDR      R1,??DataTable1_7  ;; 0x4003d000
   \   0000006C   0x2200             MOVS     R2,#+0
   \   0000006E   0x600A             STR      R2,[R1, #+0]
    106            
    107            if (time == 5)
   \   00000070   0xB2C0             UXTB     R0,R0
   \   00000072   0x2805             CMP      R0,#+5
   \   00000074   0xD105             BNE      ??demo_rtc_init_3
    108            {
    109                // Set time alarm register
    110                RTC_TAR = RTC_TSR + RTC_VAL_5S;
   \   00000076   0x....             LDR      R0,??DataTable1_7  ;; 0x4003d000
   \   00000078   0x6800             LDR      R0,[R0, #+0]
   \   0000007A   0x1D40             ADDS     R0,R0,#+5
   \   0000007C   0x....             LDR      R1,??DataTable1_8  ;; 0x4003d008
   \   0000007E   0x6008             STR      R0,[R1, #+0]
   \   00000080   0xE00D             B        ??demo_rtc_init_4
    111            }
    112            else if (time == 4)
   \                     ??demo_rtc_init_3:
   \   00000082   0xB2C0             UXTB     R0,R0
   \   00000084   0x2804             CMP      R0,#+4
   \   00000086   0xD105             BNE      ??demo_rtc_init_5
    113            {
    114                // Set time alarm register
    115                RTC_TAR = RTC_TSR + RTC_VAL_4S;
   \   00000088   0x....             LDR      R0,??DataTable1_7  ;; 0x4003d000
   \   0000008A   0x6800             LDR      R0,[R0, #+0]
   \   0000008C   0x1D00             ADDS     R0,R0,#+4
   \   0000008E   0x....             LDR      R1,??DataTable1_8  ;; 0x4003d008
   \   00000090   0x6008             STR      R0,[R1, #+0]
   \   00000092   0xE004             B        ??demo_rtc_init_4
    116            }
    117            else
    118            {
    119                // Set time alarm register
    120                RTC_TAR = RTC_TSR + RTC_VAL_1S;
   \                     ??demo_rtc_init_5:
   \   00000094   0x....             LDR      R0,??DataTable1_7  ;; 0x4003d000
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x1C40             ADDS     R0,R0,#+1
   \   0000009A   0x....             LDR      R1,??DataTable1_8  ;; 0x4003d008
   \   0000009C   0x6008             STR      R0,[R1, #+0]
    121            }
    122          
    123            // Enable RTC Alarm interrupt vector
    124            enable_irq(20);
   \                     ??demo_rtc_init_4:
   \   0000009E   0x2014             MOVS     R0,#+20
   \   000000A0   0x.... 0x....      BL       enable_irq
    125            
    126            // Enable Global interrupts. 
    127            EnableInterrupts;
   \   000000A4   0xB662             CPSIE i
    128              
    129            //Enable the counter
    130            RTC_SR |= RTC_SR_TCE_MASK;
   \   000000A6   0x....             LDR      R0,??DataTable2_1  ;; 0x4003d014
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x2110             MOVS     R1,#+16
   \   000000AC   0x4301             ORRS     R1,R1,R0
   \   000000AE   0x....             LDR      R0,??DataTable2_1  ;; 0x4003d014
   \   000000B0   0x6001             STR      R1,[R0, #+0]
    131          
    132          }
   \   000000B2   0xBD01             POP      {R0,PC}          ;; return
    133          
    134          

   \                                 In section .text, align 2, keep-with-next
    135          void IO_config(void)
    136          {       
    137          #ifdef TOWER
    138            // setup outputs
    139            PORTA_PCR12 = (PORT_PCR_MUX(0x2));
    140            PORTB_PCR8  = (PORT_PCR_MUX(0x2)); 
    141            // setup inputs
    142            PORTA_PCR7  = (PORT_PCR_MUX(0x1) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK );
    143            PORTB_PCR14 = (PORT_PCR_MUX(0x1) | PORT_PCR_PE_MASK | PORT_PCR_PS_MASK );  
    144            // setup ADC channels 
    145            PORTA_PCR9  = (PORT_PCR_MUX(0x0));
    146            PORTA_PCR10 = (PORT_PCR_MUX(0x0));
    147          #else
    148            // setup inputs
    149            // Configure switchess as GPIO inputs with pullups and interrupts disabled
    150            PORTA_PCR7  = (PORT_PCR_MUX(0x1)); // INT0  
   \                     IO_config:
   \   00000000   0x....             LDR      R0,??DataTable2_2  ;; 0x4004901c
   \   00000002   0x2180             MOVS     R1,#+128
   \   00000004   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   00000006   0x6001             STR      R1,[R0, #+0]
    151            PORTB_PCR0  = (PORT_PCR_MUX(0x1)); // INT1 
   \   00000008   0x....             LDR      R0,??DataTable2_3  ;; 0x4004a000
   \   0000000A   0x2180             MOVS     R1,#+128
   \   0000000C   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    152            // setup ADC channels
    153            //PORTA_PCR0  = (PORT_PCR_MUX(0x0));
    154            //PORTA_PCR1  = (PORT_PCR_MUX(0x0));
    155            //PORTA_PCR2  = (PORT_PCR_MUX(0x0));
    156            //PORTA_PCR3  = (PORT_PCR_MUX(0x0));
    157            //PORTA_PCR4  = (PORT_PCR_MUX(0x0));
    158            PORTA_PCR5  = (PORT_PCR_MUX(0x0));
   \   00000010   0x....             LDR      R0,??DataTable2_4  ;; 0x40049014
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x6001             STR      R1,[R0, #+0]
    159            PORTA_PCR6  = (PORT_PCR_MUX(0x0));
   \   00000016   0x....             LDR      R0,??DataTable2_5  ;; 0x40049018
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6001             STR      R1,[R0, #+0]
    160            PORTA_PCR8  = (PORT_PCR_MUX(0x0));
   \   0000001C   0x....             LDR      R0,??DataTable2_6  ;; 0x40049020
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x6001             STR      R1,[R0, #+0]
    161            PORTA_PCR9  = (PORT_PCR_MUX(0x0));
   \   00000022   0x....             LDR      R0,??DataTable2_7  ;; 0x40049024
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x6001             STR      R1,[R0, #+0]
    162            PORTA_PCR10 = (PORT_PCR_MUX(0x0));
   \   00000028   0x....             LDR      R0,??DataTable2_8  ;; 0x40049028
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    163            PORTA_PCR11 = (PORT_PCR_MUX(0x0));
   \   0000002E   0x....             LDR      R0,??DataTable2_9  ;; 0x4004902c
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x6001             STR      R1,[R0, #+0]
    164            PORTA_PCR12 = (PORT_PCR_MUX(0x0));
   \   00000034   0x....             LDR      R0,??DataTable2_10  ;; 0x40049030
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x6001             STR      R1,[R0, #+0]
    165            PORTA_PCR13 = (PORT_PCR_MUX(0x0));
   \   0000003A   0x....             LDR      R0,??DataTable2_11  ;; 0x40049034
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x6001             STR      R1,[R0, #+0]
    166            PORTA_PCR14 = (PORT_PCR_MUX(0x0));
   \   00000040   0x....             LDR      R0,??DataTable2_12  ;; 0x40049038
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x6001             STR      R1,[R0, #+0]
    167            PORTA_PCR15 = (PORT_PCR_MUX(0x1));
   \   00000046   0x....             LDR      R0,??DataTable2_13  ;; 0x4004903c
   \   00000048   0x2180             MOVS     R1,#+128
   \   0000004A   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   0000004C   0x6001             STR      R1,[R0, #+0]
    168            PORTA_PCR16 = (PORT_PCR_MUX(0x0));
   \   0000004E   0x....             LDR      R0,??DataTable2_14  ;; 0x40049040
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x6001             STR      R1,[R0, #+0]
    169            PORTA_PCR17 = (PORT_PCR_MUX(0x0));
   \   00000054   0x....             LDR      R0,??DataTable2_15  ;; 0x40049044
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x6001             STR      R1,[R0, #+0]
    170            PORTA_PCR18 = (PORT_PCR_MUX(0x0));
   \   0000005A   0x....             LDR      R0,??DataTable2_16  ;; 0x40049048
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x6001             STR      R1,[R0, #+0]
    171            PORTA_PCR19 = (PORT_PCR_MUX(0x0));
   \   00000060   0x....             LDR      R0,??DataTable2_17  ;; 0x4004904c
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x6001             STR      R1,[R0, #+0]
    172            PORTA_PCR20 = (PORT_PCR_MUX(0x0));
   \   00000066   0x....             LDR      R0,??DataTable2_18  ;; 0x40049050
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x6001             STR      R1,[R0, #+0]
    173            PORTA_PCR21 = (PORT_PCR_MUX(0x0));
   \   0000006C   0x....             LDR      R0,??DataTable2_19  ;; 0x40049054
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x6001             STR      R1,[R0, #+0]
    174            PORTA_PCR22 = (PORT_PCR_MUX(0x0));
   \   00000072   0x....             LDR      R0,??DataTable2_20  ;; 0x40049058
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x6001             STR      R1,[R0, #+0]
    175            PORTA_PCR23 = (PORT_PCR_MUX(0x0));
   \   00000078   0x....             LDR      R0,??DataTable2_21  ;; 0x4004905c
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x6001             STR      R1,[R0, #+0]
    176            PORTA_PCR24 = (PORT_PCR_MUX(0x0));
   \   0000007E   0x....             LDR      R0,??DataTable2_22  ;; 0x40049060
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x6001             STR      R1,[R0, #+0]
    177            PORTA_PCR25 = (PORT_PCR_MUX(0x0));
   \   00000084   0x....             LDR      R0,??DataTable2_23  ;; 0x40049064
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x6001             STR      R1,[R0, #+0]
    178            PORTA_PCR26 = (PORT_PCR_MUX(0x0));
   \   0000008A   0x....             LDR      R0,??DataTable2_24  ;; 0x40049068
   \   0000008C   0x2100             MOVS     R1,#+0
   \   0000008E   0x6001             STR      R1,[R0, #+0]
    179            PORTA_PCR27 = (PORT_PCR_MUX(0x0));
   \   00000090   0x....             LDR      R0,??DataTable2_25  ;; 0x4004906c
   \   00000092   0x2100             MOVS     R1,#+0
   \   00000094   0x6001             STR      R1,[R0, #+0]
    180            PORTA_PCR28 = (PORT_PCR_MUX(0x0));
   \   00000096   0x....             LDR      R0,??DataTable2_26  ;; 0x40049070
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0x6001             STR      R1,[R0, #+0]
    181            PORTA_PCR29 = (PORT_PCR_MUX(0x0));
   \   0000009C   0x....             LDR      R0,??DataTable2_27  ;; 0x40049074
   \   0000009E   0x2100             MOVS     R1,#+0
   \   000000A0   0x6001             STR      R1,[R0, #+0]
    182            PORTA_PCR30 = (PORT_PCR_MUX(0x0));
   \   000000A2   0x....             LDR      R0,??DataTable2_28  ;; 0x40049078
   \   000000A4   0x2100             MOVS     R1,#+0
   \   000000A6   0x6001             STR      R1,[R0, #+0]
    183            PORTA_PCR31 = (PORT_PCR_MUX(0x0));
   \   000000A8   0x....             LDR      R0,??DataTable2_29  ;; 0x4004907c
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0x6001             STR      R1,[R0, #+0]
    184            
    185            FGPIOA_PDDR |= 0x8000;
   \   000000AE   0x....             LDR      R0,??DataTable2_30  ;; 0xf80ff014
   \   000000B0   0x6800             LDR      R0,[R0, #+0]
   \   000000B2   0x2180             MOVS     R1,#+128
   \   000000B4   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \   000000B6   0x4301             ORRS     R1,R1,R0
   \   000000B8   0x....             LDR      R0,??DataTable2_30  ;; 0xf80ff014
   \   000000BA   0x6001             STR      R1,[R0, #+0]
    186            
    187            //PORTB_PCR0  = (PORT_PCR_MUX(0x1));
    188            PORTB_PCR1  = (PORT_PCR_MUX(0x0));
   \   000000BC   0x....             LDR      R0,??DataTable2_31  ;; 0x4004a004
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0x6001             STR      R1,[R0, #+0]
    189            PORTB_PCR2  = (PORT_PCR_MUX(0x1)); // LLWU pin wakeup.  LLWU_P5
   \   000000C2   0x....             LDR      R0,??DataTable2_32  ;; 0x4004a008
   \   000000C4   0x2180             MOVS     R1,#+128
   \   000000C6   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   000000C8   0x6001             STR      R1,[R0, #+0]
    190            PORTB_PCR3  = (PORT_PCR_MUX(0x0));
   \   000000CA   0x....             LDR      R0,??DataTable2_33  ;; 0x4004a00c
   \   000000CC   0x2100             MOVS     R1,#+0
   \   000000CE   0x6001             STR      R1,[R0, #+0]
    191            PORTB_PCR4  = (PORT_PCR_MUX(0x0));
   \   000000D0   0x....             LDR      R0,??DataTable2_34  ;; 0x4004a010
   \   000000D2   0x2100             MOVS     R1,#+0
   \   000000D4   0x6001             STR      R1,[R0, #+0]
    192            PORTB_PCR5  = (PORT_PCR_MUX(0x0));
   \   000000D6   0x....             LDR      R0,??DataTable2_35  ;; 0x4004a014
   \   000000D8   0x2100             MOVS     R1,#+0
   \   000000DA   0x6001             STR      R1,[R0, #+0]
    193            PORTB_PCR6  = (PORT_PCR_MUX(0x0));
   \   000000DC   0x....             LDR      R0,??DataTable2_36  ;; 0x4004a018
   \   000000DE   0x2100             MOVS     R1,#+0
   \   000000E0   0x6001             STR      R1,[R0, #+0]
    194            PORTB_PCR7  = (PORT_PCR_MUX(0x0));
   \   000000E2   0x....             LDR      R0,??DataTable2_37  ;; 0x4004a01c
   \   000000E4   0x2100             MOVS     R1,#+0
   \   000000E6   0x6001             STR      R1,[R0, #+0]
    195            PORTB_PCR8  = (PORT_PCR_MUX(0x0));
   \   000000E8   0x....             LDR      R0,??DataTable2_38  ;; 0x4004a020
   \   000000EA   0x2100             MOVS     R1,#+0
   \   000000EC   0x6001             STR      R1,[R0, #+0]
    196            PORTB_PCR9  = (PORT_PCR_MUX(0x0));
   \   000000EE   0x....             LDR      R0,??DataTable2_39  ;; 0x4004a024
   \   000000F0   0x2100             MOVS     R1,#+0
   \   000000F2   0x6001             STR      R1,[R0, #+0]
    197            PORTB_PCR10 = (PORT_PCR_MUX(0x0));
   \   000000F4   0x....             LDR      R0,??DataTable2_40  ;; 0x4004a028
   \   000000F6   0x2100             MOVS     R1,#+0
   \   000000F8   0x6001             STR      R1,[R0, #+0]
    198            PORTB_PCR11 = (PORT_PCR_MUX(0x0));
   \   000000FA   0x....             LDR      R0,??DataTable2_41  ;; 0x4004a02c
   \   000000FC   0x2100             MOVS     R1,#+0
   \   000000FE   0x6001             STR      R1,[R0, #+0]
    199            PORTB_PCR12 = (PORT_PCR_MUX(0x0));
   \   00000100   0x....             LDR      R0,??DataTable2_42  ;; 0x4004a030
   \   00000102   0x2100             MOVS     R1,#+0
   \   00000104   0x6001             STR      R1,[R0, #+0]
    200            PORTB_PCR13 = (PORT_PCR_MUX(0x0));
   \   00000106   0x....             LDR      R0,??DataTable2_43  ;; 0x4004a034
   \   00000108   0x2100             MOVS     R1,#+0
   \   0000010A   0x6001             STR      R1,[R0, #+0]
    201            PORTB_PCR14 = (PORT_PCR_MUX(0x0));
   \   0000010C   0x....             LDR      R0,??DataTable2_44  ;; 0x4004a038
   \   0000010E   0x2100             MOVS     R1,#+0
   \   00000110   0x6001             STR      R1,[R0, #+0]
    202            PORTB_PCR15 = (PORT_PCR_MUX(0x0));
   \   00000112   0x....             LDR      R0,??DataTable2_45  ;; 0x4004a03c
   \   00000114   0x2100             MOVS     R1,#+0
   \   00000116   0x6001             STR      R1,[R0, #+0]
    203            PORTB_PCR16 = (PORT_PCR_MUX(0x0));
   \   00000118   0x....             LDR      R0,??DataTable2_46  ;; 0x4004a040
   \   0000011A   0x2100             MOVS     R1,#+0
   \   0000011C   0x6001             STR      R1,[R0, #+0]
    204            PORTB_PCR17 = (PORT_PCR_MUX(0x0));
   \   0000011E   0x....             LDR      R0,??DataTable2_47  ;; 0x4004a044
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0x6001             STR      R1,[R0, #+0]
    205            PORTB_PCR18 = (PORT_PCR_MUX(0x0));
   \   00000124   0x....             LDR      R0,??DataTable2_48  ;; 0x4004a048
   \   00000126   0x2100             MOVS     R1,#+0
   \   00000128   0x6001             STR      R1,[R0, #+0]
    206            PORTB_PCR19 = (PORT_PCR_MUX(0x0));
   \   0000012A   0x....             LDR      R0,??DataTable3  ;; 0x4004a04c
   \   0000012C   0x2100             MOVS     R1,#+0
   \   0000012E   0x6001             STR      R1,[R0, #+0]
    207            PORTB_PCR20 = (PORT_PCR_MUX(0x0));
   \   00000130   0x....             LDR      R0,??DataTable3_1  ;; 0x4004a050
   \   00000132   0x2100             MOVS     R1,#+0
   \   00000134   0x6001             STR      R1,[R0, #+0]
    208            PORTB_PCR21 = (PORT_PCR_MUX(0x0));
   \   00000136   0x....             LDR      R0,??DataTable3_2  ;; 0x4004a054
   \   00000138   0x2100             MOVS     R1,#+0
   \   0000013A   0x6001             STR      R1,[R0, #+0]
    209            PORTB_PCR22 = (PORT_PCR_MUX(0x0));
   \   0000013C   0x....             LDR      R0,??DataTable3_3  ;; 0x4004a058
   \   0000013E   0x2100             MOVS     R1,#+0
   \   00000140   0x6001             STR      R1,[R0, #+0]
    210            PORTB_PCR23 = (PORT_PCR_MUX(0x0));
   \   00000142   0x....             LDR      R0,??DataTable3_4  ;; 0x4004a05c
   \   00000144   0x2100             MOVS     R1,#+0
   \   00000146   0x6001             STR      R1,[R0, #+0]
    211            PORTB_PCR24 = (PORT_PCR_MUX(0x0));
   \   00000148   0x....             LDR      R0,??DataTable3_5  ;; 0x4004a060
   \   0000014A   0x2100             MOVS     R1,#+0
   \   0000014C   0x6001             STR      R1,[R0, #+0]
    212            PORTB_PCR25 = (PORT_PCR_MUX(0x0));
   \   0000014E   0x....             LDR      R0,??DataTable3_6  ;; 0x4004a064
   \   00000150   0x2100             MOVS     R1,#+0
   \   00000152   0x6001             STR      R1,[R0, #+0]
    213            PORTB_PCR26 = (PORT_PCR_MUX(0x0));
   \   00000154   0x....             LDR      R0,??DataTable3_7  ;; 0x4004a068
   \   00000156   0x2100             MOVS     R1,#+0
   \   00000158   0x6001             STR      R1,[R0, #+0]
    214            PORTB_PCR27 = (PORT_PCR_MUX(0x0));
   \   0000015A   0x....             LDR      R0,??DataTable3_8  ;; 0x4004a06c
   \   0000015C   0x2100             MOVS     R1,#+0
   \   0000015E   0x6001             STR      R1,[R0, #+0]
    215            PORTB_PCR28 = (PORT_PCR_MUX(0x0));
   \   00000160   0x....             LDR      R0,??DataTable3_9  ;; 0x4004a070
   \   00000162   0x2100             MOVS     R1,#+0
   \   00000164   0x6001             STR      R1,[R0, #+0]
    216            PORTB_PCR29 = (PORT_PCR_MUX(0x0));
   \   00000166   0x....             LDR      R0,??DataTable3_10  ;; 0x4004a074
   \   00000168   0x2100             MOVS     R1,#+0
   \   0000016A   0x6001             STR      R1,[R0, #+0]
    217            PORTB_PCR30 = (PORT_PCR_MUX(0x0));
   \   0000016C   0x....             LDR      R0,??DataTable3_11  ;; 0x4004a078
   \   0000016E   0x2100             MOVS     R1,#+0
   \   00000170   0x6001             STR      R1,[R0, #+0]
    218            PORTB_PCR31 = (PORT_PCR_MUX(0x0));
   \   00000172   0x....             LDR      R0,??DataTable3_12  ;; 0x4004a07c
   \   00000174   0x2100             MOVS     R1,#+0
   \   00000176   0x6001             STR      R1,[R0, #+0]
    219            
    220            PORTB_PCR2 |= PORT_PCR_PE_MASK;
   \   00000178   0x....             LDR      R0,??DataTable2_32  ;; 0x4004a008
   \   0000017A   0x6800             LDR      R0,[R0, #+0]
   \   0000017C   0x2102             MOVS     R1,#+2
   \   0000017E   0x4301             ORRS     R1,R1,R0
   \   00000180   0x....             LDR      R0,??DataTable2_32  ;; 0x4004a008
   \   00000182   0x6001             STR      R1,[R0, #+0]
    221            
    222            FGPIOB_PDDR &= ~(0x4);
   \   00000184   0x....             LDR      R0,??DataTable3_13  ;; 0xf80ff054
   \   00000186   0x6800             LDR      R0,[R0, #+0]
   \   00000188   0x2104             MOVS     R1,#+4
   \   0000018A   0x4388             BICS     R0,R0,R1
   \   0000018C   0x....             LDR      R1,??DataTable3_13  ;; 0xf80ff054
   \   0000018E   0x6008             STR      R0,[R1, #+0]
    223            
    224            LLWU_PE2 = LLWU_PE2_WUPE5(2);
   \   00000190   0x....             LDR      R0,??DataTable4  ;; 0x4007c001
   \   00000192   0x2108             MOVS     R1,#+8
   \   00000194   0x7001             STRB     R1,[R0, #+0]
    225            
    226            
    227          #endif
    228          }
   \   00000196   0x4770             BX       LR               ;; return
    229          
    230          

   \                                 In section .text, align 2, keep-with-next
    231          void Standby_Test(void)
    232          {
    233              uint16 temp16, temp16_2, temp16_3;
    234              uint32 temp32, i;
    235              
    236              while(1)
    237              {
    238              
    239                  while (RTC_Alarm == FALSE);
   \                     Standby_Test:
   \                     ??Standby_Test_0:
   \                     ??Standby_Test_1:
   \   00000000   0x....             LDR      R0,??DataTable4_1
   \   00000002   0x8800             LDRH     R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD0FB             BEQ      ??Standby_Test_1
    240                  RTC_Alarm = FALSE;
   \   00000008   0x....             LDR      R0,??DataTable4_1
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x8001             STRH     R1,[R0, #+0]
    241                  
    242                  // The ADC registers should be configured at POR or at LLWU recovery
    243                  //  after a VLLS3 recovery.  Therefore, we simply need to start a conversion
    244                  
    245                  // Sample V0
    246                  TriggerADC(CHANNELV0);
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x.... 0x....      BL       TriggerADC
    247                  V0_result = ReadADCPoll();
   \   00000014   0x.... 0x....      BL       ReadADCPoll
   \   00000018   0x....             LDR      R1,??DataTable4_2
   \   0000001A   0x8008             STRH     R0,[R1, #+0]
    248                  
    249                  temp16 = (V0_result * TPM_1024US_VAL) / ADC_MAX_VAL12;
   \   0000001C   0x....             LDR      R0,??DataTable4_2
   \   0000001E   0x8801             LDRH     R1,[R0, #+0]
   \   00000020   0x20FF             MOVS     R0,#+255
   \   00000022   0x00C0             LSLS     R0,R0,#+3        ;; #+2040
   \   00000024   0x4348             MULS     R0,R1,R0
   \   00000026   0x2180             MOVS     R1,#+128
   \   00000028   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \   0000002A   0x.... 0x....      BL       __aeabi_idiv
   \   0000002E   0x0004             MOVS     R4,R0
    250                  
    251                  if (temp16 > TPM_1024US_VAL)
   \   00000030   0x....             LDR      R0,??DataTable4_3  ;; 0x7f9
   \   00000032   0xB2A4             UXTH     R4,R4
   \   00000034   0x4284             CMP      R4,R0
   \   00000036   0xD301             BCC      ??Standby_Test_2
    252                      temp16 = TPM_1024US_VAL;
   \   00000038   0x24FF             MOVS     R4,#+255
   \   0000003A   0x00E4             LSLS     R4,R4,#+3        ;; #+2040
    253                  if (temp16 < 1)
   \                     ??Standby_Test_2:
   \   0000003C   0xB2A4             UXTH     R4,R4
   \   0000003E   0x2C01             CMP      R4,#+1
   \   00000040   0xD200             BCS      ??Standby_Test_3
    254                      temp16 = 1;
   \   00000042   0x2401             MOVS     R4,#+1
    255                  
    256                  // Sample V1
    257                  TriggerADC(CHANNELV1);
   \                     ??Standby_Test_3:
   \   00000044   0x2005             MOVS     R0,#+5
   \   00000046   0x.... 0x....      BL       TriggerADC
    258                  V1_result = ReadADCPoll();
   \   0000004A   0x.... 0x....      BL       ReadADCPoll
   \   0000004E   0x....             LDR      R1,??DataTable4_4
   \   00000050   0x8008             STRH     R0,[R1, #+0]
    259                  
    260                  temp16_2 = (V1_result * TPM_1024US_VAL) / (Bgap_V + (Bgap_V / 5));
   \   00000052   0x....             LDR      R0,??DataTable4_5
   \   00000054   0x8805             LDRH     R5,[R0, #+0]
   \   00000056   0x....             LDR      R0,??DataTable4_5
   \   00000058   0x8800             LDRH     R0,[R0, #+0]
   \   0000005A   0x2105             MOVS     R1,#+5
   \   0000005C   0x.... 0x....      BL       __aeabi_idiv
   \   00000060   0x1829             ADDS     R1,R5,R0
   \   00000062   0x....             LDR      R0,??DataTable4_4
   \   00000064   0x8802             LDRH     R2,[R0, #+0]
   \   00000066   0x20FF             MOVS     R0,#+255
   \   00000068   0x00C0             LSLS     R0,R0,#+3        ;; #+2040
   \   0000006A   0x4350             MULS     R0,R2,R0
   \   0000006C   0x.... 0x....      BL       __aeabi_idiv
    261                  
    262                  if (temp16_2 > TPM_1024US_VAL)
   \   00000070   0x....             LDR      R1,??DataTable4_3  ;; 0x7f9
   \   00000072   0xB280             UXTH     R0,R0
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD301             BCC      ??Standby_Test_4
    263                      temp16_2 = TPM_1024US_VAL;
   \   00000078   0x20FF             MOVS     R0,#+255
   \   0000007A   0x00C0             LSLS     R0,R0,#+3        ;; #+2040
    264                  if (temp16_2 < 1)
   \                     ??Standby_Test_4:
   \   0000007C   0xB280             UXTH     R0,R0
   \   0000007E   0x2801             CMP      R0,#+1
   \   00000080   0xD200             BCS      ??Standby_Test_5
    265                      temp16_2 = 1;
   \   00000082   0x2001             MOVS     R0,#+1
    266                  
    267                  
    268                  TPM1_SC = 0x00;
   \                     ??Standby_Test_5:
   \   00000084   0x....             LDR      R1,??DataTable5  ;; 0x40039000
   \   00000086   0x2200             MOVS     R2,#+0
   \   00000088   0x600A             STR      R2,[R1, #+0]
    269                  TPM0_SC = 0x00;
   \   0000008A   0x....             LDR      R1,??DataTable5_1  ;; 0x40038000
   \   0000008C   0x2200             MOVS     R2,#+0
   \   0000008E   0x600A             STR      R2,[R1, #+0]
    270                  // Reset the Count values for the TPM, as it is being used in a normal counter mode.
    271                  //   This only resets the counter!!  It does not reset the pulse width!  
    272                  TPM1_CNT = 0x00;
   \   00000090   0x....             LDR      R1,??DataTable4_6  ;; 0x40039004
   \   00000092   0x2200             MOVS     R2,#+0
   \   00000094   0x600A             STR      R2,[R1, #+0]
    273                  TPM0_CNT = 0x00;
   \   00000096   0x....             LDR      R1,??DataTable5_2  ;; 0x40038004
   \   00000098   0x2200             MOVS     R2,#+0
   \   0000009A   0x600A             STR      R2,[R1, #+0]
    274                  
    275                  /////////////////////////////////////////////////////////////////////////////////
    276                  // Write the appropriate pulse widths by writing the CnV registers!!
    277                  /////////////////////////////////////////////////////////////////////////////////
    278                  // The pulse width is determined by the ADC result
    279                  //  For Out0, PW = (ADC result/ ADC max) * 1024us.  
    280                 //   For a TPM configured for Output compare mode when the match clears the channel,
    281                  //  and assuming the TPM is using the slow irc (32.768 kHz), then 
    282                  //  1024us = 33 ticks.  
    283                  
    284                  TPM1_C0V = temp16;
   \   0000009C   0x....             LDR      R1,??DataTable5_3  ;; 0x40039010
   \   0000009E   0xB2A4             UXTH     R4,R4
   \   000000A0   0x600C             STR      R4,[R1, #+0]
    285                  
    286                  // The pulse width is determined by the ADC result
    287                  //  For Out1, PW = (ADC result/ 1.2V) * 1024us.  
    288                  //  For a TPM configured for Output compare mode when the match clears the channel,
    289                  //  and assuming the TPM is using the slow irc (32.768 kHz), then 
    290                  //  1024us = 33,555 ticks.
    291                  //
    292                  //  Also, the Bandgap buffer is typically 1.0V.  The bandgap buffer can 
    293                  //  be used as an input to the ADC.  Therefore, to get 1.2V in terms of
    294                  //  ADC units, we must first measure the bandgap voltage and assume this 
    295                  //  is 1.0V.  This value is stored in the variable BGAP_V.  Then, use 
    296                  //  the equation 1.0 + (1.0 / 5) to get 1.2 in terms of ADC units.  
    297                  
    298                  TPM0_C3V = temp16_2;
   \   000000A2   0x....             LDR      R1,??DataTable5_4  ;; 0x40038028
   \   000000A4   0xB280             UXTH     R0,R0
   \   000000A6   0x6008             STR      R0,[R1, #+0]
    299               
    300                  // Set the GPIO high as they are manually controlled and cleared in the 
    301                  //   TPM IRQ
    302                  if (temp16 > 1)
   \   000000A8   0xB2A4             UXTH     R4,R4
   \   000000AA   0x2C02             CMP      R4,#+2
   \   000000AC   0xD306             BCC      ??Standby_Test_6
    303                     FGPIOA_PSOR |= 0x1000;
   \   000000AE   0x....             LDR      R1,??DataTable5_5  ;; 0xf80ff004
   \   000000B0   0x6809             LDR      R1,[R1, #+0]
   \   000000B2   0x2280             MOVS     R2,#+128
   \   000000B4   0x0152             LSLS     R2,R2,#+5        ;; #+4096
   \   000000B6   0x430A             ORRS     R2,R2,R1
   \   000000B8   0x....             LDR      R1,??DataTable5_5  ;; 0xf80ff004
   \   000000BA   0x600A             STR      R2,[R1, #+0]
    304            
    305                  if (temp16_2 > 1)
   \                     ??Standby_Test_6:
   \   000000BC   0xB280             UXTH     R0,R0
   \   000000BE   0x2802             CMP      R0,#+2
   \   000000C0   0xD305             BCC      ??Standby_Test_7
    306                     FGPIOB_PSOR |= 0x40;
   \   000000C2   0x....             LDR      R0,??DataTable5_6  ;; 0xf80ff044
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x2140             MOVS     R1,#+64
   \   000000C8   0x4301             ORRS     R1,R1,R0
   \   000000CA   0x....             LDR      R0,??DataTable5_6  ;; 0xf80ff044
   \   000000CC   0x6001             STR      R1,[R0, #+0]
    307                  
    308                  // Configure channel 0 control register for software compare
    309                  TPM0_SC = (uint32_t)((TPM0_SC & (uint32_t)~(uint32_t)(
    310                       TPM_SC_TOF_MASK |
    311                       TPM_SC_TOIE_MASK |
    312                       TPM_SC_CPWMS_MASK |
    313                       TPM_SC_CMOD(0x01) |
    314                       TPM_SC_PS(0x07)
    315                      )) | (uint32_t)(
    316                       TPM_SC_CMOD(0x01)
    317                      ));
   \                     ??Standby_Test_7:
   \   000000CE   0x....             LDR      R0,??DataTable5_1  ;; 0x40038000
   \   000000D0   0x6800             LDR      R0,[R0, #+0]
   \   000000D2   0x21EF             MOVS     R1,#+239
   \   000000D4   0x4388             BICS     R0,R0,R1
   \   000000D6   0x2108             MOVS     R1,#+8
   \   000000D8   0x4301             ORRS     R1,R1,R0
   \   000000DA   0x....             LDR      R0,??DataTable5_1  ;; 0x40038000
   \   000000DC   0x6001             STR      R1,[R0, #+0]
    318                  
    319                  TPM1_SC = (uint32_t)((TPM0_SC & (uint32_t)~(uint32_t)(
    320                       TPM_SC_TOF_MASK |
    321                       TPM_SC_TOIE_MASK |
    322                       TPM_SC_CPWMS_MASK |
    323                       TPM_SC_CMOD(0x01) |
    324                       TPM_SC_PS(0x07)
    325                      )) | (uint32_t)(
    326                       TPM_SC_CMOD(0x01)
    327                      ));   
   \   000000DE   0x....             LDR      R0,??DataTable5_1  ;; 0x40038000
   \   000000E0   0x6800             LDR      R0,[R0, #+0]
   \   000000E2   0x21EF             MOVS     R1,#+239
   \   000000E4   0x4388             BICS     R0,R0,R1
   \   000000E6   0x2108             MOVS     R1,#+8
   \   000000E8   0x4301             ORRS     R1,R1,R0
   \   000000EA   0x....             LDR      R0,??DataTable5  ;; 0x40039000
   \   000000EC   0x6001             STR      R1,[R0, #+0]
    328                  
    329                  // Wait for the TPM to finish before returning to low power mode. 
    330                  while ((TPM0_flag == FALSE) || (TPM1_flag == FALSE));
   \                     ??Standby_Test_8:
   \   000000EE   0x....             LDR      R0,??DataTable5_7
   \   000000F0   0x8800             LDRH     R0,[R0, #+0]
   \   000000F2   0x2800             CMP      R0,#+0
   \   000000F4   0xD0FB             BEQ      ??Standby_Test_8
   \   000000F6   0x....             LDR      R0,??DataTable5_8
   \   000000F8   0x8800             LDRH     R0,[R0, #+0]
   \   000000FA   0x2800             CMP      R0,#+0
   \   000000FC   0xD0F7             BEQ      ??Standby_Test_8
    331                  TPM0_flag = FALSE;
   \   000000FE   0x....             LDR      R0,??DataTable5_7
   \   00000100   0x2100             MOVS     R1,#+0
   \   00000102   0x8001             STRH     R1,[R0, #+0]
    332                  TPM1_flag = FALSE;
   \   00000104   0x....             LDR      R0,??DataTable5_8
   \   00000106   0x2100             MOVS     R1,#+0
   \   00000108   0x8001             STRH     R1,[R0, #+0]
    333                  
    334                  // Clear pending interrupts before entering low power modes!
    335                  
    336                  // Clear module specific. 
    337                  if((TPM1_C0SC & TPM_CnSC_CHF_MASK) == TPM_CnSC_CHF_MASK)
   \   0000010A   0x....             LDR      R0,??DataTable5_9  ;; 0x4003900c
   \   0000010C   0x6800             LDR      R0,[R0, #+0]
   \   0000010E   0x0600             LSLS     R0,R0,#+24
   \   00000110   0xD505             BPL      ??Standby_Test_9
    338                  {
    339                      TPM1_C0SC |= TPM_CnSC_CHF_MASK;
   \   00000112   0x....             LDR      R0,??DataTable5_9  ;; 0x4003900c
   \   00000114   0x6800             LDR      R0,[R0, #+0]
   \   00000116   0x2180             MOVS     R1,#+128
   \   00000118   0x4301             ORRS     R1,R1,R0
   \   0000011A   0x....             LDR      R0,??DataTable5_9  ;; 0x4003900c
   \   0000011C   0x6001             STR      R1,[R0, #+0]
    340                  }
    341                  if((TPM0_C3SC & TPM_CnSC_CHF_MASK) == TPM_CnSC_CHF_MASK)
   \                     ??Standby_Test_9:
   \   0000011E   0x....             LDR      R0,??DataTable5_10  ;; 0x40038024
   \   00000120   0x6800             LDR      R0,[R0, #+0]
   \   00000122   0x0600             LSLS     R0,R0,#+24
   \   00000124   0xD505             BPL      ??Standby_Test_10
    342                  {
    343                      TPM0_C3SC |= TPM_CnSC_CHF_MASK;
   \   00000126   0x....             LDR      R0,??DataTable5_10  ;; 0x40038024
   \   00000128   0x6800             LDR      R0,[R0, #+0]
   \   0000012A   0x2180             MOVS     R1,#+128
   \   0000012C   0x4301             ORRS     R1,R1,R0
   \   0000012E   0x....             LDR      R0,??DataTable5_10  ;; 0x40038024
   \   00000130   0x6001             STR      R1,[R0, #+0]
    344                  }
    345                  
    346                  // Clear NVIC pending interrupts!
    347                  NVIC_ICPR = 0xFFFFFFFF;
   \                     ??Standby_Test_10:
   \   00000132   0x....             LDR      R0,??DataTable5_11  ;; 0xe000e280
   \   00000134   0x2100             MOVS     R1,#+0
   \   00000136   0x43C9             MVNS     R1,R1            ;; #-1
   \   00000138   0x6001             STR      R1,[R0, #+0]
    348                  
    349                  // Enter VLLS3 here
    350                  enter_vlls3();
   \   0000013A   0x.... 0x....      BL       enter_vlls3
   \   0000013E   0xE75F             B        ??Standby_Test_0
    351                  
    352                  /*SMC_PMCTRL = (SMC_PMCTRL & (SMC_PMCTRL_RUNM_MASK |
    353                                          SMC_PMCTRL_STOPM(0x4)));
    354                  
    355                  SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    356                  
    357          #ifndef KEIL
    358          	asm("WFI");
    359          #else
    360          	__wfi();
    361          #endif    */    
    362              
    363              }
    364          }
    365          

   \                                 In section .text, align 2, keep-with-next
    366          void Alarm_Test(void)
    367          {
    368              SIM_COPC = 0x00;                             // Disable Watchdog
   \                     Alarm_Test:
   \   00000000   0x....             LDR      R0,??DataTable5_12  ;; 0x40048100
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x6001             STR      R1,[R0, #+0]
    369              fei_fbe(32768, LOW_POWER, CRYSTAL);          // Move CLK from FEI to FBE mode for TPM0
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x2080             MOVS     R0,#+128
   \   0000000C   0x0200             LSLS     R0,R0,#+8        ;; #+32768
   \   0000000E   0x.... 0x....      BL       fei_fbe
    370            
    371              SIM_SCGC5|=SIM_SCGC5_PORTA_MASK;             // Enable PortA clock
   \   00000012   0x....             LDR      R0,??DataTable5_13  ;; 0x40048038
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x2180             MOVS     R1,#+128
   \   00000018   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   0000001A   0x4301             ORRS     R1,R1,R0
   \   0000001C   0x....             LDR      R0,??DataTable5_13  ;; 0x40048038
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    372              SIM_SCGC5|=SIM_SCGC5_PORTB_MASK;             // Enable PortB clock
   \   00000020   0x....             LDR      R0,??DataTable5_13  ;; 0x40048038
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x2180             MOVS     R1,#+128
   \   00000026   0x00C9             LSLS     R1,R1,#+3        ;; #+1024
   \   00000028   0x4301             ORRS     R1,R1,R0
   \   0000002A   0x....             LDR      R0,??DataTable5_13  ;; 0x40048038
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    373              SIM_SCGC6|=SIM_SCGC6_TPM0_MASK;              // Enable TPM0 module  
   \   0000002E   0x....             LDR      R0,??DataTable5_14  ;; 0x4004803c
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x2180             MOVS     R1,#+128
   \   00000034   0x0449             LSLS     R1,R1,#+17       ;; #+16777216
   \   00000036   0x4301             ORRS     R1,R1,R0
   \   00000038   0x....             LDR      R0,??DataTable5_14  ;; 0x4004803c
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    374              SIM_SCGC6|=SIM_SCGC6_TPM1_MASK;              // Enable TPM1 module  
   \   0000003C   0x....             LDR      R0,??DataTable5_14  ;; 0x4004803c
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x2180             MOVS     R1,#+128
   \   00000042   0x0489             LSLS     R1,R1,#+18       ;; #+33554432
   \   00000044   0x4301             ORRS     R1,R1,R0
   \   00000046   0x....             LDR      R0,??DataTable5_14  ;; 0x4004803c
   \   00000048   0x6001             STR      R1,[R0, #+0]
    375              SIM_SCGC5|=SIM_SCGC5_LPTMR_MASK;             // Enable LPTMR clock 
   \   0000004A   0x....             LDR      R0,??DataTable5_13  ;; 0x40048038
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x2101             MOVS     R1,#+1
   \   00000050   0x4301             ORRS     R1,R1,R0
   \   00000052   0x....             LDR      R0,??DataTable5_13  ;; 0x40048038
   \   00000054   0x6001             STR      R1,[R0, #+0]
    376              PORTA_PCR12=PORT_PCR_MUX(1);                 // Set Pin A12 to GPIO function OUT0
   \   00000056   0x....             LDR      R0,??DataTable5_15  ;; 0x40049030
   \   00000058   0x2180             MOVS     R1,#+128
   \   0000005A   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   0000005C   0x6001             STR      R1,[R0, #+0]
    377              GPIOA_PDDR|=(1<<12);                         // Make the GPIO A12 an output to use with LPTMR for 1Hz Out0
   \   0000005E   0x....             LDR      R0,??DataTable5_16  ;; 0x400ff014
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x2180             MOVS     R1,#+128
   \   00000064   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \   00000066   0x4301             ORRS     R1,R1,R0
   \   00000068   0x....             LDR      R0,??DataTable5_16  ;; 0x400ff014
   \   0000006A   0x6001             STR      R1,[R0, #+0]
    378          
    379              SIM_SOPT2=TPM0CLK_MCGFLLCLK;                 // TPM0 Input Clock is MCGFLLCLK
   \   0000006C   0x....             LDR      R0,??DataTable5_17  ;; 0x40048004
   \   0000006E   0x2180             MOVS     R1,#+128
   \   00000070   0x0449             LSLS     R1,R1,#+17       ;; #+16777216
   \   00000072   0x6001             STR      R1,[R0, #+0]
    380           
    381              //Out1 200KHz Wave
    382              PORTB_PCR6=PORT_PCR_MUX(2);                  // Set Pin B6 to TPM0CH3 function OUT1
   \   00000074   0x....             LDR      R0,??DataTable5_18  ;; 0x4004a018
   \   00000076   0x2180             MOVS     R1,#+128
   \   00000078   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   0000007A   0x6001             STR      R1,[R0, #+0]
    383              TPM0_SC=TPM0_ENABLE;                         // busclk/1=47.68ns per count; TPM on=0x08, off=0x00
   \   0000007C   0x....             LDR      R0,??DataTable5_1  ;; 0x40038000
   \   0000007E   0x2108             MOVS     R1,#+8
   \   00000080   0x6001             STR      R1,[R0, #+0]
    384              TPM0_C3SC=TPM0_EDGE_ALIGN_PWM;               // edge-aligned PWM
   \   00000082   0x....             LDR      R0,??DataTable5_10  ;; 0x40038024
   \   00000084   0x2128             MOVS     R1,#+40
   \   00000086   0x6001             STR      R1,[R0, #+0]
    385              TPM0_MOD=TPM0_MODULO-1;                      // Frequency is 200kHz 
   \   00000088   0x....             LDR      R0,??DataTable5_19  ;; 0x40038008
   \   0000008A   0x2168             MOVS     R1,#+104
   \   0000008C   0x6001             STR      R1,[R0, #+0]
    386              TPM0_C3V=TPM0_CHANNEL>>1;                    // half of the above to produce 50% duty cycle PWM 
   \   0000008E   0x....             LDR      R0,??DataTable5_4  ;; 0x40038028
   \   00000090   0x2134             MOVS     R1,#+52
   \   00000092   0x6001             STR      R1,[R0, #+0]
    387          
    388          
    389              //Out0 1Hz Square Wave
    390              lptmr_init(COUNT, ERCLK32K);                 // count value 16384, input clk ERCLK32K, 16384/32768=0.5Hz timout, 
   \   00000094   0x2102             MOVS     R1,#+2
   \   00000096   0x2080             MOVS     R0,#+128
   \   00000098   0x01C0             LSLS     R0,R0,#+7        ;; #+16384
   \   0000009A   0x.... 0x....      BL       lptmr_init
    391          
    392              while(1);                                    // loop forever
   \                     ??Alarm_Test_0:
   \   0000009E   0xE7FE             B        ??Alarm_Test_0
    393          }
    394          
    395          ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    396          // Drive Test
    397          //
    398          // Description:
    399          //  This test samples both inputs (V0 and V1) using the CMP module with the DAC
    400          //  providing a 50% VDD reference.  The outputs (OUT0 and OUT1) simply follow their
    401          //  respective inputs.
    402          //  
    403          //  The target power consumption for this test is ~4uA average.  Currently we
    404          //  are seeing 261uA in LLS
    405          //  The breakdown
    406          //  according to the datasheet is as follows:
    407          //
    408          //  RTC adder: 0.357uA
    409          //  LPTMR adder:  ???
    410          //
    411          // Implementing VLPR mode using the FIRC, we are seeing 222uA.
    412          // 
    413          

   \                                 In section .text, align 2, keep-with-next
    414          void Drive_Test(void)
    415          {
   \                     Drive_Test:
   \   00000000   0xB580             PUSH     {R7,LR}
    416              uint32 temp32;
    417              uint16 i;
    418              uint8 temp8;
    419              
    420              // Must use LLS mode in this case. 
    421              
    422              // Configure CMP0
    423              
    424              // CMP0 should be configured to trigger the TPM.  We also want to take 
    425              //  advantage of the CMP pulse capabilities to reduce current consumption.
    426              //  
    427              // CMP triggering is a 2-stage process that uses the LPTMR to first 
    428              //  trigger a wake-up event to the CMP and DAC.  Then a second trigger is 
    429              //  asserted which performs the CMP capture event.  The first trigger is
    430              //  asserted when the TCF flage of the LPTMR is set, while the second 
    431              //  trigger is asserted at 1/2 the Prescaler output period (if the LPTMR 
    432              //  prescaler is enabled) or 1/2 the prescaler clock period (if the LPTMR
    433              //  prescaler is by-passed).  
    434              
    435          #ifdef DEBUG_TOWER
    436              // setup outputs PTB8 - PTB9
    437              PORTB_PCR8 = (PORT_PCR_MUX(0x1));
    438              
    439              FGPIOB_PDDR |= 0x100;
    440              FGPIOB_PSOR |= 0x100;
    441              
    442              PORTB_PCR9  = (PORT_PCR_MUX(0x1));
    443              
    444              FGPIOB_PDDR |= 0x200;
    445              FGPIOB_PCOR |= 0x200;
    446              
    447              // Setup inputs PTB5 - PTBA12
    448              PORTB_PCR5 = PORT_PCR_MUX(0);
    449              PORTA_PCR12 = PORT_PCR_MUX(0);
    450          #else
    451              // setup outputs PTA12 - PTB6
    452              PORTA_PCR12 = (PORT_PCR_MUX(0x1));
   \   00000002   0x....             LDR      R0,??DataTable5_15  ;; 0x40049030
   \   00000004   0x2180             MOVS     R1,#+128
   \   00000006   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   00000008   0x6001             STR      R1,[R0, #+0]
    453              
    454              GPIOA_PDDR |= 0x1000;
   \   0000000A   0x....             LDR      R0,??DataTable5_16  ;; 0x400ff014
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x2180             MOVS     R1,#+128
   \   00000010   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \   00000012   0x4301             ORRS     R1,R1,R0
   \   00000014   0x....             LDR      R0,??DataTable5_16  ;; 0x400ff014
   \   00000016   0x6001             STR      R1,[R0, #+0]
    455              GPIOA_PSOR |= 0x1000;
   \   00000018   0x....             LDR      R0,??DataTable5_20  ;; 0x400ff004
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x2180             MOVS     R1,#+128
   \   0000001E   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \   00000020   0x4301             ORRS     R1,R1,R0
   \   00000022   0x....             LDR      R0,??DataTable5_20  ;; 0x400ff004
   \   00000024   0x6001             STR      R1,[R0, #+0]
    456              
    457              PORTB_PCR6  = (PORT_PCR_MUX(0x1));
   \   00000026   0x....             LDR      R0,??DataTable5_18  ;; 0x4004a018
   \   00000028   0x2180             MOVS     R1,#+128
   \   0000002A   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   0000002C   0x6001             STR      R1,[R0, #+0]
    458              
    459              FGPIOB_PDDR |= 0x40;
   \   0000002E   0x....             LDR      R0,??DataTable5_21  ;; 0xf80ff054
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x2140             MOVS     R1,#+64
   \   00000034   0x4301             ORRS     R1,R1,R0
   \   00000036   0x....             LDR      R0,??DataTable5_21  ;; 0xf80ff054
   \   00000038   0x6001             STR      R1,[R0, #+0]
    460              FGPIOB_PCOR |= 0x40;
   \   0000003A   0x....             LDR      R0,??DataTable5_22  ;; 0xf80ff048
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2140             MOVS     R1,#+64
   \   00000040   0x4301             ORRS     R1,R1,R0
   \   00000042   0x....             LDR      R0,??DataTable5_22  ;; 0xf80ff048
   \   00000044   0x6001             STR      R1,[R0, #+0]
    461              
    462               // Setup inputs PTB5 - PTB1
    463              PORTB_PCR5 = PORT_PCR_MUX(0);
   \   00000046   0x....             LDR      R0,??DataTable5_23  ;; 0x4004a014
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x6001             STR      R1,[R0, #+0]
    464              PORTB_PCR1 = PORT_PCR_MUX(0);
   \   0000004C   0x....             LDR      R0,??DataTable5_24  ;; 0x4004a004
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x6001             STR      R1,[R0, #+0]
    465          #endif
    466              
    467              
    468              /*
    469              // Set CMP Filter Count and Hysteresis control to 0.  
    470              //  Filter should be disabled to allow for low lag time.   
    471              CMP0_CR0 = 0x00;
    472              
    473              // Set CMP0_CR1 to a known state
    474              CMP0_CR1 = 0x00;
    475              
    476              // Now configure CMP0_CR1 (but do not enable it!)
    477              //CMP0_CR1 |= (CMP_CR1_PMODE_MASK | CMP_CR1_TRIGM_MASK);
    478              //CMP0_CR1 |= (CMP_CR1_TRIGM_MASK);   // Comment this line out if using the LPTMR interrupt method
    479              CMP0_CR1 &= ~(CMP_CR1_PMODE_MASK);
    480              //CMP0_CR1 |= CMP_CR1_TRIGM_MASK;  // Set if using triggered mode!
    481              //CMP0_SCR |= (CMP_SCR_IER_MASK | CMP_SCR_IEF_MASK);  // Set these if using triggered mode!
    482              
    483              // Configure the 6-bit DAC
    484              //  We want to use the Vin1in supply and to set the output voltage to 1/2 Vin
    485              //  DACout = (Vin/64) * (VOSEL[5:0] + 1), therefore 31 will produce DACout = 1/2 * Vin
    486              CMP0_DACCR = (CMP_DACCR_DACEN_MASK
    487                            | CMP_DACCR_VOSEL(31));
    488              
    489              // Select the appropriate Mux control
    490              //  
    491              //  We want to know when V0 > 50% Vcc, therefore, set the inverted input to
    492              //  be the DAC output.  Select the non-inverted input to be V0. 
    493              
    494              CMP0_MUXCR = (CMP_MUXCR_PSEL(CMP_CHANNEL_V0) | CMP_MUXCR_MSEL(CMP_DACIN));
    495              
    496              // Start with looking for the rising edge.  
    497              //CMP0_SCR = (CMP_SCR_IER_MASK);
    498              
    499              CMP0_flag = FALSE; 
    500              
    501              CMP0_CR1 |= CMP_CR1_EN_MASK;
    502              */
    503              // Setup the LPTMR to trigger a sample every 2 ms.  There will be a 10 ms pulse
    504              //  every 5s.  We want to be sure that we catch the pulse. 
    505              
    506              // Also, the timer increments need to be selected appropriately for the CMP
    507              //  and DAC to settle.  According to the datasheet, this settling requires
    508              //  40us.  One period of a 32.768 kHz wave is approximately 30 us.  Therefore,
    509              //  the prescaler will need to be used and 1/2 of the prescaler output will
    510              //  will need to be >40us. In other words, the prescaler output must be 
    511              //  4 times the input clock.
    512            
    513              // However, if we use the LPO, we can still achieve our goal using a 1 kHz
    514              //  clock.    
    515                 
    516              // Disable the LPTMR first.  For this app, the default control values are acceptable. 
    517              LPTMR0_CSR = 0x00;
   \   00000052   0x....             LDR      R0,??DataTable5_25  ;; 0x40040000
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x6001             STR      R1,[R0, #+0]
    518              
    519              // Set the PSR to a known state
    520              LPTMR0_PSR = 0x00;
   \   00000058   0x....             LDR      R0,??DataTable5_26  ;; 0x40040004
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0x6001             STR      R1,[R0, #+0]
    521              
    522              // Setup the PSR to use the prescaler, and select the appropriate clock. 
    523              LPTMR0_PSR |= (LPTMR_PSR_PCS(1) | LPTMR_PSR_PBYP_MASK);  // If using the LPO.  
   \   0000005E   0x....             LDR      R0,??DataTable5_26  ;; 0x40040004
   \   00000060   0x6800             LDR      R0,[R0, #+0]
   \   00000062   0x2105             MOVS     R1,#+5
   \   00000064   0x4301             ORRS     R1,R1,R0
   \   00000066   0x....             LDR      R0,??DataTable5_26  ;; 0x40040004
   \   00000068   0x6001             STR      R1,[R0, #+0]
    524              // LPTMR0_PSR |= (LPTMR_PSR_PCS(2)
    525              //                | LPTMR_PSR_PRESCALE(1));
    526              
    527              
    528              // Set the Compare register for a 9 ms interval. 
    529              LPTMR0_CMR = LPTMR_CMR_COMPARE(9);
   \   0000006A   0x....             LDR      R0,??DataTable5_27  ;; 0x40040008
   \   0000006C   0x2109             MOVS     R1,#+9
   \   0000006E   0x6001             STR      R1,[R0, #+0]
    530              // LPTMR0_CMR = 17;  // If using the 32.768 kHz ER32KCLK
    531              
    532              LPTMR0_CSR = LPTMR_CSR_TCF_MASK;
   \   00000070   0x....             LDR      R0,??DataTable5_25  ;; 0x40040000
   \   00000072   0x2180             MOVS     R1,#+128
   \   00000074   0x6001             STR      R1,[R0, #+0]
    533              
    534              // Configure the LLWU to wakeup from the LPTMR interrupt 
    535              LLWU_ME = LLWU_ME_WUME0_MASK ;     // Use this setting if using the LPTMR interrupt method
   \   00000076   0x....             LDR      R0,??DataTable5_28  ;; 0x4007c002
   \   00000078   0x2101             MOVS     R1,#+1
   \   0000007A   0x7001             STRB     R1,[R0, #+0]
    536              //LLWU_ME = LLWU_ME_WUME1_MASK ;     // Use this setting if using the CMP0 interrupt method
    537              
    538              // Enable LLWU IRQ
    539              enable_irq(7);
   \   0000007C   0x2007             MOVS     R0,#+7
   \   0000007E   0x.... 0x....      BL       enable_irq
    540              // Enable LPTMR IRQ (IRQ no. 28)
    541              //enable_irq(28);   
    542              // Set LPTMR IRQ to lower priority (higher number)
    543              //set_irq_priority(28, 1);
    544              // Use this interrupt if using the LPTMR interrupt method. 
    545              // Enable CMP0 interrupt
    546              //enable_irq(16);
    547              
    548              // Must disable CMP BEFORE entering LLS;  UNLESS using triggered mode!
    549              //CMP0_CR1 &= ~CMP_CR1_EN_MASK;    // Must comment this out if using the CMP method
    550              //CMP0_DACCR &= ~CMP_DACCR_DACEN_MASK;
    551                  
    552                  
    553              
    554              //LPTMR0_CSR |= (LPTMR_CSR_TEN_MASK);
    555            
    556              /*while(1)
    557              {
    558                  enter_lls();
    559              }*/
    560              //PORTA_PCR15 = PORT_PCR_MUX(3);
    561              //SIM_SOPT2 = 0x01000050;
    562              
    563              /*SMC_PMCTRL |= (SMC_PMCTRL_STOPM(0x3));
    564                  
    565              SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
    566              
    567              
    568                  
    569                  // Clear any pending interrupts before entering LLS!  Otherwise,
    570                  //  you may end up with a STOP ABORT condition.  
    571                  
    572                  // Clear module specific flags.  
    573                  //if((LPTMR0_CSR & LPTMR_CSR_TCF_MASK) == LPTMR_CSR_TCF_MASK)
    574                 // {
    575                      LPTMR0_CSR |=  LPTMR_CSR_TCF_MASK;   // write 1 to TCF to clear the LPT timer compare flag
    576                      //LPTMR0_CSR |= (LPTMR_CSR_TEN_MASK);
    577                      //wait for write to complete to  before returning 
    578                      temp32 = LPTMR0_CSR;
    579                  //}
    580                      
    581                      CMP0_SCR |= (CMP_SCR_CFR_MASK | CMP_SCR_CFF_MASK);
    582                  // Clear pending interrupts in the NVIC by writing a 1!
    583                  NVIC_ICPR = 0xFFFFFFFF;
    584                */  
    585              
    586              FGPIOA_PDDR &= ~0x80;
   \   00000082   0x....             LDR      R0,??DataTable6  ;; 0xf80ff014
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x2180             MOVS     R1,#+128
   \   00000088   0x4388             BICS     R0,R0,R1
   \   0000008A   0x....             LDR      R1,??DataTable6  ;; 0xf80ff014
   \   0000008C   0x6008             STR      R0,[R1, #+0]
    587              FGPIOB_PDDR &= ~0x01;
   \   0000008E   0x....             LDR      R0,??DataTable5_21  ;; 0xf80ff054
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x2101             MOVS     R1,#+1
   \   00000094   0x4388             BICS     R0,R0,R1
   \   00000096   0x....             LDR      R1,??DataTable5_21  ;; 0xf80ff054
   \   00000098   0x6008             STR      R0,[R1, #+0]
    588              
    589              PORTA_PCR7 = PORT_PCR_MUX(1);
   \   0000009A   0x....             LDR      R0,??DataTable6_1  ;; 0x4004901c
   \   0000009C   0x2180             MOVS     R1,#+128
   \   0000009E   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   000000A0   0x6001             STR      R1,[R0, #+0]
    590              PORTB_PCR0 = PORT_PCR_MUX(1);
   \   000000A2   0x....             LDR      R0,??DataTable6_2  ;; 0x4004a000
   \   000000A4   0x2180             MOVS     R1,#+128
   \   000000A6   0x0049             LSLS     R1,R1,#+1        ;; #+256
   \   000000A8   0x6001             STR      R1,[R0, #+0]
    591              
    592              //LLWU_PE2 |= LLWU_PE2_WUPE4(2);
    593              //LLWU_PE1 |= LLWU_PE1_WUPE3(2);
    594              
    595             /* // ** Replacing with the BME equivalent ** //
    596              SMC_PMCTRL |= (SMC_PMCTRL_STOPM(0x3));
    597              
    598              //SCB_SCR = (SCB_SCR_SLEEPDEEP_MASK | SCB_SCR_SLEEPONEXIT_MASK);
    599              SCB_SCR = (SCB_SCR_SLEEPDEEP_MASK);
    600                  
    601              //FGPIOA_PCOR |= 0x8000;
    602              while(1)
    603              {
    604          #ifndef KEIL
    605                  asm("WFI");
    606          #else
    607          	__wfi();
    608          #endif    
    609              }*/
    610                  // Call Drive Test infinite loop
    611                  Run_Drive_Test_Loop();
   \   000000AA   0x.... 0x....      BL       Run_Drive_Test_Loop
    612              
    613          }
   \   000000AE   0xBD01             POP      {R0,PC}          ;; return
    614          

   \                                 In section .textrw, align 4, keep-with-next
    615          void Run_Drive_Test_Loop(void)
    616          {
    617              uint32 temp32;
    618              
    619              // Turn off the Flash!!
    620              SIM_FCFG1 |= SIM_FCFG1_FLASHDIS_MASK;
   \                     Run_Drive_Test_Loop:
   \   00000000   0x....             LDR      R0,??DataTable157  ;; 0x4004804c
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2101             MOVS     R1,#+1
   \   00000006   0x4301             ORRS     R1,R1,R0
   \   00000008   0x....             LDR      R0,??DataTable157  ;; 0x4004804c
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    621              //SIM_SCGC6 &= ~SIM_SCGC6_FTF_MASK;
    622              
    623              // Finally, enable the LPTMR
    624              LPTMR0_CSR |= (LPTMR_CSR_TIE_MASK | LPTMR_CSR_TEN_MASK);  // Use this setting if using the LPTMR interrupt method
   \   0000000C   0x....             LDR      R0,??DataTable157_1  ;; 0x40040000
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x2141             MOVS     R1,#+65
   \   00000012   0x4301             ORRS     R1,R1,R0
   \   00000014   0x....             LDR      R0,??DataTable157_1  ;; 0x40040000
   \   00000016   0x6001             STR      R1,[R0, #+0]
    625              
    626                  
    627              //SMC_PMCTRL = SMC_PMCTRL_RUNM(2);
    628              
    629              
    630             
    631                  /*if((RTC_SR & RTC_SR_TAF_MASK) == 0x04)
    632                  {
    633                      RTC_TAR = RTC_TSR + RTC_refresh_rate;
    634                  }*/	
    635                  
    636                  // Enter LLS mode. 
    637                  //enter_lls();
    638                  
    639                      
    640                      // ** Replacing with the BME equivalent ** //
    641                  SMC_PMCTRL |= (SMC_PMCTRL_STOPM(0x3));
   \   00000018   0x....             LDR      R0,??DataTable157_2  ;; 0x4007e001
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0x2103             MOVS     R1,#+3
   \   0000001E   0x4301             ORRS     R1,R1,R0
   \   00000020   0x....             LDR      R0,??DataTable157_2  ;; 0x4007e001
   \   00000022   0x7001             STRB     R1,[R0, #+0]
    642                      //BME_BFI_B(&SMC_PMCTRL, 3<<SMC_PMCTRL_STOPM_SHIFT, SMC_PMCTRL_STOPM_SHIFT, 3);
    643                      
    644                  //temp32 = SMC_PMCTRL;
    645                  
    646                  //SCB_SCR = (SCB_SCR_SLEEPDEEP_MASK | SCB_SCR_SLEEPONEXIT_MASK);
    647                  SCB_SCR = (SCB_SCR_SLEEPDEEP_MASK);
   \   00000024   0x....             LDR      R0,??DataTable157_3  ;; 0xe000ed10
   \   00000026   0x2104             MOVS     R1,#+4
   \   00000028   0x6001             STR      R1,[R0, #+0]
    648                  
    649                  //FGPIOA_PCOR |= 0x8000;
    650                   while(1)
    651                  {
    652          #ifndef KEIL
    653          	asm("WFI");
   \                     ??Run_Drive_Test_Loop_0:
   \   0000002A   0xBF30             WFI
   \   0000002C   0xE7FD             B        ??Run_Drive_Test_Loop_0
    654          #else
    655          	__wfi();
    656          #endif
    657                  
    658                  
    659              }
    660          }
    661          

   \                                 In section .text, align 4, keep-with-next
    662          void RF_Test(void)
    663          {
    664              int i;
    665          
    666              // Set RTC alarm to wake up every 5 seconds
    667              RTC_refresh_rate = 4; // Set to equal desired rate - 1
   \                     RF_Test:
   \   00000000   0x....             LDR      R0,??DataTable6_3
   \   00000002   0x2104             MOVS     R1,#+4
   \   00000004   0x8001             STRH     R1,[R0, #+0]
    668              // Enter BLPI mode using the fast IRC    
    669              i = fei_fbi(4000000, 1);
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x....             LDR      R0,??DataTable6_4  ;; 0x3d0900
   \   0000000A   0x.... 0x....      BL       fei_fbi
   \   0000000E   0x0004             MOVS     R4,R0
    670              // Set LP bit to disable the FLL and enter BLPI
    671              MCG_C2 |= MCG_C2_LP_MASK;
   \   00000010   0x....             LDR      R0,??DataTable6_5  ;; 0x40064001
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2102             MOVS     R1,#+2
   \   00000016   0x4301             ORRS     R1,R1,R0
   \   00000018   0x....             LDR      R0,??DataTable6_5  ;; 0x40064001
   \   0000001A   0x7001             STRB     R1,[R0, #+0]
    672              // Set EREFS0 to allow the OSCERCLK to be enabled
    673              MCG_C2 |= MCG_C2_EREFS0_MASK;
   \   0000001C   0x....             LDR      R0,??DataTable6_5  ;; 0x40064001
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x2104             MOVS     R1,#+4
   \   00000022   0x4301             ORRS     R1,R1,R0
   \   00000024   0x....             LDR      R0,??DataTable6_5  ;; 0x40064001
   \   00000026   0x7001             STRB     R1,[R0, #+0]
    674              // Now enable OSCERCLK
    675              OSC0_CR |= OSC_CR_ERCLKEN_MASK;
   \   00000028   0x....             LDR      R0,??DataTable6_6  ;; 0x40065000
   \   0000002A   0x7800             LDRB     R0,[R0, #+0]
   \   0000002C   0x2180             MOVS     R1,#+128
   \   0000002E   0x4301             ORRS     R1,R1,R0
   \   00000030   0x....             LDR      R0,??DataTable6_6  ;; 0x40065000
   \   00000032   0x7001             STRB     R1,[R0, #+0]
    676              
    677              // enable the TPM1 Interrupt 
    678              enable_irq(18);
   \   00000034   0x2012             MOVS     R0,#+18
   \   00000036   0x.... 0x....      BL       enable_irq
    679              
    680              // Clear alarm flag and re-arm the RTC Alarm by adding 5 seconds to the present time
    681              RTC_TAR = (RTC_TSR + 5);
   \   0000003A   0x....             LDR      R0,??DataTable6_7  ;; 0x4003d000
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x1D40             ADDS     R0,R0,#+5
   \   00000040   0x....             LDR      R1,??DataTable6_8  ;; 0x4003d008
   \   00000042   0x6008             STR      R0,[R1, #+0]
    682              
    683              // Set up LLWU from the RTC Alarm
    684              LLWU_ME = LLWU_F3_MWUF5_MASK;
   \   00000044   0x....             LDR      R0,??DataTable6_9  ;; 0x4007c002
   \   00000046   0x2120             MOVS     R1,#+32
   \   00000048   0x7001             STRB     R1,[R0, #+0]
    685              
    686              // Setup inputs
    687              PORTB_PCR5 = PORT_PCR_MUX(0);  // V0
   \   0000004A   0x....             LDR      R0,??DataTable6_10  ;; 0x4004a014
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x6001             STR      R1,[R0, #+0]
    688              PORTB_PCR1 = PORT_PCR_MUX(0); //  V1
   \   00000050   0x....             LDR      R0,??DataTable6_11  ;; 0x4004a004
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x6001             STR      R1,[R0, #+0]
    689              
    690              // setup outputs
    691              PORTA_PCR12 = (PORT_PCR_MUX(0x2)); // TPM1_CH0 - Out0
   \   00000056   0x....             LDR      R0,??DataTable6_12  ;; 0x40049030
   \   00000058   0x2180             MOVS     R1,#+128
   \   0000005A   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   0000005C   0x6001             STR      R1,[R0, #+0]
    692              PORTB_PCR6  = (PORT_PCR_MUX(0x2)); // TPM0_CH3 - Out1
   \   0000005E   0x....             LDR      R0,??DataTable6_13  ;; 0x4004a018
   \   00000060   0x2180             MOVS     R1,#+128
   \   00000062   0x0089             LSLS     R1,R1,#+2        ;; #+512
   \   00000064   0x6001             STR      R1,[R0, #+0]
    693            
    694              // Enable the CMP clock gating
    695              SIM_SCGC4 |= SIM_SCGC4_CMP_MASK;
   \   00000066   0x....             LDR      R0,??DataTable6_14  ;; 0x40048034
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0x2180             MOVS     R1,#+128
   \   0000006C   0x0309             LSLS     R1,R1,#+12       ;; #+524288
   \   0000006E   0x4301             ORRS     R1,R1,R0
   \   00000070   0x....             LDR      R0,??DataTable6_14  ;; 0x40048034
   \   00000072   0x6001             STR      R1,[R0, #+0]
    696              // Enable the TPM0 and TPM1 clock gating
    697              SIM_SCGC6 |= SIM_SCGC6_TPM0_MASK | SIM_SCGC6_TPM1_MASK;
   \   00000074   0x....             LDR      R0,??DataTable6_15  ;; 0x4004803c
   \   00000076   0x6800             LDR      R0,[R0, #+0]
   \   00000078   0x21C0             MOVS     R1,#+192
   \   0000007A   0x0489             LSLS     R1,R1,#+18       ;; #+50331648
   \   0000007C   0x4301             ORRS     R1,R1,R0
   \   0000007E   0x....             LDR      R0,??DataTable6_15  ;; 0x4004803c
   \   00000080   0x6001             STR      R1,[R0, #+0]
    698              
    699              // Set CMP Filter Count and Hysteresis control to 0.  
    700              //  Filter should be disabled to allow for low lag time.   
    701              CMP0_CR0 = 0x00;
   \   00000082   0x....             LDR      R0,??DataTable6_16  ;; 0x40073000
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0x7001             STRB     R1,[R0, #+0]
    702              
    703              // Set CMP0_CR1 to a known state
    704              CMP0_CR1 = 0x00;
   \   00000088   0x....             LDR      R0,??DataTable7  ;; 0x40073001
   \   0000008A   0x2100             MOVS     R1,#+0
   \   0000008C   0x7001             STRB     R1,[R0, #+0]
    705              
    706              // Select the appropriate Mux control
    707              //  
    708              //  We want to know when V0 >= V1, therefore, set the inverted input to
    709              //  be V1.  Select the non-inverted input to be V0. 
    710              
    711              CMP0_MUXCR = 0x00;
   \   0000008E   0x....             LDR      R0,??DataTable6_17  ;; 0x40073005
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0x7001             STRB     R1,[R0, #+0]
    712              CMP0_MUXCR |= (CMP_MUXCR_PSEL(1) | CMP_MUXCR_MSEL(3));
   \   00000094   0x....             LDR      R0,??DataTable6_17  ;; 0x40073005
   \   00000096   0x7800             LDRB     R0,[R0, #+0]
   \   00000098   0x210B             MOVS     R1,#+11
   \   0000009A   0x4301             ORRS     R1,R1,R0
   \   0000009C   0x....             LDR      R0,??DataTable6_17  ;; 0x40073005
   \   0000009E   0x7001             STRB     R1,[R0, #+0]
    713              
    714              // select OSCERCLK as the TPM clock source    
    715              SIM_SOPT2 |= SIM_SOPT2_TPMSRC(2); // assumes default reset state to begin with
   \   000000A0   0x....             LDR      R0,??DataTable6_18  ;; 0x40048004
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0x2180             MOVS     R1,#+128
   \   000000A6   0x0489             LSLS     R1,R1,#+18       ;; #+33554432
   \   000000A8   0x4301             ORRS     R1,R1,R0
   \   000000AA   0x....             LDR      R0,??DataTable6_18  ;; 0x40048004
   \   000000AC   0x6001             STR      R1,[R0, #+0]
    716              
    717              // Move to VLPR mode
    718              if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK) != 4)
   \   000000AE   0x....             LDR      R0,??DataTable7_1  ;; 0x4007e003
   \   000000B0   0x7800             LDRB     R0,[R0, #+0]
   \   000000B2   0xB2C0             UXTB     R0,R0
   \   000000B4   0x0640             LSLS     R0,R0,#+25       ;; ZeroExtS R0,R0,#+25,#+25
   \   000000B6   0x0E40             LSRS     R0,R0,#+25
   \   000000B8   0x2804             CMP      R0,#+4
   \   000000BA   0xD03F             BEQ      ??RF_Test_0
    719              {
    720                  SMC_PMCTRL = SMC_PMCTRL_RUNM(2);
   \   000000BC   0x....             LDR      R0,??DataTable7_2  ;; 0x4007e001
   \   000000BE   0x2140             MOVS     R1,#+64
   \   000000C0   0x7001             STRB     R1,[R0, #+0]
   \   000000C2   0xE03B             B        ??RF_Test_0
    721              }  
    722              
    723              // Now enter the main loop
    724              while (1)
    725              {     
    726                // enable the comparator
    727                CMP0_CR1 |= CMP_CR1_EN_MASK;
    728                // Enable OSCERCLK
    729                OSC0_CR |= OSC_CR_ERCLKEN_MASK;
    730                
    731                // configure TPM1 but do not enable just yet
    732                TPM1_SC = 0x0;          // Make sure clock is disabled 
    733                TPM1_CNT = 0x00000000;  // Clear counter.
    734                TPM1_CONF = 0xC0;       // Allow counters to run in debug
    735                TPM1_C0SC = 0x000000E8; // Edge aligned PWM, output compare, enable Channel interrupt 
    736                TPM1_C0V = 0x00000146;  // Set pulse width, 327 cycles of 32.768kHz  = 9.979ms
    737                TPM1_MOD = 0x000003F0;  // Set MOD to be greater than Value register   
    738                                                            
    739                // Configure TPM0 but do not enable just yet
    740                TPM0_SC = 0x0;          // Make sure clock is disabled 
    741                TPM0_CNT = 0x00000000;  // Clear counter.
    742                TPM0_CONF = 0xC0;       // Allow counters to run in debug
    743                TPM0_C3SC = 0x000000A8; // Edge aligned PWM, output compare
    744                TPM0_C3V = 0x00000146;  // Set pulse width, 327 cycles of 32.768kHz  = 9.979ms
    745                TPM0_MOD = 0x000003F0;  // Set MOD to be greater than Value register
    746                
    747                // Wait additional delay to ensure comparator is stable
    748                for (i=0 ; i <17; i++);
    749                
    750                // Check CMP result to determine if Out1 should be toggled
    751                if (CMP0_SCR & CMP_SCR_COUT_MASK)
    752                {
    753                  // trigger both TPMs for Out0 and Out1 
    754                  TPM0_SC = 0x00000008;  // enable TPM clock
    755                  TPM1_SC = 0x00000088;  // enable TPM clock and clear TOF
    756                }
    757                else
    758                {
    759                  // Trigger just the TPM1 for Out0
    760                  TPM1_SC = 0x00000088;  // enable TPM clock and clear TOF
   \                     ??RF_Test_1:
   \   000000C4   0x....             LDR      R0,??DataTable9  ;; 0x40039000
   \   000000C6   0x2188             MOVS     R1,#+136
   \   000000C8   0x6001             STR      R1,[R0, #+0]
    761                }
    762                // Turn off CMP to save current
    763                CMP0_CR1 &= ~CMP_CR1_EN_MASK;
   \                     ??RF_Test_2:
   \   000000CA   0x....             LDR      R0,??DataTable7  ;; 0x40073001
   \   000000CC   0x7800             LDRB     R0,[R0, #+0]
   \   000000CE   0x21FE             MOVS     R1,#+254
   \   000000D0   0x4001             ANDS     R1,R1,R0
   \   000000D2   0x....             LDR      R0,??DataTable7  ;; 0x40073001
   \   000000D4   0x7001             STRB     R1,[R0, #+0]
    764                
    765                // enter vlps while pulse is active to reduce Idd, TPM CHF interrupt will exit VLPS      
    766                SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
   \   000000D6   0x....             LDR      R0,??DataTable7_2  ;; 0x4007e001
   \   000000D8   0x7800             LDRB     R0,[R0, #+0]
   \   000000DA   0x21F8             MOVS     R1,#+248
   \   000000DC   0x4001             ANDS     R1,R1,R0
   \   000000DE   0x....             LDR      R0,??DataTable7_2  ;; 0x4007e001
   \   000000E0   0x7001             STRB     R1,[R0, #+0]
    767                SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x2); 
   \   000000E2   0x....             LDR      R0,??DataTable7_2  ;; 0x4007e001
   \   000000E4   0x7800             LDRB     R0,[R0, #+0]
   \   000000E6   0x2102             MOVS     R1,#+2
   \   000000E8   0x4301             ORRS     R1,R1,R0
   \   000000EA   0x....             LDR      R0,??DataTable7_2  ;; 0x4007e001
   \   000000EC   0x7001             STRB     R1,[R0, #+0]
    768                // wait for write to complete to SMC before stopping core 
    769                i = SMC_PMCTRL;
   \   000000EE   0x....             LDR      R0,??DataTable7_2  ;; 0x4007e001
   \   000000F0   0x7804             LDRB     R4,[R0, #+0]
   \   000000F2   0xB2E4             UXTB     R4,R4
    770            
    771                SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
   \   000000F4   0x....             LDR      R0,??DataTable8  ;; 0xe000ed10
   \   000000F6   0x6800             LDR      R0,[R0, #+0]
   \   000000F8   0x2104             MOVS     R1,#+4
   \   000000FA   0x4301             ORRS     R1,R1,R0
   \   000000FC   0x....             LDR      R0,??DataTable8  ;; 0xe000ed10
   \   000000FE   0x6001             STR      R1,[R0, #+0]
    772          #ifdef CMSIS
    773                //  Set the SLEEPDEEP bit to enable deep sleep mode (STOP)       
    774                __wfi();
    775          #else      
    776                asm("WFI");
   \   00000100   0xBF30             WFI
    777          #endif
    778            
    779                // Turn off unused clock sources to save current once TPM pulse ends
    780                OSC0_CR &= ~OSC_CR_ERCLKEN_MASK;
   \   00000102   0x....             LDR      R0,??DataTable6_6  ;; 0x40065000
   \   00000104   0x7800             LDRB     R0,[R0, #+0]
   \   00000106   0x0640             LSLS     R0,R0,#+25       ;; ZeroExtS R0,R0,#+25,#+25
   \   00000108   0x0E40             LSRS     R0,R0,#+25
   \   0000010A   0x....             LDR      R1,??DataTable6_6  ;; 0x40065000
   \   0000010C   0x7008             STRB     R0,[R1, #+0]
    781              
    782                // now that all tasks are complete enter LLS for additional current savings
    783                SMC_PMCTRL &= ~SMC_PMCTRL_STOPM_MASK; 
   \   0000010E   0x....             LDR      R0,??DataTable7_2  ;; 0x4007e001
   \   00000110   0x7800             LDRB     R0,[R0, #+0]
   \   00000112   0x21F8             MOVS     R1,#+248
   \   00000114   0x4001             ANDS     R1,R1,R0
   \   00000116   0x....             LDR      R0,??DataTable7_2  ;; 0x4007e001
   \   00000118   0x7001             STRB     R1,[R0, #+0]
    784                SMC_PMCTRL |=  SMC_PMCTRL_STOPM(0x3); 
   \   0000011A   0x....             LDR      R0,??DataTable7_2  ;; 0x4007e001
   \   0000011C   0x7800             LDRB     R0,[R0, #+0]
   \   0000011E   0x2103             MOVS     R1,#+3
   \   00000120   0x4301             ORRS     R1,R1,R0
   \   00000122   0x....             LDR      R0,??DataTable7_2  ;; 0x4007e001
   \   00000124   0x7001             STRB     R1,[R0, #+0]
    785                // wait for write to complete to SMC before stopping core   
    786                i = SMC_PMCTRL;
   \   00000126   0x....             LDR      R0,??DataTable7_2  ;; 0x4007e001
   \   00000128   0x7800             LDRB     R0,[R0, #+0]
   \   0000012A   0xB2C0             UXTB     R0,R0
   \   0000012C   0x0004             MOVS     R4,R0
    787                // Now execute the stop instruction to go into LLS 
    788                SCB_SCR |= SCB_SCR_SLEEPDEEP_MASK;
   \   0000012E   0x....             LDR      R0,??DataTable8  ;; 0xe000ed10
   \   00000130   0x6800             LDR      R0,[R0, #+0]
   \   00000132   0x2104             MOVS     R1,#+4
   \   00000134   0x4301             ORRS     R1,R1,R0
   \   00000136   0x....             LDR      R0,??DataTable8  ;; 0xe000ed10
   \   00000138   0x6001             STR      R1,[R0, #+0]
    789          #ifdef CMSIS
    790                // Set the SLEEPDEEP bit to enable deep sleep mode (STOP)       
    791                __wfi();
    792          #else      
    793                asm("WFI");
   \   0000013A   0xBF30             WFI
   \                     ??RF_Test_0:
   \   0000013C   0x....             LDR      R0,??DataTable7  ;; 0x40073001
   \   0000013E   0x7800             LDRB     R0,[R0, #+0]
   \   00000140   0x2101             MOVS     R1,#+1
   \   00000142   0x4301             ORRS     R1,R1,R0
   \   00000144   0x....             LDR      R0,??DataTable7  ;; 0x40073001
   \   00000146   0x7001             STRB     R1,[R0, #+0]
   \   00000148   0x....             LDR      R0,??DataTable6_6  ;; 0x40065000
   \   0000014A   0x7800             LDRB     R0,[R0, #+0]
   \   0000014C   0x2180             MOVS     R1,#+128
   \   0000014E   0x4301             ORRS     R1,R1,R0
   \   00000150   0x....             LDR      R0,??DataTable6_6  ;; 0x40065000
   \   00000152   0x7001             STRB     R1,[R0, #+0]
   \   00000154   0x....             LDR      R0,??DataTable9  ;; 0x40039000
   \   00000156   0x2100             MOVS     R1,#+0
   \   00000158   0x6001             STR      R1,[R0, #+0]
   \   0000015A   0x....             LDR      R0,??DataTable9_1  ;; 0x40039004
   \   0000015C   0x2100             MOVS     R1,#+0
   \   0000015E   0x6001             STR      R1,[R0, #+0]
   \   00000160   0x....             LDR      R0,??DataTable9_2  ;; 0x40039084
   \   00000162   0x21C0             MOVS     R1,#+192
   \   00000164   0x6001             STR      R1,[R0, #+0]
   \   00000166   0x....             LDR      R0,??DataTable9_3  ;; 0x4003900c
   \   00000168   0x21E8             MOVS     R1,#+232
   \   0000016A   0x6001             STR      R1,[R0, #+0]
   \   0000016C   0x....             LDR      R0,??DataTable9_4  ;; 0x40039010
   \   0000016E   0x21A3             MOVS     R1,#+163
   \   00000170   0x0049             LSLS     R1,R1,#+1        ;; #+326
   \   00000172   0x6001             STR      R1,[R0, #+0]
   \   00000174   0x....             LDR      R0,??DataTable9_5  ;; 0x40039008
   \   00000176   0x21FC             MOVS     R1,#+252
   \   00000178   0x0089             LSLS     R1,R1,#+2        ;; #+1008
   \   0000017A   0x6001             STR      R1,[R0, #+0]
   \   0000017C   0x....             LDR      R0,??DataTable9_6  ;; 0x40038000
   \   0000017E   0x2100             MOVS     R1,#+0
   \   00000180   0x6001             STR      R1,[R0, #+0]
   \   00000182   0x....             LDR      R0,??DataTable9_7  ;; 0x40038004
   \   00000184   0x2100             MOVS     R1,#+0
   \   00000186   0x6001             STR      R1,[R0, #+0]
   \   00000188   0x....             LDR      R0,??DataTable9_8  ;; 0x40038084
   \   0000018A   0x21C0             MOVS     R1,#+192
   \   0000018C   0x6001             STR      R1,[R0, #+0]
   \   0000018E   0x....             LDR      R0,??DataTable9_9  ;; 0x40038024
   \   00000190   0x21A8             MOVS     R1,#+168
   \   00000192   0x6001             STR      R1,[R0, #+0]
   \   00000194   0x....             LDR      R0,??DataTable9_10  ;; 0x40038028
   \   00000196   0x21A3             MOVS     R1,#+163
   \   00000198   0x0049             LSLS     R1,R1,#+1        ;; #+326
   \   0000019A   0x6001             STR      R1,[R0, #+0]
   \   0000019C   0x....             LDR      R0,??DataTable9_11  ;; 0x40038008
   \   0000019E   0x21FC             MOVS     R1,#+252
   \   000001A0   0x0089             LSLS     R1,R1,#+2        ;; #+1008
   \   000001A2   0x6001             STR      R1,[R0, #+0]
   \   000001A4   0x2400             MOVS     R4,#+0
   \   000001A6   0xE000             B        ??RF_Test_3
   \                     ??RF_Test_4:
   \   000001A8   0x1C64             ADDS     R4,R4,#+1
   \                     ??RF_Test_3:
   \   000001AA   0x2C11             CMP      R4,#+17
   \   000001AC   0xDBFC             BLT      ??RF_Test_4
   \   000001AE   0x....             LDR      R0,??DataTable9_12  ;; 0x40073003
   \   000001B0   0x7800             LDRB     R0,[R0, #+0]
   \   000001B2   0x07C0             LSLS     R0,R0,#+31
   \   000001B4   0xD586             BPL      ??RF_Test_1
   \   000001B6   0x....             LDR      R0,??DataTable9_6  ;; 0x40038000
   \   000001B8   0x2108             MOVS     R1,#+8
   \   000001BA   0x6001             STR      R1,[R0, #+0]
   \   000001BC   0x....             LDR      R0,??DataTable9  ;; 0x40039000
   \   000001BE   0x2188             MOVS     R1,#+136
   \   000001C0   0x6001             STR      R1,[R0, #+0]
   \   000001C2   0xE782             B        ??RF_Test_2
    794          #endif
    795          
    796              }
    797          }
    798          
    799          ////////////////////////////////////////////////////////////////////////////////////////
    800          // LPTMR IRQ Handler
    801          /////////////////////////////////////////////////////////////////////////////////////////

   \                                 In section .textrw, align 2, keep-with-next
    802          void LPTMR_IRQHandler(void)
    803          {
   \                     LPTMR_IRQHandler:
   \   00000000   0xB500             PUSH     {LR}
    804              uint32 temp32, i;
    805              
    806              //FGPIOA_PSOR |= 0x8000;   // This sets the clkout pin and is used purely for power profiling
    807              
    808              // Move to VLPR mode
    809              /*if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK) != 4)
    810              {
    811                  SMC_PMCTRL = SMC_PMCTRL_RUNM(2);
    812              }*/
    813              
    814              if (test_mode == 1)
   \   00000002   0x....             LDR      R0,??DataTable157_4
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD107             BNE      ??LPTMR_IRQHandler_0
    815              {
    816              /*
    817              // First ensure that V0 has been selected. Note that the CMP should already be off at this step.  
    818              CMP0_MUXCR = (CMP_MUXCR_PSEL(CMP_CHANNEL_V0) | CMP_MUXCR_MSEL(7));
    819              
    820              // Now perform conversion
    821              CMP0_CR1 |= CMP_CR1_EN_MASK;
    822              
    823              // Reset semaphore i
    824              i = 0;
    825              // WAIT!!  Must meet the settling time of 40 us here!
    826              while(i<80)
    827              //while(i<2)   // Use this if using the external crystal
    828                  i++;
    829              
    830              // Read the output and make decision
    831              if (CMP0_SCR & CMP_SCR_COUT_MASK)
    832              {
    833          #ifdef DEBUG_TOWER
    834                  FGPIOB_PSOR |= 0x100;
    835          #else
    836                  FGPIOA_PSOR |= 0x1000;
    837          #endif
    838              }
    839              else
    840              {
    841          #ifdef DEBUG_TOWER
    842                  FGPIOB_PCOR |= 0x100;
    843          #else
    844                  FGPIOA_PCOR |= 0x1000;
    845          #endif
    846              }
    847              
    848              // Now select V1
    849              CMP0_MUXCR = (CMP_MUXCR_PSEL(CMP_CHANNEL_V1) | CMP_MUXCR_MSEL(CMP_DACIN));
    850              
    851              // Read the output and make decision
    852              if (CMP0_SCR & CMP_SCR_COUT_MASK)
    853              {
    854          #ifdef DEBUG_TOWER
    855                  FGPIOB_PSOR |= 0x200;
    856          #else
    857                  FGPIOB_PSOR |= 0x40;
    858          #endif
    859              }
    860              else
    861              {
    862          #ifdef DEBUG_TOWER
    863                  FGPIOB_PCOR |= 0x200;
    864          #else
    865                  FGPIOB_PCOR |= 0x40;
    866          #endif
    867              }
    868              
    869              CMP0_CR1 &= ~CMP_CR1_EN_MASK;   // Ensure CMP is off before leaving ISR
    870              
    871              LPTMR0_CSR |=  LPTMR_CSR_TCF_MASK;   // write 1 to TCF to clear the LPT timer compare flag
    872              //LPTMR0_CSR |= (LPTMR_CSR_TEN_MASK);  // Enable the timer
    873              //wait for write to complete to  before returning 
    874              temp32 = LPTMR0_CSR;*/
    875                  
    876                  while(1)
    877                  {
    878                      FGPIOA_PCOR = 0x1000;
   \                     ??LPTMR_IRQHandler_1:
   \   0000000A   0x....             LDR      R0,??DataTable157_5  ;; 0xf80ff008
   \   0000000C   0x2180             MOVS     R1,#+128
   \   0000000E   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \   00000010   0x6001             STR      R1,[R0, #+0]
    879                      FGPIOB_PTOR = 0x40;
   \   00000012   0x....             LDR      R0,??DataTable157_6  ;; 0xf80ff04c
   \   00000014   0x2140             MOVS     R1,#+64
   \   00000016   0x6001             STR      R1,[R0, #+0]
   \   00000018   0xE7F7             B        ??LPTMR_IRQHandler_1
    880                  }
    881              }
    882              else if (test_mode == 2)
   \                     ??LPTMR_IRQHandler_0:
   \   0000001A   0x....             LDR      R0,??DataTable157_4
   \   0000001C   0x8800             LDRH     R0,[R0, #+0]
   \   0000001E   0x2802             CMP      R0,#+2
   \   00000020   0xD115             BNE      ??LPTMR_IRQHandler_2
    883              {
    884                  GPIOA_PTOR|=(1<<12);                       // Toggle A12 GPIO at 1Hz for OUT0 
   \   00000022   0x....             LDR      R0,??DataTable157_7  ;; 0x400ff00c
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x2180             MOVS     R1,#+128
   \   00000028   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \   0000002A   0x4301             ORRS     R1,R1,R0
   \   0000002C   0x....             LDR      R0,??DataTable157_7  ;; 0x400ff00c
   \   0000002E   0x6001             STR      R1,[R0, #+0]
    885                  LPTMR0_CSR |=  LPTMR_CSR_TCF_MASK;         // write 1 to TCF to clear the LPT timer compare flag
   \   00000030   0x....             LDR      R0,??DataTable157_1  ;; 0x40040000
   \   00000032   0x6800             LDR      R0,[R0, #+0]
   \   00000034   0x2180             MOVS     R1,#+128
   \   00000036   0x4301             ORRS     R1,R1,R0
   \   00000038   0x....             LDR      R0,??DataTable157_1  ;; 0x40040000
   \   0000003A   0x6001             STR      R1,[R0, #+0]
    886                  LPTMR0_CSR |= (LPTMR_CSR_TEN_MASK);
   \   0000003C   0x....             LDR      R0,??DataTable157_1  ;; 0x40040000
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x4301             ORRS     R1,R1,R0
   \   00000044   0x....             LDR      R0,??DataTable157_1  ;; 0x40040000
   \   00000046   0x6001             STR      R1,[R0, #+0]
    887                  /*wait for write to complete to  before returning */  
    888                  temp32 = LPTMR0_CSR;                       // dummy read
   \   00000048   0x....             LDR      R0,??DataTable157_1  ;; 0x40040000
   \   0000004A   0x6800             LDR      R0,[R0, #+0]
   \   0000004C   0xE014             B        ??LPTMR_IRQHandler_3
    889              }
    890              else if (test_mode == 3)
   \                     ??LPTMR_IRQHandler_2:
   \   0000004E   0x....             LDR      R0,??DataTable157_4
   \   00000050   0x8800             LDRH     R0,[R0, #+0]
   \   00000052   0x2803             CMP      R0,#+3
   \   00000054   0xD110             BNE      ??LPTMR_IRQHandler_3
    891              {
    892                  LPTMR_flag = TRUE;
   \   00000056   0x....             LDR      R0,??DataTable157_8
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x8001             STRH     R1,[R0, #+0]
    893                  LPTMR0_CSR |=  LPTMR_CSR_TCF_MASK;   // write 1 to TCF to clear the LPT timer compare flag
   \   0000005C   0x....             LDR      R0,??DataTable157_1  ;; 0x40040000
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x2180             MOVS     R1,#+128
   \   00000062   0x4301             ORRS     R1,R1,R0
   \   00000064   0x....             LDR      R0,??DataTable157_1  ;; 0x40040000
   \   00000066   0x6001             STR      R1,[R0, #+0]
    894                  LPTMR0_CSR |= (LPTMR_CSR_TEN_MASK);
   \   00000068   0x....             LDR      R0,??DataTable157_1  ;; 0x40040000
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x4301             ORRS     R1,R1,R0
   \   00000070   0x....             LDR      R0,??DataTable157_1  ;; 0x40040000
   \   00000072   0x6001             STR      R1,[R0, #+0]
    895                  /*wait for write to complete to  before returning */  
    896                  temp32 = LPTMR0_CSR;
   \   00000074   0x....             LDR      R0,??DataTable157_1  ;; 0x40040000
   \   00000076   0x6800             LDR      R0,[R0, #+0]
    897              }
    898              else
    899              {}
    900              
    901              //FGPIOA_PCOR |= 0x8000;  // This clears the clkout pin and is used purely for power profiling
    902          }
   \                     ??LPTMR_IRQHandler_3:
   \   00000078   0xBD00             POP      {PC}             ;; return
    903          
    904          
    905          
    906          
    907          //////////////////////////////////////////////////////////////////////////////////////////////////////
    908          // CMP0 IRQ Handler
    909          /////////////////////
    910          

   \                                 In section .text, align 2, keep-with-next
    911          void CMP0_IRQHandler(void)
    912          {
   \                     CMP0_IRQHandler:
   \   00000000   0xB500             PUSH     {LR}
    913              uint32 temp32, i, j;
    914              
    915              FGPIOA_PSOR |= 0x8000;  // This sets the clkout pin and is used purely for power profiling
   \   00000002   0x....             LDR      R1,??DataTable9_13  ;; 0xf80ff004
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x2280             MOVS     R2,#+128
   \   00000008   0x0212             LSLS     R2,R2,#+8        ;; #+32768
   \   0000000A   0x430A             ORRS     R2,R2,R1
   \   0000000C   0x....             LDR      R1,??DataTable9_13  ;; 0xf80ff004
   \   0000000E   0x600A             STR      R2,[R1, #+0]
    916              
    917              LPTMR0_CSR &= ~(LPTMR_CSR_TEN_MASK);
   \   00000010   0x....             LDR      R1,??DataTable9_14  ;; 0x40040000
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x2201             MOVS     R2,#+1
   \   00000016   0x4391             BICS     R1,R1,R2
   \   00000018   0x....             LDR      R2,??DataTable9_14  ;; 0x40040000
   \   0000001A   0x6011             STR      R1,[R2, #+0]
    918              
    919              // Move to VLPR mode
    920              if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK) != 4)
   \   0000001C   0x....             LDR      R1,??DataTable7_1  ;; 0x4007e003
   \   0000001E   0x7809             LDRB     R1,[R1, #+0]
   \   00000020   0xB2C9             UXTB     R1,R1
   \   00000022   0x0649             LSLS     R1,R1,#+25       ;; ZeroExtS R1,R1,#+25,#+25
   \   00000024   0x0E49             LSRS     R1,R1,#+25
   \   00000026   0x2904             CMP      R1,#+4
   \   00000028   0xD002             BEQ      ??CMP0_IRQHandler_0
    921              {
    922                  SMC_PMCTRL = SMC_PMCTRL_RUNM(2);
   \   0000002A   0x....             LDR      R1,??DataTable7_2  ;; 0x4007e001
   \   0000002C   0x2240             MOVS     R2,#+64
   \   0000002E   0x700A             STRB     R2,[R1, #+0]
    923              }
    924              
    925              if ((CMP0_SCR & CMP_SCR_CFR_MASK) == CMP_SCR_CFR_MASK)
   \                     ??CMP0_IRQHandler_0:
   \   00000030   0x....             LDR      R1,??DataTable9_12  ;; 0x40073003
   \   00000032   0x7809             LDRB     R1,[R1, #+0]
   \   00000034   0xB2C9             UXTB     R1,R1
   \   00000036   0x0749             LSLS     R1,R1,#+29
   \   00000038   0xD50B             BPL      ??CMP0_IRQHandler_1
    926              {
    927                  j = 0;
   \   0000003A   0x2000             MOVS     R0,#+0
    928                  
    929                  CMP0_SCR = (CMP_SCR_CFR_MASK | CMP_SCR_IEF_MASK);
   \   0000003C   0x....             LDR      R1,??DataTable9_12  ;; 0x40073003
   \   0000003E   0x220C             MOVS     R2,#+12
   \   00000040   0x700A             STRB     R2,[R1, #+0]
    930                  
    931          #ifdef DEBUG_TOWER
    932                  FGPIOB_PSOR |= 0x100;
    933          #else
    934                  FGPIOA_PSOR |= 0x1000;
   \   00000042   0x....             LDR      R1,??DataTable9_13  ;; 0xf80ff004
   \   00000044   0x6809             LDR      R1,[R1, #+0]
   \   00000046   0x2280             MOVS     R2,#+128
   \   00000048   0x0152             LSLS     R2,R2,#+5        ;; #+4096
   \   0000004A   0x430A             ORRS     R2,R2,R1
   \   0000004C   0x....             LDR      R1,??DataTable9_13  ;; 0xf80ff004
   \   0000004E   0x600A             STR      R2,[R1, #+0]
   \   00000050   0xE00F             B        ??CMP0_IRQHandler_2
    935          #endif
    936              }
    937              else if ((CMP0_SCR & CMP_SCR_CFF_MASK) == CMP_SCR_CFF_MASK)
   \                     ??CMP0_IRQHandler_1:
   \   00000052   0x....             LDR      R1,??DataTable9_12  ;; 0x40073003
   \   00000054   0x7809             LDRB     R1,[R1, #+0]
   \   00000056   0xB2C9             UXTB     R1,R1
   \   00000058   0x0789             LSLS     R1,R1,#+30
   \   0000005A   0xD50A             BPL      ??CMP0_IRQHandler_2
    938              {
    939                  j = 1;
   \   0000005C   0x2001             MOVS     R0,#+1
    940                  
    941                  CMP0_SCR = (CMP_SCR_CFF_MASK | CMP_SCR_IER_MASK);
   \   0000005E   0x....             LDR      R1,??DataTable9_12  ;; 0x40073003
   \   00000060   0x2212             MOVS     R2,#+18
   \   00000062   0x700A             STRB     R2,[R1, #+0]
    942                  
    943          #ifdef DEBUG_TOWER
    944                  FGPIOB_PCOR |= 0x100;
    945          #else
    946                  FGPIOA_PCOR |= 0x1000;
   \   00000064   0x....             LDR      R1,??DataTable9_15  ;; 0xf80ff008
   \   00000066   0x6809             LDR      R1,[R1, #+0]
   \   00000068   0x2280             MOVS     R2,#+128
   \   0000006A   0x0152             LSLS     R2,R2,#+5        ;; #+4096
   \   0000006C   0x430A             ORRS     R2,R2,R1
   \   0000006E   0x....             LDR      R1,??DataTable9_15  ;; 0xf80ff008
   \   00000070   0x600A             STR      R2,[R1, #+0]
    947          #endif
    948              }
    949              
    950              // Now select V1
    951              CMP0_CR1 &= ~(CMP_CR1_EN_MASK | CMP_CR1_TRIGM_MASK);
   \                     ??CMP0_IRQHandler_2:
   \   00000072   0x....             LDR      R1,??DataTable7  ;; 0x40073001
   \   00000074   0x7809             LDRB     R1,[R1, #+0]
   \   00000076   0x22DE             MOVS     R2,#+222
   \   00000078   0x400A             ANDS     R2,R2,R1
   \   0000007A   0x....             LDR      R1,??DataTable7  ;; 0x40073001
   \   0000007C   0x700A             STRB     R2,[R1, #+0]
    952              //CMP0_MUXCR = 0x00;
    953              CMP0_MUXCR = (CMP_MUXCR_PSEL(CMP_CHANNEL_V1) | CMP_MUXCR_MSEL(CMP_DACIN));
   \   0000007E   0x....             LDR      R1,??DataTable9_16  ;; 0x40073005
   \   00000080   0x221F             MOVS     R2,#+31
   \   00000082   0x700A             STRB     R2,[R1, #+0]
    954              
    955              // Now perform conversion
    956              CMP0_CR1 |= CMP_CR1_EN_MASK;
   \   00000084   0x....             LDR      R1,??DataTable7  ;; 0x40073001
   \   00000086   0x7809             LDRB     R1,[R1, #+0]
   \   00000088   0x2201             MOVS     R2,#+1
   \   0000008A   0x430A             ORRS     R2,R2,R1
   \   0000008C   0x....             LDR      R1,??DataTable7  ;; 0x40073001
   \   0000008E   0x700A             STRB     R2,[R1, #+0]
    957              i = 0;
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0xE000             B        ??CMP0_IRQHandler_3
    958              // WAIT!!  Must meet the settling time of 40 us here!  (85 when using BLPI, 3 when using BLPE)
    959              while(i<85)
    960              //while(i<3)
    961                  i++;
   \                     ??CMP0_IRQHandler_4:
   \   00000094   0x1C49             ADDS     R1,R1,#+1
   \                     ??CMP0_IRQHandler_3:
   \   00000096   0x2955             CMP      R1,#+85
   \   00000098   0xD3FC             BCC      ??CMP0_IRQHandler_4
    962              
    963              // Read the output and make decision
    964              if (CMP0_SCR & CMP_SCR_COUT_MASK)
   \   0000009A   0x....             LDR      R1,??DataTable9_12  ;; 0x40073003
   \   0000009C   0x7809             LDRB     R1,[R1, #+0]
   \   0000009E   0x07C9             LSLS     R1,R1,#+31
   \   000000A0   0xD506             BPL      ??CMP0_IRQHandler_5
    965              {
    966          #ifdef DEBUG_TOWER
    967                  FGPIOB_PSOR |= 0x200;
    968          #else
    969                  FGPIOB_PSOR |= 0x40;
   \   000000A2   0x....             LDR      R1,??DataTable9_17  ;; 0xf80ff044
   \   000000A4   0x6809             LDR      R1,[R1, #+0]
   \   000000A6   0x2240             MOVS     R2,#+64
   \   000000A8   0x430A             ORRS     R2,R2,R1
   \   000000AA   0x....             LDR      R1,??DataTable9_17  ;; 0xf80ff044
   \   000000AC   0x600A             STR      R2,[R1, #+0]
   \   000000AE   0xE005             B        ??CMP0_IRQHandler_6
    970          #endif
    971              }
    972              else
    973              {
    974          #ifdef DEBUG_TOWER
    975                  FGPIOB_PCOR |= 0x200;
    976          #else
    977                  FGPIOB_PCOR |= 0x40;
   \                     ??CMP0_IRQHandler_5:
   \   000000B0   0x....             LDR      R1,??DataTable9_18  ;; 0xf80ff048
   \   000000B2   0x6809             LDR      R1,[R1, #+0]
   \   000000B4   0x2240             MOVS     R2,#+64
   \   000000B6   0x430A             ORRS     R2,R2,R1
   \   000000B8   0x....             LDR      R1,??DataTable9_18  ;; 0xf80ff048
   \   000000BA   0x600A             STR      R2,[R1, #+0]
    978          #endif
    979              }
    980              
    981              CMP0_CR1 &= ~CMP_CR1_EN_MASK;
   \                     ??CMP0_IRQHandler_6:
   \   000000BC   0x....             LDR      R1,??DataTable7  ;; 0x40073001
   \   000000BE   0x7809             LDRB     R1,[R1, #+0]
   \   000000C0   0x22FE             MOVS     R2,#+254
   \   000000C2   0x400A             ANDS     R2,R2,R1
   \   000000C4   0x....             LDR      R1,??DataTable7  ;; 0x40073001
   \   000000C6   0x700A             STRB     R2,[R1, #+0]
    982              CMP0_CR1 |= CMP_CR1_TRIGM_MASK;
   \   000000C8   0x....             LDR      R1,??DataTable7  ;; 0x40073001
   \   000000CA   0x7809             LDRB     R1,[R1, #+0]
   \   000000CC   0x2220             MOVS     R2,#+32
   \   000000CE   0x430A             ORRS     R2,R2,R1
   \   000000D0   0x....             LDR      R1,??DataTable7  ;; 0x40073001
   \   000000D2   0x700A             STRB     R2,[R1, #+0]
    983              CMP0_MUXCR = (CMP_MUXCR_PSEL(CMP_CHANNEL_V0) 
    984                            | CMP_MUXCR_MSEL(CMP_DACIN));
   \   000000D4   0x....             LDR      R1,??DataTable9_16  ;; 0x40073005
   \   000000D6   0x220F             MOVS     R2,#+15
   \   000000D8   0x700A             STRB     R2,[R1, #+0]
    985              if (j == 0)
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD106             BNE      ??CMP0_IRQHandler_7
    986                  CMP0_SCR |= CMP_SCR_IEF_MASK;
   \   000000DE   0x....             LDR      R0,??DataTable9_12  ;; 0x40073003
   \   000000E0   0x7800             LDRB     R0,[R0, #+0]
   \   000000E2   0x2108             MOVS     R1,#+8
   \   000000E4   0x4301             ORRS     R1,R1,R0
   \   000000E6   0x....             LDR      R0,??DataTable9_12  ;; 0x40073003
   \   000000E8   0x7001             STRB     R1,[R0, #+0]
   \   000000EA   0xE005             B        ??CMP0_IRQHandler_8
    987              else
    988                  CMP0_SCR |= CMP_SCR_IER_MASK;
   \                     ??CMP0_IRQHandler_7:
   \   000000EC   0x....             LDR      R0,??DataTable9_12  ;; 0x40073003
   \   000000EE   0x7800             LDRB     R0,[R0, #+0]
   \   000000F0   0x2110             MOVS     R1,#+16
   \   000000F2   0x4301             ORRS     R1,R1,R0
   \   000000F4   0x....             LDR      R0,??DataTable9_12  ;; 0x40073003
   \   000000F6   0x7001             STRB     R1,[R0, #+0]
    989              
    990              CMP0_CR1 |= CMP_CR1_EN_MASK;
   \                     ??CMP0_IRQHandler_8:
   \   000000F8   0x....             LDR      R0,??DataTable7  ;; 0x40073001
   \   000000FA   0x7800             LDRB     R0,[R0, #+0]
   \   000000FC   0x2101             MOVS     R1,#+1
   \   000000FE   0x4301             ORRS     R1,R1,R0
   \   00000100   0x....             LDR      R0,??DataTable7  ;; 0x40073001
   \   00000102   0x7001             STRB     R1,[R0, #+0]
    991              
    992              
    993              //LPTMR0_CSR |=  LPTMR_CSR_TCF_MASK;   // write 1 to TCF to clear the LPT timer compare flag
    994              LPTMR0_CSR |= (LPTMR_CSR_TEN_MASK);
   \   00000104   0x....             LDR      R0,??DataTable9_14  ;; 0x40040000
   \   00000106   0x6800             LDR      R0,[R0, #+0]
   \   00000108   0x2101             MOVS     R1,#+1
   \   0000010A   0x4301             ORRS     R1,R1,R0
   \   0000010C   0x....             LDR      R0,??DataTable9_14  ;; 0x40040000
   \   0000010E   0x6001             STR      R1,[R0, #+0]
    995              //wait for write to complete to  before returning 
    996              //temp32 = LPTMR0_CSR;
    997              
    998              
    999              CMP0_flag = TRUE;
   \   00000110   0x....             LDR      R0,??DataTable9_19
   \   00000112   0x2101             MOVS     R1,#+1
   \   00000114   0x8001             STRH     R1,[R0, #+0]
   1000             
   1001              FGPIOA_PCOR |= 0x8000;  // This clears the clkout pin and is used purely for power profiling
   \   00000116   0x....             LDR      R0,??DataTable9_15  ;; 0xf80ff008
   \   00000118   0x6800             LDR      R0,[R0, #+0]
   \   0000011A   0x2180             MOVS     R1,#+128
   \   0000011C   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \   0000011E   0x4301             ORRS     R1,R1,R0
   \   00000120   0x....             LDR      R0,??DataTable9_15  ;; 0xf80ff008
   \   00000122   0x6001             STR      R1,[R0, #+0]
   1002              
   1003          }
   \   00000124   0xBD00             POP      {PC}             ;; return
   1004          

   \                                 In section .textrw, align 2, keep-with-next
   1005          void RTC_Alarm_IRQHandler(void)
   1006          {
   \                     RTC_Alarm_IRQHandler:
   \   00000000   0xB500             PUSH     {LR}
   1007              // Move to VLPR mode
   1008              /*if ((SMC_PMSTAT & SMC_PMSTAT_PMSTAT_MASK) != 4)
   1009              {
   1010                  SMC_PMCTRL = SMC_PMCTRL_RUNM(2);
   1011              }*/
   1012              // service the COP 
   1013              SIM_SRVCOP = 0x55;
   \   00000002   0x....             LDR      R0,??DataTable157_9  ;; 0x40048104
   \   00000004   0x2155             MOVS     R1,#+85
   \   00000006   0x6001             STR      R1,[R0, #+0]
   1014              SIM_SRVCOP = 0xAA;
   \   00000008   0x....             LDR      R0,??DataTable157_9  ;; 0x40048104
   \   0000000A   0x21AA             MOVS     R1,#+170
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   1015              
   1016              if((RTC_SR & RTC_SR_TIF_MASK)== 0x01)
   \   0000000E   0x....             LDR      R0,??DataTable157_10  ;; 0x4003d014
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x07C0             LSLS     R0,R0,#+31
   \   00000014   0xD509             BPL      ??RTC_Alarm_IRQHandler_0
   1017              {
   1018                  RTC_SR &= ~RTC_SR_TCE_MASK;  //clear TCE, or RTC_TSR can  not be written
   \   00000016   0x....             LDR      R0,??DataTable157_10  ;; 0x4003d014
   \   00000018   0x6800             LDR      R0,[R0, #+0]
   \   0000001A   0x2110             MOVS     R1,#+16
   \   0000001C   0x4388             BICS     R0,R0,R1
   \   0000001E   0x....             LDR      R1,??DataTable157_10  ;; 0x4003d014
   \   00000020   0x6008             STR      R0,[R1, #+0]
   1019          	RTC_TSR = 0x00000000;  //clear TIF
   \   00000022   0x....             LDR      R0,??DataTable157_11  ;; 0x4003d000
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x6001             STR      R1,[R0, #+0]
   \   00000028   0xE01B             B        ??RTC_Alarm_IRQHandler_1
   1020              }
   1021              else if((RTC_SR & RTC_SR_TOF_MASK) == 0x02)
   \                     ??RTC_Alarm_IRQHandler_0:
   \   0000002A   0x....             LDR      R0,??DataTable157_10  ;; 0x4003d014
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x0780             LSLS     R0,R0,#+30
   \   00000030   0xD509             BPL      ??RTC_Alarm_IRQHandler_2
   1022              {
   1023                  RTC_SR &= 0x07;  //clear TCE, or RTC_TSR can  not be written
   \   00000032   0x....             LDR      R0,??DataTable157_10  ;; 0x4003d014
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0x0740             LSLS     R0,R0,#+29       ;; ZeroExtS R0,R0,#+29,#+29
   \   00000038   0x0F40             LSRS     R0,R0,#+29
   \   0000003A   0x....             LDR      R1,??DataTable157_10  ;; 0x4003d014
   \   0000003C   0x6008             STR      R0,[R1, #+0]
   1024          	RTC_TSR = 0x00000000;  //clear TOF
   \   0000003E   0x....             LDR      R0,??DataTable157_11  ;; 0x4003d000
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x6001             STR      R1,[R0, #+0]
   \   00000044   0xE00D             B        ??RTC_Alarm_IRQHandler_1
   1025              }
   1026              else if((RTC_SR & RTC_SR_TAF_MASK) == 0x04)
   \                     ??RTC_Alarm_IRQHandler_2:
   \   00000046   0x....             LDR      R0,??DataTable157_10  ;; 0x4003d014
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x0740             LSLS     R0,R0,#+29
   \   0000004C   0xD509             BPL      ??RTC_Alarm_IRQHandler_1
   1027              {
   1028                  // Set RTC alarm semaphore to True
   1029                  RTC_Alarm = TRUE;
   \   0000004E   0x....             LDR      R0,??DataTable157_12
   \   00000050   0x2101             MOVS     R1,#+1
   \   00000052   0x8001             STRH     R1,[R0, #+0]
   1030                  //RTC_TAR = RTC_TSR + RTC_VAL_1S;
   1031                  RTC_TAR = RTC_TSR + RTC_refresh_rate;
   \   00000054   0x....             LDR      R0,??DataTable157_11  ;; 0x4003d000
   \   00000056   0x6800             LDR      R0,[R0, #+0]
   \   00000058   0x....             LDR      R1,??DataTable157_13
   \   0000005A   0x8809             LDRH     R1,[R1, #+0]
   \   0000005C   0x1840             ADDS     R0,R0,R1
   \   0000005E   0x....             LDR      R1,??DataTable157_14  ;; 0x4003d008
   \   00000060   0x6008             STR      R0,[R1, #+0]
   1032              }	
   1033              else
   1034              {
   1035              }
   1036          
   1037              return;
   \                     ??RTC_Alarm_IRQHandler_1:
   \   00000062   0xBD00             POP      {PC}             ;; return
   1038          }
   1039          

   \                                 In section .text, align 2, keep-with-next
   1040          void TPM0_IRQHandler(void)
   1041          {
   \                     TPM0_IRQHandler:
   \   00000000   0xB500             PUSH     {LR}
   1042              
   1043              if((TPM0_C3SC & TPM_CnSC_CHF_MASK) == TPM_CnSC_CHF_MASK)
   \   00000002   0x....             LDR      R0,??DataTable9_9  ;; 0x40038024
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x0600             LSLS     R0,R0,#+24
   \   00000008   0xD50E             BPL      ??TPM0_IRQHandler_0
   1044              {
   1045                  TPM0_C3SC |= TPM_CnSC_CHF_MASK;
   \   0000000A   0x....             LDR      R0,??DataTable9_9  ;; 0x40038024
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x2180             MOVS     R1,#+128
   \   00000010   0x4301             ORRS     R1,R1,R0
   \   00000012   0x....             LDR      R0,??DataTable9_9  ;; 0x40038024
   \   00000014   0x6001             STR      R1,[R0, #+0]
   1046                  /*TPM0_C3V = TPM0_C3V + V1_result;
   1047                  TPM0_C3SC = (uint32_t)((TPM0_C3SC & (uint32_t)~(uint32_t)(
   1048                         TPM_CnSC_CHF_MASK |
   1049                         TPM_CnSC_ELSA_MASK |
   1050                         TPM_CnSC_DMA_MASK |
   1051                         0xFFFFFF02U
   1052                        )) | (uint32_t)(
   1053                         TPM_CnSC_MSA_MASK |
   1054                         TPM_CnSC_CHIE_MASK |
   1055                         TPM_CnSC_ELSB_MASK
   1056                        ));           
   1057                  TPM0_SC = (uint32_t)((TPM0_SC & (uint32_t)~(uint32_t)(
   1058                       TPM_SC_CMOD(0x01)
   1059                      )) | (uint32_t)(
   1060                       TPM_SC_CMOD(0x01)
   1061                      ));  */
   1062                  TPM0_flag = TRUE;
   \   00000016   0x....             LDR      R0,??DataTable9_20
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x8001             STRH     R1,[R0, #+0]
   1063                  FGPIOB_PCOR |= 0x40;
   \   0000001C   0x....             LDR      R0,??DataTable9_18  ;; 0xf80ff048
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2140             MOVS     R1,#+64
   \   00000022   0x4301             ORRS     R1,R1,R0
   \   00000024   0x....             LDR      R0,??DataTable9_18  ;; 0xf80ff048
   \   00000026   0x6001             STR      R1,[R0, #+0]
   1064                  
   1065                  //TPM0_SC = 0x00;
   1066              }
   1067          }
   \                     ??TPM0_IRQHandler_0:
   \   00000028   0xBD00             POP      {PC}             ;; return
   1068          

   \                                 In section .text, align 2, keep-with-next
   1069          void TPM1_IRQHandler(void)
   1070          {
   \                     TPM1_IRQHandler:
   \   00000000   0xB500             PUSH     {LR}
   1071              if(test_mode == 0)
   \   00000002   0x....             LDR      R0,??DataTable9_21
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD106             BNE      ??TPM1_IRQHandler_0
   1072              {
   1073                  TPM1_C0SC |= TPM_CnSC_CHF_MASK; // Clear CHF flag
   \   0000000A   0x....             LDR      R0,??DataTable9_3  ;; 0x4003900c
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x2180             MOVS     R1,#+128
   \   00000010   0x4301             ORRS     R1,R1,R0
   \   00000012   0x....             LDR      R0,??DataTable9_3  ;; 0x4003900c
   \   00000014   0x6001             STR      R1,[R0, #+0]
   \   00000016   0xE017             B        ??TPM1_IRQHandler_1
   1074              }
   1075              else if (test_mode == 3)
   \                     ??TPM1_IRQHandler_0:
   \   00000018   0x....             LDR      R0,??DataTable9_21
   \   0000001A   0x8800             LDRH     R0,[R0, #+0]
   \   0000001C   0x2803             CMP      R0,#+3
   \   0000001E   0xD113             BNE      ??TPM1_IRQHandler_1
   1076              {
   1077                  
   1078              if((TPM1_C0SC & TPM_CnSC_CHF_MASK) == TPM_CnSC_CHF_MASK)
   \   00000020   0x....             LDR      R0,??DataTable9_3  ;; 0x4003900c
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x0600             LSLS     R0,R0,#+24
   \   00000026   0xD50F             BPL      ??TPM1_IRQHandler_1
   1079              {
   1080                  TPM1_C0SC |= TPM_CnSC_CHF_MASK;
   \   00000028   0x....             LDR      R0,??DataTable9_3  ;; 0x4003900c
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0x2180             MOVS     R1,#+128
   \   0000002E   0x4301             ORRS     R1,R1,R0
   \   00000030   0x....             LDR      R0,??DataTable9_3  ;; 0x4003900c
   \   00000032   0x6001             STR      R1,[R0, #+0]
   1081                 
   1082                  TPM1_flag = TRUE;
   \   00000034   0x....             LDR      R0,??DataTable9_22
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0x8001             STRH     R1,[R0, #+0]
   1083                  
   1084                  /*TPM1_C0SC = (uint32_t)((TPM1_C0SC & (uint32_t)~(uint32_t)(
   1085                         TPM_CnSC_CHF_MASK |
   1086                         TPM_CnSC_ELSA_MASK |
   1087                         TPM_CnSC_DMA_MASK |
   1088                         TPM_CnSC_ELSB_MASK |
   1089                         0xFFFFFF02U
   1090                        )) | (uint32_t)(
   1091                         TPM_CnSC_MSA_MASK |
   1092                         TPM_CnSC_CHIE_MASK 
   1093                        ));           
   1094                  TPM1_SC = (uint32_t)((TPM1_SC & (uint32_t)~(uint32_t)(
   1095                       TPM_SC_CMOD(0x01)
   1096                      )) | (uint32_t)(
   1097                       TPM_SC_CMOD(0x01)
   1098                      ));  
   1099                  
   1100                  */
   1101                  FGPIOA_PCOR |= 0x1000;
   \   0000003A   0x....             LDR      R0,??DataTable9_15  ;; 0xf80ff008
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x2180             MOVS     R1,#+128
   \   00000040   0x0149             LSLS     R1,R1,#+5        ;; #+4096
   \   00000042   0x4301             ORRS     R1,R1,R0
   \   00000044   0x....             LDR      R0,??DataTable9_15  ;; 0xf80ff008
   \   00000046   0x6001             STR      R1,[R0, #+0]
   1102              }
   1103              }
   1104              else
   1105              {}
   1106          }
   \                     ??TPM1_IRQHandler_1:
   \   00000048   0xBD00             POP      {PC}             ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0xF80FF008         DC32     0xf80ff008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x4007C002         DC32     0x4007c002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x4003D010         DC32     0x4003d010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x40048104         DC32     0x40048104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_5:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_6:
   \   00000000   0x4003D01C         DC32     0x4003d01c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_7:
   \   00000000   0x4003D000         DC32     0x4003d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_8:
   \   00000000   0x4003D008         DC32     0x4003d008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     test_mode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x4003D014         DC32     0x4003d014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x4004901C         DC32     0x4004901c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x4004A000         DC32     0x4004a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x40049014         DC32     0x40049014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x40049018         DC32     0x40049018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x40049020         DC32     0x40049020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x40049024         DC32     0x40049024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_8:
   \   00000000   0x40049028         DC32     0x40049028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_9:
   \   00000000   0x4004902C         DC32     0x4004902c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_10:
   \   00000000   0x40049030         DC32     0x40049030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_11:
   \   00000000   0x40049034         DC32     0x40049034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_12:
   \   00000000   0x40049038         DC32     0x40049038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_13:
   \   00000000   0x4004903C         DC32     0x4004903c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_14:
   \   00000000   0x40049040         DC32     0x40049040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_15:
   \   00000000   0x40049044         DC32     0x40049044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_16:
   \   00000000   0x40049048         DC32     0x40049048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_17:
   \   00000000   0x4004904C         DC32     0x4004904c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_18:
   \   00000000   0x40049050         DC32     0x40049050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_19:
   \   00000000   0x40049054         DC32     0x40049054

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_20:
   \   00000000   0x40049058         DC32     0x40049058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_21:
   \   00000000   0x4004905C         DC32     0x4004905c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_22:
   \   00000000   0x40049060         DC32     0x40049060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_23:
   \   00000000   0x40049064         DC32     0x40049064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_24:
   \   00000000   0x40049068         DC32     0x40049068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_25:
   \   00000000   0x4004906C         DC32     0x4004906c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_26:
   \   00000000   0x40049070         DC32     0x40049070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_27:
   \   00000000   0x40049074         DC32     0x40049074

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_28:
   \   00000000   0x40049078         DC32     0x40049078

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_29:
   \   00000000   0x4004907C         DC32     0x4004907c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_30:
   \   00000000   0xF80FF014         DC32     0xf80ff014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_31:
   \   00000000   0x4004A004         DC32     0x4004a004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_32:
   \   00000000   0x4004A008         DC32     0x4004a008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_33:
   \   00000000   0x4004A00C         DC32     0x4004a00c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_34:
   \   00000000   0x4004A010         DC32     0x4004a010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_35:
   \   00000000   0x4004A014         DC32     0x4004a014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_36:
   \   00000000   0x4004A018         DC32     0x4004a018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_37:
   \   00000000   0x4004A01C         DC32     0x4004a01c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_38:
   \   00000000   0x4004A020         DC32     0x4004a020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_39:
   \   00000000   0x4004A024         DC32     0x4004a024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_40:
   \   00000000   0x4004A028         DC32     0x4004a028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_41:
   \   00000000   0x4004A02C         DC32     0x4004a02c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_42:
   \   00000000   0x4004A030         DC32     0x4004a030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_43:
   \   00000000   0x4004A034         DC32     0x4004a034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_44:
   \   00000000   0x4004A038         DC32     0x4004a038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_45:
   \   00000000   0x4004A03C         DC32     0x4004a03c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_46:
   \   00000000   0x4004A040         DC32     0x4004a040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_47:
   \   00000000   0x4004A044         DC32     0x4004a044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_48:
   \   00000000   0x4004A048         DC32     0x4004a048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x4004A04C         DC32     0x4004a04c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x4004A050         DC32     0x4004a050

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x4004A054         DC32     0x4004a054

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x4004A058         DC32     0x4004a058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x4004A05C         DC32     0x4004a05c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x4004A060         DC32     0x4004a060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x4004A064         DC32     0x4004a064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x4004A068         DC32     0x4004a068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_8:
   \   00000000   0x4004A06C         DC32     0x4004a06c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_9:
   \   00000000   0x4004A070         DC32     0x4004a070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_10:
   \   00000000   0x4004A074         DC32     0x4004a074

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_11:
   \   00000000   0x4004A078         DC32     0x4004a078

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_12:
   \   00000000   0x4004A07C         DC32     0x4004a07c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_13:
   \   00000000   0xF80FF054         DC32     0xf80ff054

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x4007C001         DC32     0x4007c001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x........         DC32     RTC_Alarm

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     V0_result

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x000007F9         DC32     0x7f9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     V1_result

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     Bgap_V

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x40039004         DC32     0x40039004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x40039000         DC32     0x40039000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40038000         DC32     0x40038000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x40038004         DC32     0x40038004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x40039010         DC32     0x40039010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x40038028         DC32     0x40038028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0xF80FF004         DC32     0xf80ff004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0xF80FF044         DC32     0xf80ff044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     TPM0_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     TPM1_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x4003900C         DC32     0x4003900c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x40038024         DC32     0x40038024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x40048100         DC32     0x40048100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x40049030         DC32     0x40049030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x400FF014         DC32     0x400ff014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x40048004         DC32     0x40048004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \   00000000   0x4004A018         DC32     0x4004a018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \   00000000   0x40038008         DC32     0x40038008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_20:
   \   00000000   0x400FF004         DC32     0x400ff004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_21:
   \   00000000   0xF80FF054         DC32     0xf80ff054

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_22:
   \   00000000   0xF80FF048         DC32     0xf80ff048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_23:
   \   00000000   0x4004A014         DC32     0x4004a014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_24:
   \   00000000   0x4004A004         DC32     0x4004a004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_25:
   \   00000000   0x40040000         DC32     0x40040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_26:
   \   00000000   0x40040004         DC32     0x40040004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_27:
   \   00000000   0x40040008         DC32     0x40040008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_28:
   \   00000000   0x4007C002         DC32     0x4007c002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0xF80FF014         DC32     0xf80ff014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x4004901C         DC32     0x4004901c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x4004A000         DC32     0x4004a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     RTC_refresh_rate

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x003D0900         DC32     0x3d0900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x40065000         DC32     0x40065000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x4003D000         DC32     0x4003d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x4003D008         DC32     0x4003d008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x4007C002         DC32     0x4007c002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x4004A014         DC32     0x4004a014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x4004A004         DC32     0x4004a004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x40049030         DC32     0x40049030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x4004A018         DC32     0x4004a018

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_16:
   \   00000000   0x40073000         DC32     0x40073000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_17:
   \   00000000   0x40073005         DC32     0x40073005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_18:
   \   00000000   0x40048004         DC32     0x40048004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0x40073001         DC32     0x40073001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_1:
   \   00000000   0x4007E003         DC32     0x4007e003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable7_2:
   \   00000000   0x4007E001         DC32     0x4007e001

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable157:
   \   00000000   0x4004804C         DC32     0x4004804c

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable157_1:
   \   00000000   0x40040000         DC32     0x40040000

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable157_2:
   \   00000000   0x4007E001         DC32     0x4007e001

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable157_3:
   \   00000000   0xE000ED10         DC32     0xe000ed10

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable157_4:
   \   00000000   0x........         DC32     test_mode

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable157_5:
   \   00000000   0xF80FF008         DC32     0xf80ff008

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable157_6:
   \   00000000   0xF80FF04C         DC32     0xf80ff04c

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable157_7:
   \   00000000   0x400FF00C         DC32     0x400ff00c

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable157_8:
   \   00000000   0x........         DC32     LPTMR_flag

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable157_9:
   \   00000000   0x40048104         DC32     0x40048104

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable157_10:
   \   00000000   0x4003D014         DC32     0x4003d014

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable157_11:
   \   00000000   0x4003D000         DC32     0x4003d000

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable157_12:
   \   00000000   0x........         DC32     RTC_Alarm

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable157_13:
   \   00000000   0x........         DC32     RTC_refresh_rate

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable157_14:
   \   00000000   0x4003D008         DC32     0x4003d008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0xE000ED10         DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40039000         DC32     0x40039000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40039004         DC32     0x40039004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40039084         DC32     0x40039084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x4003900C         DC32     0x4003900c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x40039010         DC32     0x40039010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x40039008         DC32     0x40039008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x40038000         DC32     0x40038000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x40038004         DC32     0x40038004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x40038084         DC32     0x40038084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x40038024         DC32     0x40038024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x40038028         DC32     0x40038028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x40038008         DC32     0x40038008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x40073003         DC32     0x40073003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0xF80FF004         DC32     0xf80ff004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x40040000         DC32     0x40040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0xF80FF008         DC32     0xf80ff008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x40073005         DC32     0x40073005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0xF80FF044         DC32     0xf80ff044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_18:
   \   00000000   0xF80FF048         DC32     0xf80ff048

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_19:
   \   00000000   0x........         DC32     CMP0_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_20:
   \   00000000   0x........         DC32     TPM0_flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_21:
   \   00000000   0x........         DC32     test_mode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_22:
   \   00000000   0x........         DC32     TPM1_flag

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  Alarm_Test
             0 -> fei_fbe
             0 -> lptmr_init
        4  CMP0_IRQHandler
        8  Drive_Test
             8 -> Run_Drive_Test_Loop
             8 -> enable_irq
        0  IO_config
        4  LPTMR_IRQHandler
        0  RF_Test
             0 -> enable_irq
             0 -> fei_fbi
        4  RTC_Alarm_IRQHandler
        0  Run_Drive_Test_Loop
        0  Standby_Test
             0 -> ReadADCPoll
             0 -> TriggerADC
             0 -> __aeabi_idiv
             0 -> enter_vlls3
        4  TPM0_IRQHandler
        4  TPM1_IRQHandler
        8  demo_rtc_init
             8 -> enable_irq
        8  main
             8 -> Alarm_Test
             8 -> Drive_Test
             8 -> RF_Test
             8 -> Standby_Test


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable157
       4  ??DataTable157_1
       4  ??DataTable157_10
       4  ??DataTable157_11
       4  ??DataTable157_12
       4  ??DataTable157_13
       4  ??DataTable157_14
       4  ??DataTable157_2
       4  ??DataTable157_3
       4  ??DataTable157_4
       4  ??DataTable157_5
       4  ??DataTable157_6
       4  ??DataTable157_7
       4  ??DataTable157_8
       4  ??DataTable157_9
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_14
       4  ??DataTable2_15
       4  ??DataTable2_16
       4  ??DataTable2_17
       4  ??DataTable2_18
       4  ??DataTable2_19
       4  ??DataTable2_2
       4  ??DataTable2_20
       4  ??DataTable2_21
       4  ??DataTable2_22
       4  ??DataTable2_23
       4  ??DataTable2_24
       4  ??DataTable2_25
       4  ??DataTable2_26
       4  ??DataTable2_27
       4  ??DataTable2_28
       4  ??DataTable2_29
       4  ??DataTable2_3
       4  ??DataTable2_30
       4  ??DataTable2_31
       4  ??DataTable2_32
       4  ??DataTable2_33
       4  ??DataTable2_34
       4  ??DataTable2_35
       4  ??DataTable2_36
       4  ??DataTable2_37
       4  ??DataTable2_38
       4  ??DataTable2_39
       4  ??DataTable2_4
       4  ??DataTable2_40
       4  ??DataTable2_41
       4  ??DataTable2_42
       4  ??DataTable2_43
       4  ??DataTable2_44
       4  ??DataTable2_45
       4  ??DataTable2_46
       4  ??DataTable2_47
       4  ??DataTable2_48
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_21
       4  ??DataTable5_22
       4  ??DataTable5_23
       4  ??DataTable5_24
       4  ??DataTable5_25
       4  ??DataTable5_26
       4  ??DataTable5_27
       4  ??DataTable5_28
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_16
       4  ??DataTable6_17
       4  ??DataTable6_18
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable8
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_19
       4  ??DataTable9_2
       4  ??DataTable9_20
       4  ??DataTable9_21
       4  ??DataTable9_22
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
     160  Alarm_Test
     294  CMP0_IRQHandler
       2  CMP0_flag
     176  Drive_Test
     408  IO_config
     122  LPTMR_IRQHandler
       2  LPTMR_flag
     452  RF_Test
       2  RTC_Alarm
     100  RTC_Alarm_IRQHandler
       2  RTC_refresh_rate
      46  Run_Drive_Test_Loop
     320  Standby_Test
      42  TPM0_IRQHandler
       2  TPM0_flag
      74  TPM1_IRQHandler
       2  TPM1_flag
       2  V0_result
       2  V1_result
       2  VLLS3_recovery
     180  demo_rtc_init
      62  main

 
    18 bytes in section .bss
 2 784 bytes in section .text
   328 bytes in section .textrw
 
 3 112 bytes of CODE memory
    18 bytes of DATA memory

Errors: none
Warnings: 13
