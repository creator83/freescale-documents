###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.3.54009/W32 for ARM     18/Feb/2013  16:57:30 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Profiles\B38350\My Documents\App Notes\Kinetis\L      #
#                    Series\CMP pin sampling\Example                          #
#                    Projects\src\common\memtest.c                            #
#    Command line =  "D:\Profiles\B38350\My Documents\App Notes\Kinetis\L     #
#                    Series\CMP pin sampling\Example                          #
#                    Projects\src\common\memtest.c" -D IAR -D FRDM -D EX2     #
#                    -lCN "D:\Profiles\B38350\My Documents\App                #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\FLASH_32KB\Lis #
#                    t\" -lB "D:\Profiles\B38350\My Documents\App             #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\FLASH_32KB\Lis #
#                    t\" -o "D:\Profiles\B38350\My Documents\App              #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\FLASH_32KB\Obj #
#                    \" --no_cse --no_unroll --no_inline --no_code_motion     #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M0+ -e --fpu=None           #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.4\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    "D:\Profiles\B38350\My Documents\App Notes\Kinetis\L     #
#                    Series\CMP pin sampling\Example                          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\p #
#                    rojects\DualChannel_Experiment\" -I                      #
#                    "D:\Profiles\B38350\My Documents\App Notes\Kinetis\L     #
#                    Series\CMP pin sampling\Example                          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\c #
#                    ommon\" -I "D:\Profiles\B38350\My Documents\App          #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\c #
#                    pu\" -I "D:\Profiles\B38350\My Documents\App             #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\c #
#                    pu\headers\" -I "D:\Profiles\B38350\My Documents\App     #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\llwu\" -I "D:\Profiles\B38350\My Documents\App    #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\adc\" -I "D:\Profiles\B38350\My Documents\App     #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\lptmr\" -I "D:\Profiles\B38350\My Documents\App   #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\mcg\" -I "D:\Profiles\B38350\My Documents\App     #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\pmc\" -I "D:\Profiles\B38350\My Documents\App     #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\rcm\" -I "D:\Profiles\B38350\My Documents\App     #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\rtc\" -I "D:\Profiles\B38350\My Documents\App     #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\smc\" -I "D:\Profiles\B38350\My Documents\App     #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\uart\" -I "D:\Profiles\B38350\My Documents\App    #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\wdog\" -I "D:\Profiles\B38350\My Documents\App    #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\uart\" -I "D:\Profiles\B38350\My Documents\App    #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\p #
#                    latforms\" -I "D:\Profiles\B38350\My Documents\App       #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\" -Ol       #
#                    --use_c++_inline                                         #
#    List file    =  D:\Profiles\B38350\My Documents\App Notes\Kinetis\L      #
#                    Series\CMP pin sampling\Example                          #
#                    Projects\build\iar\DualChannel_Experiment\FLASH_32KB\Lis #
#                    t\memtest.lst                                            #
#    Object file  =  D:\Profiles\B38350\My Documents\App Notes\Kinetis\L      #
#                    Series\CMP pin sampling\Example                          #
#                    Projects\build\iar\DualChannel_Experiment\FLASH_32KB\Obj #
#                    \memtest.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\Profiles\B38350\My Documents\App Notes\Kinetis\L Series\CMP pin sampling\Example Projects\src\common\memtest.c
      1          /**********************************************************************
      2           *
      3           * Filename:    memtest.c
      4           * 
      5           * Description: General-purpose memory testing functions.
      6           *
      7           * Notes:       This software can be easily ported to systems with
      8           *              different data bus widths by redefining 'datum'.
      9           *
     10           * 
     11           * Copyright (c) 1998 by Michael Barr.  This software is placed into
     12           * the public domain and may be used for any purpose.  However, this
     13           * notice must not be changed or removed and no warranty is either
     14           * expressed or implied by its publication or distribution.
     15           **********************************************************************/
     16          
     17          
     18          #include "memtest.h"
     19          
     20          
     21          /**********************************************************************
     22           *
     23           * Function:    memTestDataBus()
     24           *
     25           * Description: Test the data bus wiring in a memory region by
     26           *              performing a walking 1's test at a fixed address
     27           *              within that region.  The address (and hence the
     28           *              memory region) is selected by the caller.
     29           *
     30           * Notes:       
     31           *
     32           * Returns:     0 if the test succeeds.  
     33           *              A non-zero result is the first pattern that failed.
     34           *
     35           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     36          datum
     37          memTestDataBus(volatile datum * address)
     38          {
   \                     memTestDataBus:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
     39              datum pattern;
     40          
     41          
     42              /*
     43               * Perform a walking 1's test at the given address.
     44               */
     45              for (pattern = 1; pattern != 0; pattern <<= 1)
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xE000             B        ??memTestDataBus_0
   \                     ??memTestDataBus_1:
   \   00000008   0x0040             LSLS     R0,R0,#+1
   \                     ??memTestDataBus_0:
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD004             BEQ      ??memTestDataBus_2
     46              {
     47                  /*
     48                   * Write the test pattern.
     49                   */
     50                  *address = pattern;
   \   0000000E   0x6008             STR      R0,[R1, #+0]
     51          
     52                  /*
     53                   * Read it back (immediately is okay for this test).
     54                   */
     55                  if (*address != pattern) 
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0x4282             CMP      R2,R0
   \   00000014   0xD0F8             BEQ      ??memTestDataBus_1
     56                  {
     57                      return (pattern);
   \   00000016   0xE000             B        ??memTestDataBus_3
     58                  }
     59              }
     60          
     61              return (0);
   \                     ??memTestDataBus_2:
   \   00000018   0x2000             MOVS     R0,#+0
   \                     ??memTestDataBus_3:
   \   0000001A   0xBD00             POP      {PC}             ;; return
     62          
     63          }   /* memTestDataBus() */
     64          
     65          
     66          /**********************************************************************
     67           *
     68           * Function:    memTestAddressBus()
     69           *
     70           * Description: Test the address bus wiring in a memory region by
     71           *              performing a walking 1's test on the relevant bits
     72           *              of the address and checking for aliasing. This test
     73           *              will find single-bit address failures such as stuck
     74           *              -high, stuck-low, and shorted pins.  The base address
     75           *              and size of the region are selected by the caller.
     76           *
     77           * Notes:       For best results, the selected base address should
     78           *              have enough LSB 0's to guarantee single address bit
     79           *              changes.  For example, to test a 64-Kbyte region, 
     80           *              select a base address on a 64-Kbyte boundary.  Also, 
     81           *              select the region size as a power-of-two--if at all 
     82           *              possible.
     83           *
     84           * Returns:     NULL if the test succeeds.  
     85           *              A non-zero result is the first address at which an
     86           *              aliasing problem was uncovered.  By examining the
     87           *              contents of memory, it may be possible to gather
     88           *              additional information about the problem.
     89           *
     90           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     91          datum * 
     92          memTestAddressBus(volatile datum * baseAddress, unsigned long nBytes)
     93          {
   \                     memTestAddressBus:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
     94              unsigned long addressMask = (nBytes/sizeof(datum) - 1);
   \   00000002   0x0889             LSRS     R1,R1,#+2
   \   00000004   0x1E49             SUBS     R1,R1,#+1
     95              unsigned long offset;
     96              unsigned long testOffset;
     97          
     98              datum pattern     = (datum) 0xAAAAAAAA;
   \   00000006   0x....             LDR      R2,??DataTable0  ;; 0xaaaaaaaa
     99              datum antipattern = (datum) 0x55555555;
   \   00000008   0x....             LDR      R3,??DataTable0_1  ;; 0x55555555
    100          
    101          
    102              /*
    103               * Write the default pattern at each of the power-of-two offsets.
    104               */
    105              for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
   \   0000000A   0x2501             MOVS     R5,#+1
   \   0000000C   0xE003             B        ??memTestAddressBus_0
    106              {
    107                  baseAddress[offset] = pattern;
   \                     ??memTestAddressBus_1:
   \   0000000E   0x2404             MOVS     R4,#+4
   \   00000010   0x436C             MULS     R4,R5,R4
   \   00000012   0x5102             STR      R2,[R0, R4]
    108              }
   \   00000014   0x006D             LSLS     R5,R5,#+1
   \                     ??memTestAddressBus_0:
   \   00000016   0x420D             TST      R5,R1
   \   00000018   0xD1F9             BNE      ??memTestAddressBus_1
    109          
    110              /* 
    111               * Check for address bits stuck high.
    112               */
    113              testOffset = 0;
   \   0000001A   0x2400             MOVS     R4,#+0
    114              baseAddress[testOffset] = antipattern;
   \   0000001C   0x2504             MOVS     R5,#+4
   \   0000001E   0x4365             MULS     R5,R4,R5
   \   00000020   0x5143             STR      R3,[R0, R5]
    115          
    116              for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
   \   00000022   0x2501             MOVS     R5,#+1
   \   00000024   0xE000             B        ??memTestAddressBus_2
   \                     ??memTestAddressBus_3:
   \   00000026   0x006D             LSLS     R5,R5,#+1
   \                     ??memTestAddressBus_2:
   \   00000028   0x420D             TST      R5,R1
   \   0000002A   0xD008             BEQ      ??memTestAddressBus_4
    117              {
    118                  if (baseAddress[offset] != pattern)
   \   0000002C   0x2604             MOVS     R6,#+4
   \   0000002E   0x436E             MULS     R6,R5,R6
   \   00000030   0x5986             LDR      R6,[R0, R6]
   \   00000032   0x4296             CMP      R6,R2
   \   00000034   0xD0F7             BEQ      ??memTestAddressBus_3
    119                  {
    120                      return ((datum *) &baseAddress[offset]);
   \   00000036   0x2104             MOVS     R1,#+4
   \   00000038   0x434D             MULS     R5,R1,R5
   \   0000003A   0x1940             ADDS     R0,R0,R5
   \   0000003C   0xE025             B        ??memTestAddressBus_5
    121                  }
    122              }
    123          
    124              baseAddress[testOffset] = pattern;
   \                     ??memTestAddressBus_4:
   \   0000003E   0x2504             MOVS     R5,#+4
   \   00000040   0x436C             MULS     R4,R5,R4
   \   00000042   0x5102             STR      R2,[R0, R4]
    125          
    126              /*
    127               * Check for address bits stuck low or shorted.
    128               */
    129              for (testOffset = 1; (testOffset & addressMask) != 0; testOffset <<= 1)
   \   00000044   0x2401             MOVS     R4,#+1
   \   00000046   0xE003             B        ??memTestAddressBus_6
    130              {
    131                  baseAddress[testOffset] = antipattern;
    132          
    133          		if (baseAddress[0] != pattern)
    134          		{
    135          			return ((datum *) &baseAddress[testOffset]);
    136          		}
    137          
    138                  for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
    139                  {
    140                      if ((baseAddress[offset] != pattern) && (offset != testOffset))
    141                      {
    142                          return ((datum *) &baseAddress[testOffset]);
    143                      }
    144                  }
    145          
    146                  baseAddress[testOffset] = pattern;
   \                     ??memTestAddressBus_7:
   \   00000048   0x2504             MOVS     R5,#+4
   \   0000004A   0x4365             MULS     R5,R4,R5
   \   0000004C   0x5142             STR      R2,[R0, R5]
   \   0000004E   0x0064             LSLS     R4,R4,#+1
   \                     ??memTestAddressBus_6:
   \   00000050   0x420C             TST      R4,R1
   \   00000052   0xD019             BEQ      ??memTestAddressBus_8
   \   00000054   0x2504             MOVS     R5,#+4
   \   00000056   0x4365             MULS     R5,R4,R5
   \   00000058   0x5143             STR      R3,[R0, R5]
   \   0000005A   0x6805             LDR      R5,[R0, #+0]
   \   0000005C   0x4295             CMP      R5,R2
   \   0000005E   0xD003             BEQ      ??memTestAddressBus_9
   \   00000060   0x2104             MOVS     R1,#+4
   \   00000062   0x434C             MULS     R4,R1,R4
   \   00000064   0x1900             ADDS     R0,R0,R4
   \   00000066   0xE010             B        ??memTestAddressBus_5
   \                     ??memTestAddressBus_9:
   \   00000068   0x2501             MOVS     R5,#+1
   \   0000006A   0xE000             B        ??memTestAddressBus_10
   \                     ??memTestAddressBus_11:
   \   0000006C   0x006D             LSLS     R5,R5,#+1
   \                     ??memTestAddressBus_10:
   \   0000006E   0x420D             TST      R5,R1
   \   00000070   0xD0EA             BEQ      ??memTestAddressBus_7
   \   00000072   0x2604             MOVS     R6,#+4
   \   00000074   0x436E             MULS     R6,R5,R6
   \   00000076   0x5986             LDR      R6,[R0, R6]
   \   00000078   0x4296             CMP      R6,R2
   \   0000007A   0xD0F7             BEQ      ??memTestAddressBus_11
   \   0000007C   0x42A5             CMP      R5,R4
   \   0000007E   0xD0F5             BEQ      ??memTestAddressBus_11
   \   00000080   0x2104             MOVS     R1,#+4
   \   00000082   0x434C             MULS     R4,R1,R4
   \   00000084   0x1900             ADDS     R0,R0,R4
   \   00000086   0xE000             B        ??memTestAddressBus_5
    147              }
    148          
    149              return (NULL);
   \                     ??memTestAddressBus_8:
   \   00000088   0x2000             MOVS     R0,#+0
   \                     ??memTestAddressBus_5:
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
    150          
    151          }   /* memTestAddressBus() */
    152          
    153          
    154          /**********************************************************************
    155           *
    156           * Function:    memTestDevice()
    157           *
    158           * Description: Test the integrity of a physical memory device by
    159           *              performing an increment/decrement test over the
    160           *              entire region.  In the process every storage bit 
    161           *              in the device is tested as a zero and a one.  The
    162           *              base address and the size of the region are
    163           *              selected by the caller.
    164           *
    165           * Notes:       
    166           *
    167           * Returns:     NULL if the test succeeds.
    168           *
    169           *              A non-zero result is the first address at which an
    170           *              incorrect value was read back.  By examining the
    171           *              contents of memory, it may be possible to gather
    172           *              additional information about the problem.
    173           *
    174           **********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    175          datum * 
    176          memTestDevice(volatile datum * baseAddress, unsigned long nBytes)	
    177          {
   \                     memTestDevice:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    178              unsigned long offset;
    179              unsigned long nWords = nBytes / sizeof(datum);
   \   00000002   0x0889             LSRS     R1,R1,#+2
    180          
    181              datum pattern;
    182              datum antipattern;
    183          
    184          
    185              /*
    186               * Fill memory with a known pattern.
    187               */
    188              for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x2300             MOVS     R3,#+0
   \   00000008   0xE004             B        ??memTestDevice_0
    189              {
    190                  baseAddress[offset] = pattern;
   \                     ??memTestDevice_1:
   \   0000000A   0x2404             MOVS     R4,#+4
   \   0000000C   0x435C             MULS     R4,R3,R4
   \   0000000E   0x5102             STR      R2,[R0, R4]
    191              }
   \   00000010   0x1C52             ADDS     R2,R2,#+1
   \   00000012   0x1C5B             ADDS     R3,R3,#+1
   \                     ??memTestDevice_0:
   \   00000014   0x428B             CMP      R3,R1
   \   00000016   0xD3F8             BCC      ??memTestDevice_1
    192          
    193              /*
    194               * Check each location and invert it for the second pass.
    195               */
    196              for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0xE005             B        ??memTestDevice_2
    197              {
    198                  if (baseAddress[offset] != pattern)
    199                  {
    200                      return ((datum *) &baseAddress[offset]);
    201                  }
    202          
    203                  antipattern = ~pattern;
   \                     ??memTestDevice_3:
   \   0000001E   0x43D4             MVNS     R4,R2
    204                  baseAddress[offset] = antipattern;
   \   00000020   0x2504             MOVS     R5,#+4
   \   00000022   0x435D             MULS     R5,R3,R5
   \   00000024   0x5144             STR      R4,[R0, R5]
   \   00000026   0x1C52             ADDS     R2,R2,#+1
   \   00000028   0x1C5B             ADDS     R3,R3,#+1
   \                     ??memTestDevice_2:
   \   0000002A   0x428B             CMP      R3,R1
   \   0000002C   0xD208             BCS      ??memTestDevice_4
   \   0000002E   0x2404             MOVS     R4,#+4
   \   00000030   0x435C             MULS     R4,R3,R4
   \   00000032   0x5904             LDR      R4,[R0, R4]
   \   00000034   0x4294             CMP      R4,R2
   \   00000036   0xD0F2             BEQ      ??memTestDevice_3
   \   00000038   0x2104             MOVS     R1,#+4
   \   0000003A   0x434B             MULS     R3,R1,R3
   \   0000003C   0x18C0             ADDS     R0,R0,R3
   \   0000003E   0xE011             B        ??memTestDevice_5
    205              }
    206          
    207              /*
    208               * Check each location for the inverted pattern and zero it.
    209               */
    210              for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
   \                     ??memTestDevice_4:
   \   00000040   0x2201             MOVS     R2,#+1
   \   00000042   0x2300             MOVS     R3,#+0
   \   00000044   0xE001             B        ??memTestDevice_6
   \                     ??memTestDevice_7:
   \   00000046   0x1C52             ADDS     R2,R2,#+1
   \   00000048   0x1C5B             ADDS     R3,R3,#+1
   \                     ??memTestDevice_6:
   \   0000004A   0x428B             CMP      R3,R1
   \   0000004C   0xD209             BCS      ??memTestDevice_8
    211              {
    212                  antipattern = ~pattern;
   \   0000004E   0x43D4             MVNS     R4,R2
    213                  if (baseAddress[offset] != antipattern)
   \   00000050   0x2504             MOVS     R5,#+4
   \   00000052   0x435D             MULS     R5,R3,R5
   \   00000054   0x5945             LDR      R5,[R0, R5]
   \   00000056   0x42A5             CMP      R5,R4
   \   00000058   0xD0F5             BEQ      ??memTestDevice_7
    214                  {
    215                      return ((datum *) &baseAddress[offset]);
   \   0000005A   0x2104             MOVS     R1,#+4
   \   0000005C   0x434B             MULS     R3,R1,R3
   \   0000005E   0x18C0             ADDS     R0,R0,R3
   \   00000060   0xE000             B        ??memTestDevice_5
    216                  }
    217              }
    218          
    219              return (NULL);
   \                     ??memTestDevice_8:
   \   00000062   0x2000             MOVS     R0,#+0
   \                     ??memTestDevice_5:
   \   00000064   0xBD30             POP      {R4,R5,PC}       ;; return
    220          
    221          }   /* memTestDevice() */

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0xAAAAAAAA         DC32     0xaaaaaaaa

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x55555555         DC32     0x55555555

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  memTestAddressBus
        4  memTestDataBus
       12  memTestDevice


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
     140  memTestAddressBus
      28  memTestDataBus
     102  memTestDevice

 
 278 bytes in section .text
 
 278 bytes of CODE memory

Errors: none
Warnings: none
