###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.40.3.54009/W32 for ARM     18/Feb/2013  16:57:30 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Profiles\B38350\My Documents\App Notes\Kinetis\L      #
#                    Series\CMP pin sampling\Example                          #
#                    Projects\src\drivers\mcg\mcg.c                           #
#    Command line =  "D:\Profiles\B38350\My Documents\App Notes\Kinetis\L     #
#                    Series\CMP pin sampling\Example                          #
#                    Projects\src\drivers\mcg\mcg.c" -D IAR -D FRDM -D EX2    #
#                    -lCN "D:\Profiles\B38350\My Documents\App                #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\FLASH_32KB\Lis #
#                    t\" -lB "D:\Profiles\B38350\My Documents\App             #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\FLASH_32KB\Lis #
#                    t\" -o "D:\Profiles\B38350\My Documents\App              #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\FLASH_32KB\Obj #
#                    \" --no_cse --no_unroll --no_inline --no_code_motion     #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M0+ -e --fpu=None           #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.4\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    "D:\Profiles\B38350\My Documents\App Notes\Kinetis\L     #
#                    Series\CMP pin sampling\Example                          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\p #
#                    rojects\DualChannel_Experiment\" -I                      #
#                    "D:\Profiles\B38350\My Documents\App Notes\Kinetis\L     #
#                    Series\CMP pin sampling\Example                          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\c #
#                    ommon\" -I "D:\Profiles\B38350\My Documents\App          #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\c #
#                    pu\" -I "D:\Profiles\B38350\My Documents\App             #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\c #
#                    pu\headers\" -I "D:\Profiles\B38350\My Documents\App     #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\llwu\" -I "D:\Profiles\B38350\My Documents\App    #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\adc\" -I "D:\Profiles\B38350\My Documents\App     #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\lptmr\" -I "D:\Profiles\B38350\My Documents\App   #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\mcg\" -I "D:\Profiles\B38350\My Documents\App     #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\pmc\" -I "D:\Profiles\B38350\My Documents\App     #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\rcm\" -I "D:\Profiles\B38350\My Documents\App     #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\rtc\" -I "D:\Profiles\B38350\My Documents\App     #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\smc\" -I "D:\Profiles\B38350\My Documents\App     #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\uart\" -I "D:\Profiles\B38350\My Documents\App    #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\wdog\" -I "D:\Profiles\B38350\My Documents\App    #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\d #
#                    rivers\uart\" -I "D:\Profiles\B38350\My Documents\App    #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\..\..\src\p #
#                    latforms\" -I "D:\Profiles\B38350\My Documents\App       #
#                    Notes\Kinetis\L Series\CMP pin sampling\Example          #
#                    Projects\build\iar\DualChannel_Experiment\..\" -Ol       #
#                    --use_c++_inline                                         #
#    List file    =  D:\Profiles\B38350\My Documents\App Notes\Kinetis\L      #
#                    Series\CMP pin sampling\Example                          #
#                    Projects\build\iar\DualChannel_Experiment\FLASH_32KB\Lis #
#                    t\mcg.lst                                                #
#    Object file  =  D:\Profiles\B38350\My Documents\App Notes\Kinetis\L      #
#                    Series\CMP pin sampling\Example                          #
#                    Projects\build\iar\DualChannel_Experiment\FLASH_32KB\Obj #
#                    \mcg.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\Profiles\B38350\My Documents\App Notes\Kinetis\L Series\CMP pin sampling\Example Projects\src\drivers\mcg\mcg.c
      1          /*
      2           * File:    mcg.c
      3           *
      4           * Notes:
      5           * Assumes the MCG mode is in the default FEI mode out of reset
      6           */
      7          
      8          #include "common.h"
      9          #include "mcg.h"
     10          //#include "lptmr.h"
     11          
     12          // global variables
     13          extern int core_clk_khz;
     14          //extern int slow_irc_freq = 32768; // default slow irc frequency is 32768Hz
     15          //extern int fast_irc_freq = 4000000; // default fast irc frequency is 4MHz
     16          

   \                                 In section .bss, align 1
     17          char drs_val, dmx32_val;
   \                     drs_val:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     dmx32_val:
   \   00000000                      DS8 1
     18          
     19          
     20          
     21          
     22          
     23          /*********************************************************************************************/
     24          /* Functon name : pll_init
     25           *
     26           * Mode transition: Option to move from FEI to PEE mode or to just initialize the PLL
     27           *
     28           * This function initializess either PLL0 or PLL1. Either OSC0 or OSC1 can be selected for the
     29           * reference clock source. The oscillators can be configured to use a crystal or take in an
     30           * external square wave clock.
     31           * NOTE : This driver does not presently (as of Sept 9 2011) support the use of OSC1 as the
     32           * reference clock for the MCGOUT clock used for the system clocks.
     33           * The PLL outputs a PLLCLK and PLLCLK2X. PLLCLK2X is the actual PLL frequency and PLLCLK is
     34           * half this frequency. PLLCLK is used for MCGOUT and is also typically used by the
     35           * peripherals that can select the PLL as a clock source. So the PLL frequency generated will
     36           * be twice the desired frequency.
     37           * Using the function parameter names the PLL frequency is calculated as follows:
     38           * PLL freq = ((crystal_val / prdiv_val) * vdiv_val)
     39           * Refer to the readme file in the mcg driver directory for examples of pll_init configurations.
     40           * All parameters must be provided, for example crystal_val must be provided even if the
     41           * oscillator associated with that parameter is already initialized.
     42           * The various passed parameters are checked to ensure they are within the allowed range. If any
     43           * of these checks fail the driver will exit and return a fail/error code. An error code will
     44           * also be returned if any error occurs during the PLL initialization sequence. Refer to the
     45           * readme file in the mcg driver directory for a list of all these codes.
     46           *
     47           * Parameters: crystal_val - external clock frequency in Hz either from a crystal or square
     48           *                           wave clock source
     49           *             hgo_val     - selects whether low power or high gain mode is selected
     50           *                           for the crystal oscillator. This has no meaning if an
     51           *                           external clock is used.
     52           *             erefs_val   - selects external clock (=0) or crystal osc (=1)
     53           *             prdiv_val   - value to divide the external clock source by to create the desired
     54           *                           PLL reference clock frequency
     55           *             vdiv_val    - value to multiply the PLL reference clock frequency by
     56           *             mcgout_select  - 0 if the PLL is just to be enabled, non-zero if the PLL is used
     57           *                              to provide the MCGOUT clock for the system.
     58           *
     59           * Return value : PLL frequency (Hz) divided by 2 or error code
     60           */
     61          
     62          

   \                                 In section .text, align 2, keep-with-next
     63          int blpe_fbe(int crystal_val)
     64          {
   \                     blpe_fbe:
   \   00000000   0xB500             PUSH     {LR}
     65            
     66          // Check MCG is in BLPE mode
     67            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
     68                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
     69                (MCG_C2 & MCG_C2_LP_MASK)))                                     // check MCG_C2[LP] bit is set   
   \   00000002   0x....             LDR      R1,??DataTable4  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD107             BNE      ??blpe_fbe_0
   \   00000012   0x....             LDR      R1,??DataTable4  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD403             BMI      ??blpe_fbe_0
   \   0000001A   0x....             LDR      R1,??DataTable4_1  ;; 0x40064001
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0789             LSLS     R1,R1,#+30
   \   00000020   0xD401             BMI      ??blpe_fbe_1
     70            {
     71              return 0x6;                                                       // return error code
   \                     ??blpe_fbe_0:
   \   00000022   0x2006             MOVS     R0,#+6
   \   00000024   0xE005             B        ??blpe_fbe_2
     72            }
     73           
     74          // To move from BLPE to FBE the PLLS mux be set to select the FLL output and the LP bit must be cleared
     75          //  MCG_C6 &= ~MCG_C6_PLLS_MASK; // clear PLLS to select the FLL
     76            MCG_C2 &= ~MCG_C2_LP_MASK; // clear LP bit  
   \                     ??blpe_fbe_1:
   \   00000026   0x....             LDR      R1,??DataTable4_1  ;; 0x40064001
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0x22FD             MOVS     R2,#+253
   \   0000002C   0x400A             ANDS     R2,R2,R1
   \   0000002E   0x....             LDR      R1,??DataTable4_1  ;; 0x40064001
   \   00000030   0x700A             STRB     R2,[R1, #+0]
     77          
     78          // wait for PLLST status bit to set
     79            /*
     80            for (i = 0 ; i < 2000 ; i++)
     81            {
     82              if (!(MCG_S & MCG_S_PLLST_MASK)) break; // jump out early if PLLST clears before loop finishes
     83            }
     84            if (MCG_S & MCG_S_PLLST_MASK) return 0x15; // check bit is really clear and return with error if not clear  
     85            */
     86            
     87          // now in FBE mode
     88            return crystal_val; // MCGOUT frequency equals external clock frequency     
   \                     ??blpe_fbe_2:
   \   00000032   0xBD00             POP      {PC}             ;; return
     89          } // blpe_fbe
     90          
     91          

   \                                 In section .text, align 2, keep-with-next
     92          int fbe_blpe(int crystal_val)
     93          {
   \                     fbe_blpe:
   \   00000000   0xB500             PUSH     {LR}
     94          // Check MCG is in FBE mode
     95            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
     96                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
     97             //   (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
     98                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000002   0x....             LDR      R1,??DataTable4  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD107             BNE      ??fbe_blpe_0
   \   00000012   0x....             LDR      R1,??DataTable4  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD403             BMI      ??fbe_blpe_0
   \   0000001A   0x....             LDR      R1,??DataTable4_1  ;; 0x40064001
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0789             LSLS     R1,R1,#+30
   \   00000020   0xD501             BPL      ??fbe_blpe_1
     99            {
    100              return 0x4;                                                       // return error code
   \                     ??fbe_blpe_0:
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0xE005             B        ??fbe_blpe_2
    101            }
    102           
    103          // To move from FBE to BLPE the LP bit must be set
    104            MCG_C2 |= MCG_C2_LP_MASK; // set LP bit  
   \                     ??fbe_blpe_1:
   \   00000026   0x....             LDR      R1,??DataTable4_1  ;; 0x40064001
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0x2202             MOVS     R2,#+2
   \   0000002C   0x430A             ORRS     R2,R2,R1
   \   0000002E   0x....             LDR      R1,??DataTable4_1  ;; 0x40064001
   \   00000030   0x700A             STRB     R2,[R1, #+0]
    105           
    106          // now in FBE mode
    107            return crystal_val; // MCGOUT frequency equals external clock frequency     
   \                     ??fbe_blpe_2:
   \   00000032   0xBD00             POP      {PC}             ;; return
    108          } // fbe_blpe
    109          
    110          

   \                                 In section .text, align 2, keep-with-next
    111          int fbe_fei(int slow_irc_freq)
    112          {
   \                     fbe_fei:
   \   00000000   0xB580             PUSH     {R7,LR}
    113            unsigned char temp_reg;
    114            short i;
    115            int mcg_out;
    116            
    117          // Check MCG is in FBE mode
    118            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    119                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    120             //   (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    121                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000002   0x....             LDR      R1,??DataTable4  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD107             BNE      ??fbe_fei_0
   \   00000012   0x....             LDR      R1,??DataTable4  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD403             BMI      ??fbe_fei_0
   \   0000001A   0x....             LDR      R1,??DataTable4_1  ;; 0x40064001
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0789             LSLS     R1,R1,#+30
   \   00000020   0xD501             BPL      ??fbe_fei_1
    122            {
    123              return 0x4;                                                       // return error code
   \                     ??fbe_fei_0:
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0xE045             B        ??fbe_fei_2
    124            }
    125          
    126          // Check IRC frequency is within spec.
    127            if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
   \                     ??fbe_fei_1:
   \   00000026   0x....             LDR      R1,??DataTable4_2  ;; 0x7a12
   \   00000028   0x1A41             SUBS     R1,R0,R1
   \   0000002A   0x....             LDR      R2,??DataTable4_3  ;; 0x1e86
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xD301             BCC      ??fbe_fei_3
    128            {
    129              return 0x31;
   \   00000030   0x2031             MOVS     R0,#+49
   \   00000032   0xE03E             B        ??fbe_fei_2
    130            }
    131            
    132          // Check resulting FLL frequency 
    133            mcg_out = fll_freq(slow_irc_freq); 
   \                     ??fbe_fei_3:
   \   00000034   0x.... 0x....      BL       fll_freq
    134            if (mcg_out < 0x5B) {return mcg_out;} // If error code returned, return the code to calling function
   \   00000038   0x285B             CMP      R0,#+91
   \   0000003A   0xDB3A             BLT      ??fbe_fei_2
    135          
    136          // Need to make sure the clockmonitor is disabled before moving to an "internal" clock mode
    137          //  MCG_C6 &= ~MCG_C6_CME0_MASK; //This assumes OSC0 is used as the external clock source
    138             MCG_C6 &= ~MCG_C6_CME0_MASK; 
   \                     ??fbe_fei_4:
   \   0000003C   0x....             LDR      R1,??DataTable4_4  ;; 0x40064005
   \   0000003E   0x7809             LDRB     R1,[R1, #+0]
   \   00000040   0x22DF             MOVS     R2,#+223
   \   00000042   0x400A             ANDS     R2,R2,R1
   \   00000044   0x....             LDR      R1,??DataTable4_4  ;; 0x40064005
   \   00000046   0x700A             STRB     R2,[R1, #+0]
    139             
    140          // Move to FEI by setting CLKS to 0 and enabling the slow IRC as the FLL reference clock
    141            temp_reg = MCG_C1;
   \   00000048   0x....             LDR      R1,??DataTable4_5  ;; 0x40064000
   \   0000004A   0x7809             LDRB     R1,[R1, #+0]
    142            temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
   \   0000004C   0x0689             LSLS     R1,R1,#+26       ;; ZeroExtS R1,R1,#+26,#+26
   \   0000004E   0x0E89             LSRS     R1,R1,#+26
    143            temp_reg |= MCG_C1_IREFS_MASK; // select internal reference clock
   \   00000050   0x000A             MOVS     R2,R1
   \   00000052   0x2104             MOVS     R1,#+4
   \   00000054   0x4311             ORRS     R1,R1,R2
    144            MCG_C1 = temp_reg; // update MCG_C1 
   \   00000056   0x....             LDR      R2,??DataTable4_5  ;; 0x40064000
   \   00000058   0x7011             STRB     R1,[R2, #+0]
    145            
    146          // wait for Reference clock Status bit to set
    147            for (i = 0 ; i < 2000 ; i++)
   \   0000005A   0x2100             MOVS     R1,#+0
   \   0000005C   0xE000             B        ??fbe_fei_5
   \                     ??fbe_fei_6:
   \   0000005E   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbe_fei_5:
   \   00000060   0x22FA             MOVS     R2,#+250
   \   00000062   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000064   0xB209             SXTH     R1,R1
   \   00000066   0x4291             CMP      R1,R2
   \   00000068   0xDA03             BGE      ??fbe_fei_7
    148            {
    149              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
   \   0000006A   0x....             LDR      R2,??DataTable4  ;; 0x40064006
   \   0000006C   0x7812             LDRB     R2,[R2, #+0]
   \   0000006E   0x06D2             LSLS     R2,R2,#+27
   \   00000070   0xD5F5             BPL      ??fbe_fei_6
    150            }
    151            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set
   \                     ??fbe_fei_7:
   \   00000072   0x....             LDR      R1,??DataTable4  ;; 0x40064006
   \   00000074   0x7809             LDRB     R1,[R1, #+0]
   \   00000076   0x06C9             LSLS     R1,R1,#+27
   \   00000078   0xD401             BMI      ??fbe_fei_8
   \   0000007A   0x2012             MOVS     R0,#+18
   \   0000007C   0xE019             B        ??fbe_fei_2
    152            
    153          // Wait for clock status bits to show clock source is ext ref clk
    154            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbe_fei_8:
   \   0000007E   0x2100             MOVS     R1,#+0
   \   00000080   0xE000             B        ??fbe_fei_9
   \                     ??fbe_fei_10:
   \   00000082   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbe_fei_9:
   \   00000084   0x22FA             MOVS     R2,#+250
   \   00000086   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000088   0xB209             SXTH     R1,R1
   \   0000008A   0x4291             CMP      R1,R2
   \   0000008C   0xDA07             BGE      ??fbe_fei_11
    155            {
    156              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \   0000008E   0x....             LDR      R2,??DataTable4  ;; 0x40064006
   \   00000090   0x7812             LDRB     R2,[R2, #+0]
   \   00000092   0xB2D2             UXTB     R2,R2
   \   00000094   0x0892             LSRS     R2,R2,#+2
   \   00000096   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   00000098   0x0F92             LSRS     R2,R2,#+30
   \   0000009A   0x2A00             CMP      R2,#+0
   \   0000009C   0xD1F1             BNE      ??fbe_fei_10
    157            }
    158            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check EXT CLK is really selected and return with error if not
   \                     ??fbe_fei_11:
   \   0000009E   0x....             LDR      R1,??DataTable4  ;; 0x40064006
   \   000000A0   0x7809             LDRB     R1,[R1, #+0]
   \   000000A2   0xB2C9             UXTB     R1,R1
   \   000000A4   0x0889             LSRS     R1,R1,#+2
   \   000000A6   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   000000A8   0x0F89             LSRS     R1,R1,#+30
   \   000000AA   0x2900             CMP      R1,#+0
   \   000000AC   0xD001             BEQ      ??fbe_fei_12
   \   000000AE   0x2018             MOVS     R0,#+24
   \   000000B0   0xE7FF             B        ??fbe_fei_2
    159          
    160          // Now in FEI mode
    161            return mcg_out;
   \                     ??fbe_fei_12:
   \                     ??fbe_fei_2:
   \   000000B2   0xBD02             POP      {R1,PC}          ;; return
    162          } // fbe_fei
    163          
    164          
    165          
    166          
    167          

   \                                 In section .text, align 2, keep-with-next
    168          int fbe_fee(int crystal_val)
    169          {
   \                     fbe_fee:
   \   00000000   0xB580             PUSH     {R7,LR}
    170            short i, fll_ref_freq;
    171            int mcg_out;
    172          
    173          // Check MCG is in FBE mode
    174            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    175                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    176              //  (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    177                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000002   0x....             LDR      R1,??DataTable5  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD107             BNE      ??fbe_fee_0
   \   00000012   0x....             LDR      R1,??DataTable5  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD403             BMI      ??fbe_fee_0
   \   0000001A   0x....             LDR      R1,??DataTable4_1  ;; 0x40064001
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0789             LSLS     R1,R1,#+30
   \   00000020   0xD501             BPL      ??fbe_fee_1
    178            {
    179              return 0x4;                                                       // return error code
   \                     ??fbe_fee_0:
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0xE041             B        ??fbe_fee_2
    180            }
    181            
    182            // The FLL ref clk divide value depends on FRDIV and the RANGE value
    183            if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
   \                     ??fbe_fee_1:
   \   00000026   0x....             LDR      R1,??DataTable4_1  ;; 0x40064001
   \   00000028   0x7809             LDRB     R1,[R1, #+0]
   \   0000002A   0xB2C9             UXTB     R1,R1
   \   0000002C   0x0909             LSRS     R1,R1,#+4
   \   0000002E   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   00000030   0x0F89             LSRS     R1,R1,#+30
   \   00000032   0x2900             CMP      R1,#+0
   \   00000034   0xD00A             BEQ      ??fbe_fee_3
    184            {
    185              fll_ref_freq = (crystal_val / (32 << ((MCG_C1 & MCG_C1_FRDIV_MASK) >> MCG_C1_FRDIV_SHIFT)));
   \   00000036   0x2120             MOVS     R1,#+32
   \   00000038   0x....             LDR      R2,??DataTable4_5  ;; 0x40064000
   \   0000003A   0x7812             LDRB     R2,[R2, #+0]
   \   0000003C   0xB2D2             UXTB     R2,R2
   \   0000003E   0x08D2             LSRS     R2,R2,#+3
   \   00000040   0x0752             LSLS     R2,R2,#+29       ;; ZeroExtS R2,R2,#+29,#+29
   \   00000042   0x0F52             LSRS     R2,R2,#+29
   \   00000044   0x4091             LSLS     R1,R1,R2
   \   00000046   0x.... 0x....      BL       __aeabi_idiv
   \   0000004A   0xE009             B        ??fbe_fee_4
    186            }
    187            else
    188            {
    189              fll_ref_freq = ((crystal_val) / (1 << (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT))));
   \                     ??fbe_fee_3:
   \   0000004C   0x2101             MOVS     R1,#+1
   \   0000004E   0x....             LDR      R2,??DataTable4_1  ;; 0x40064001
   \   00000050   0x7812             LDRB     R2,[R2, #+0]
   \   00000052   0xB2D2             UXTB     R2,R2
   \   00000054   0x0912             LSRS     R2,R2,#+4
   \   00000056   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   00000058   0x0F92             LSRS     R2,R2,#+30
   \   0000005A   0x4091             LSLS     R1,R1,R2
   \   0000005C   0x.... 0x....      BL       __aeabi_idiv
    190            }
    191            
    192          // Check resulting FLL frequency 
    193            mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRDIV
   \                     ??fbe_fee_4:
   \   00000060   0xB200             SXTH     R0,R0
   \   00000062   0x.... 0x....      BL       fll_freq
    194            if (mcg_out < 0x5B) {return mcg_out;} // If error code returned, return the code to calling function
   \   00000066   0x285B             CMP      R0,#+91
   \   00000068   0xDB1F             BLT      ??fbe_fee_2
    195            
    196          // Clear CLKS field to switch CLKS mux to select FLL output
    197            MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to select FLL output
   \                     ??fbe_fee_5:
   \   0000006A   0x....             LDR      R1,??DataTable4_5  ;; 0x40064000
   \   0000006C   0x7809             LDRB     R1,[R1, #+0]
   \   0000006E   0x0689             LSLS     R1,R1,#+26       ;; ZeroExtS R1,R1,#+26,#+26
   \   00000070   0x0E89             LSRS     R1,R1,#+26
   \   00000072   0x....             LDR      R2,??DataTable4_5  ;; 0x40064000
   \   00000074   0x7011             STRB     R1,[R2, #+0]
    198          
    199          // Wait for clock status bits to show clock source is FLL
    200            for (i = 0 ; i < 2000 ; i++)
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0xE000             B        ??fbe_fee_6
   \                     ??fbe_fee_7:
   \   0000007A   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbe_fee_6:
   \   0000007C   0x22FA             MOVS     R2,#+250
   \   0000007E   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000080   0xB209             SXTH     R1,R1
   \   00000082   0x4291             CMP      R1,R2
   \   00000084   0xDA07             BGE      ??fbe_fee_8
    201            {
    202              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST shows FLL selected before loop finishes
   \   00000086   0x....             LDR      R2,??DataTable5  ;; 0x40064006
   \   00000088   0x7812             LDRB     R2,[R2, #+0]
   \   0000008A   0xB2D2             UXTB     R2,R2
   \   0000008C   0x0892             LSRS     R2,R2,#+2
   \   0000008E   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   00000090   0x0F92             LSRS     R2,R2,#+30
   \   00000092   0x2A00             CMP      R2,#+0
   \   00000094   0xD1F1             BNE      ??fbe_fee_7
    203            }
    204            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really selected and return with error if not
   \                     ??fbe_fee_8:
   \   00000096   0x....             LDR      R1,??DataTable5  ;; 0x40064006
   \   00000098   0x7809             LDRB     R1,[R1, #+0]
   \   0000009A   0xB2C9             UXTB     R1,R1
   \   0000009C   0x0889             LSRS     R1,R1,#+2
   \   0000009E   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   000000A0   0x0F89             LSRS     R1,R1,#+30
   \   000000A2   0x2900             CMP      R1,#+0
   \   000000A4   0xD001             BEQ      ??fbe_fee_9
   \   000000A6   0x2018             MOVS     R0,#+24
   \   000000A8   0xE7FF             B        ??fbe_fee_2
    205            
    206          // Now in FEE mode
    207            return mcg_out;
   \                     ??fbe_fee_9:
   \                     ??fbe_fee_2:
   \   000000AA   0xBD02             POP      {R1,PC}          ;; return
    208          } // fbe_fee
    209          
    210          

   \                                 In section .text, align 2, keep-with-next
    211          int fee_fbe(int crystal_val)
    212          { 
   \                     fee_fbe:
   \   00000000   0xB500             PUSH     {LR}
    213            short i;
    214            
    215          // Check MCG is in FEE mode
    216           /*
    217            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL
    218                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    219                (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
    220           */ 
    221           
    222            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL
    223                (!(MCG_S & MCG_S_IREFST_MASK))))                                 // check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R1,??DataTable5  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD103             BNE      ??fee_fbe_0
   \   00000012   0x....             LDR      R1,??DataTable5  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD501             BPL      ??fee_fbe_1
    224            {
    225              return 0x2;                                                       // return error code
   \                     ??fee_fbe_0:
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE01F             B        ??fee_fbe_2
    226            }
    227            
    228          // Set CLKS field to 2 to switch CLKS mux to select ext ref clock
    229          // MCG is current in FEE mode so CLKS field = 0 so can just OR in new value
    230            MCG_C1 |= MCG_C1_CLKS(2); // set CLKS to select ext ref clock
   \                     ??fee_fbe_1:
   \   0000001E   0x....             LDR      R1,??DataTable4_5  ;; 0x40064000
   \   00000020   0x7809             LDRB     R1,[R1, #+0]
   \   00000022   0x2280             MOVS     R2,#+128
   \   00000024   0x430A             ORRS     R2,R2,R1
   \   00000026   0x....             LDR      R1,??DataTable4_5  ;; 0x40064000
   \   00000028   0x700A             STRB     R2,[R1, #+0]
    231          
    232          /// Wait for clock status bits to show clock source is ext ref clk
    233            for (i = 0 ; i < 2000 ; i++)
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0xE000             B        ??fee_fbe_3
   \                     ??fee_fbe_4:
   \   0000002E   0x1C49             ADDS     R1,R1,#+1
   \                     ??fee_fbe_3:
   \   00000030   0x22FA             MOVS     R2,#+250
   \   00000032   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000034   0xB209             SXTH     R1,R1
   \   00000036   0x4291             CMP      R1,R2
   \   00000038   0xDA07             BGE      ??fee_fbe_5
    234            {
    235              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \   0000003A   0x....             LDR      R2,??DataTable5  ;; 0x40064006
   \   0000003C   0x7812             LDRB     R2,[R2, #+0]
   \   0000003E   0xB2D2             UXTB     R2,R2
   \   00000040   0x0892             LSRS     R2,R2,#+2
   \   00000042   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   00000044   0x0F92             LSRS     R2,R2,#+30
   \   00000046   0x2A02             CMP      R2,#+2
   \   00000048   0xD1F1             BNE      ??fee_fbe_4
    236            }
    237            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
   \                     ??fee_fbe_5:
   \   0000004A   0x....             LDR      R1,??DataTable5  ;; 0x40064006
   \   0000004C   0x7809             LDRB     R1,[R1, #+0]
   \   0000004E   0xB2C9             UXTB     R1,R1
   \   00000050   0x0889             LSRS     R1,R1,#+2
   \   00000052   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   00000054   0x0F89             LSRS     R1,R1,#+30
   \   00000056   0x2902             CMP      R1,#+2
   \   00000058   0xD001             BEQ      ??fee_fbe_6
   \   0000005A   0x201A             MOVS     R0,#+26
   \   0000005C   0xE7FF             B        ??fee_fbe_2
    238            
    239          // Now in FBE mode
    240            return crystal_val;
   \                     ??fee_fbe_6:
   \                     ??fee_fbe_2:
   \   0000005E   0xBD00             POP      {PC}             ;; return
    241          } // fee_fbe
    242          
    243          

   \                                 In section .text, align 2, keep-with-next
    244          int fbe_fbi(int irc_freq, unsigned char irc_select)
    245          {
   \                     fbe_fbi:
   \   00000000   0xB500             PUSH     {LR}
    246            unsigned char temp_reg;
    247            unsigned char fcrdiv_val;
    248            short i;
    249            
    250          // Check MCG is in FBE mode
    251            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
    252                (!(MCG_S & MCG_S_IREFST_MASK)) &&                               // check FLL ref is external ref clk
    253            //    (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    254                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check MCG_C2[LP] bit is not set   
   \   00000002   0x....             LDR      R2,??DataTable5  ;; 0x40064006
   \   00000004   0x7812             LDRB     R2,[R2, #+0]
   \   00000006   0xB2D2             UXTB     R2,R2
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000000C   0x0F92             LSRS     R2,R2,#+30
   \   0000000E   0x2A02             CMP      R2,#+2
   \   00000010   0xD107             BNE      ??fbe_fbi_0
   \   00000012   0x....             LDR      R2,??DataTable5  ;; 0x40064006
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x06D2             LSLS     R2,R2,#+27
   \   00000018   0xD403             BMI      ??fbe_fbi_0
   \   0000001A   0x....             LDR      R2,??DataTable5_1  ;; 0x40064001
   \   0000001C   0x7812             LDRB     R2,[R2, #+0]
   \   0000001E   0x0792             LSLS     R2,R2,#+30
   \   00000020   0xD501             BPL      ??fbe_fbi_1
    255            {
    256              return 0x4;                                                       // return error code
   \                     ??fbe_fbi_0:
   \   00000022   0x2004             MOVS     R0,#+4
   \   00000024   0xE091             B        ??fbe_fbi_2
    257            }
    258          
    259          // Check that the irc frequency matches the selected IRC 
    260            if (!(irc_select))
   \                     ??fbe_fbi_1:
   \   00000026   0xB2C9             UXTB     R1,R1
   \   00000028   0x2900             CMP      R1,#+0
   \   0000002A   0xD106             BNE      ??fbe_fbi_3
    261            {    
    262              if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
   \   0000002C   0x....             LDR      R2,??DataTable5_2  ;; 0x7a12
   \   0000002E   0x1A82             SUBS     R2,R0,R2
   \   00000030   0x....             LDR      R3,??DataTable5_3  ;; 0x1e86
   \   00000032   0x429A             CMP      R2,R3
   \   00000034   0xD308             BCC      ??fbe_fbi_4
   \   00000036   0x2031             MOVS     R0,#+49
   \   00000038   0xE087             B        ??fbe_fbi_2
    263            }
    264            else
    265            {
    266              if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
   \                     ??fbe_fbi_3:
   \   0000003A   0x....             LDR      R2,??DataTable5_4  ;; 0x2dc6c0
   \   0000003C   0x1A82             SUBS     R2,R0,R2
   \   0000003E   0x....             LDR      R3,??DataTable5_5  ;; 0x1e8481
   \   00000040   0x429A             CMP      R2,R3
   \   00000042   0xD301             BCC      ??fbe_fbi_4
   \   00000044   0x2032             MOVS     R0,#+50
   \   00000046   0xE080             B        ??fbe_fbi_2
    267            }
    268            
    269          // Select the required IRC
    270            if (irc_select)
   \                     ??fbe_fbi_4:
   \   00000048   0xB2C9             UXTB     R1,R1
   \   0000004A   0x2900             CMP      R1,#+0
   \   0000004C   0xD006             BEQ      ??fbe_fbi_5
    271            {
    272              MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
   \   0000004E   0x....             LDR      R2,??DataTable5_1  ;; 0x40064001
   \   00000050   0x7812             LDRB     R2,[R2, #+0]
   \   00000052   0x2301             MOVS     R3,#+1
   \   00000054   0x4313             ORRS     R3,R3,R2
   \   00000056   0x....             LDR      R2,??DataTable5_1  ;; 0x40064001
   \   00000058   0x7013             STRB     R3,[R2, #+0]
   \   0000005A   0xE005             B        ??fbe_fbi_6
    273            }
    274            else
    275            {
    276              MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
   \                     ??fbe_fbi_5:
   \   0000005C   0x....             LDR      R2,??DataTable5_1  ;; 0x40064001
   \   0000005E   0x7812             LDRB     R2,[R2, #+0]
   \   00000060   0x23FE             MOVS     R3,#+254
   \   00000062   0x4013             ANDS     R3,R3,R2
   \   00000064   0x....             LDR      R2,??DataTable5_1  ;; 0x40064001
   \   00000066   0x7013             STRB     R3,[R2, #+0]
    277            }
    278            
    279          // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
    280           // MCG_C6 &= ~MCG_C6_CME0_MASK;
    281             MCG_C6 &= ~MCG_C6_CME0_MASK;
   \                     ??fbe_fbi_6:
   \   00000068   0x....             LDR      R2,??DataTable5_6  ;; 0x40064005
   \   0000006A   0x7812             LDRB     R2,[R2, #+0]
   \   0000006C   0x23DF             MOVS     R3,#+223
   \   0000006E   0x4013             ANDS     R3,R3,R2
   \   00000070   0x....             LDR      R2,??DataTable5_6  ;; 0x40064005
   \   00000072   0x7013             STRB     R3,[R2, #+0]
    282            
    283          // Select the IRC as the CLKS mux selection
    284            temp_reg = MCG_C1;
   \   00000074   0x....             LDR      R2,??DataTable6  ;; 0x40064000
   \   00000076   0x7812             LDRB     R2,[R2, #+0]
    285            temp_reg &= ~MCG_C1_CLKS_MASK;                    // clear CLKS bits 
   \   00000078   0x0692             LSLS     R2,R2,#+26       ;; ZeroExtS R2,R2,#+26,#+26
   \   0000007A   0x0E92             LSRS     R2,R2,#+26
    286            temp_reg |= (MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK); // select IRC as MCGOUT and enable IREFS
   \   0000007C   0x0013             MOVS     R3,R2
   \   0000007E   0x2244             MOVS     R2,#+68
   \   00000080   0x431A             ORRS     R2,R2,R3
    287            MCG_C1 = temp_reg; // update MCG_C1
   \   00000082   0x....             LDR      R3,??DataTable6  ;; 0x40064000
   \   00000084   0x701A             STRB     R2,[R3, #+0]
    288            
    289          // wait until internal reference switches to requested irc.
    290            if (!(irc_select))
   \   00000086   0xB2C9             UXTB     R1,R1
   \   00000088   0x2900             CMP      R1,#+0
   \   0000008A   0xD111             BNE      ??fbe_fbi_7
    291            {
    292              for (i = 0 ; i < 2000 ; i++)
   \   0000008C   0x2200             MOVS     R2,#+0
   \   0000008E   0xE000             B        ??fbe_fbi_8
   \                     ??fbe_fbi_9:
   \   00000090   0x1C52             ADDS     R2,R2,#+1
   \                     ??fbe_fbi_8:
   \   00000092   0x23FA             MOVS     R3,#+250
   \   00000094   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   00000096   0xB212             SXTH     R2,R2
   \   00000098   0x429A             CMP      R2,R3
   \   0000009A   0xDA03             BGE      ??fbe_fbi_10
    293              {
    294                if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishes
   \   0000009C   0x....             LDR      R3,??DataTable5  ;; 0x40064006
   \   0000009E   0x781B             LDRB     R3,[R3, #+0]
   \   000000A0   0x07DB             LSLS     R3,R3,#+31
   \   000000A2   0xD4F5             BMI      ??fbe_fbi_9
    295              }
    296              if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error if set
   \                     ??fbe_fbi_10:
   \   000000A4   0x....             LDR      R2,??DataTable5  ;; 0x40064006
   \   000000A6   0x7812             LDRB     R2,[R2, #+0]
   \   000000A8   0x07D2             LSLS     R2,R2,#+31
   \   000000AA   0xD513             BPL      ??fbe_fbi_11
   \   000000AC   0x2013             MOVS     R0,#+19
   \   000000AE   0xE04C             B        ??fbe_fbi_2
    297            }
    298            else
    299            {
    300              for (i = 0 ; i < 2000 ; i++)
   \                     ??fbe_fbi_7:
   \   000000B0   0x2200             MOVS     R2,#+0
   \   000000B2   0xE000             B        ??fbe_fbi_12
   \                     ??fbe_fbi_13:
   \   000000B4   0x1C52             ADDS     R2,R2,#+1
   \                     ??fbe_fbi_12:
   \   000000B6   0x23FA             MOVS     R3,#+250
   \   000000B8   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   000000BA   0xB212             SXTH     R2,R2
   \   000000BC   0x429A             CMP      R2,R3
   \   000000BE   0xDA03             BGE      ??fbe_fbi_14
    301              {
    302                if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
   \   000000C0   0x....             LDR      R3,??DataTable5  ;; 0x40064006
   \   000000C2   0x781B             LDRB     R3,[R3, #+0]
   \   000000C4   0x07DB             LSLS     R3,R3,#+31
   \   000000C6   0xD5F5             BPL      ??fbe_fbi_13
    303              }
    304              if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error if not set
   \                     ??fbe_fbi_14:
   \   000000C8   0x....             LDR      R2,??DataTable5  ;; 0x40064006
   \   000000CA   0x7812             LDRB     R2,[R2, #+0]
   \   000000CC   0x07D2             LSLS     R2,R2,#+31
   \   000000CE   0xD401             BMI      ??fbe_fbi_11
   \   000000D0   0x2014             MOVS     R0,#+20
   \   000000D2   0xE03A             B        ??fbe_fbi_2
    305            }
    306           
    307          // Wait for clock status bits to update
    308            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbe_fbi_11:
   \   000000D4   0x2200             MOVS     R2,#+0
   \   000000D6   0xE000             B        ??fbe_fbi_15
   \                     ??fbe_fbi_16:
   \   000000D8   0x1C52             ADDS     R2,R2,#+1
   \                     ??fbe_fbi_15:
   \   000000DA   0x23FA             MOVS     R3,#+250
   \   000000DC   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   000000DE   0xB212             SXTH     R2,R2
   \   000000E0   0x429A             CMP      R2,R3
   \   000000E2   0xDA07             BGE      ??fbe_fbi_17
    309            {
    310              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST shows IRC slected before loop finishes
   \   000000E4   0x....             LDR      R3,??DataTable5  ;; 0x40064006
   \   000000E6   0x781B             LDRB     R3,[R3, #+0]
   \   000000E8   0xB2DB             UXTB     R3,R3
   \   000000EA   0x089B             LSRS     R3,R3,#+2
   \   000000EC   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   000000EE   0x0F9B             LSRS     R3,R3,#+30
   \   000000F0   0x2B01             CMP      R3,#+1
   \   000000F2   0xD1F1             BNE      ??fbe_fbi_16
    311            }
    312            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really selected and return with error if not
   \                     ??fbe_fbi_17:
   \   000000F4   0x....             LDR      R2,??DataTable5  ;; 0x40064006
   \   000000F6   0x7812             LDRB     R2,[R2, #+0]
   \   000000F8   0xB2D2             UXTB     R2,R2
   \   000000FA   0x0892             LSRS     R2,R2,#+2
   \   000000FC   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   000000FE   0x0F92             LSRS     R2,R2,#+30
   \   00000100   0x2A01             CMP      R2,#+1
   \   00000102   0xD001             BEQ      ??fbe_fbi_18
   \   00000104   0x2019             MOVS     R0,#+25
   \   00000106   0xE020             B        ??fbe_fbi_2
    313           
    314          //GPIOC_PSOR = 0x00020000; //set bit 17 of port C  
    315            // wait for Reference clock Status bit to set
    316            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbe_fbi_18:
   \   00000108   0x2200             MOVS     R2,#+0
   \   0000010A   0xE000             B        ??fbe_fbi_19
   \                     ??fbe_fbi_20:
   \   0000010C   0x1C52             ADDS     R2,R2,#+1
   \                     ??fbe_fbi_19:
   \   0000010E   0x23FA             MOVS     R3,#+250
   \   00000110   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   00000112   0xB212             SXTH     R2,R2
   \   00000114   0x429A             CMP      R2,R3
   \   00000116   0xDA03             BGE      ??fbe_fbi_21
    317            {
    318              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
   \   00000118   0x....             LDR      R3,??DataTable5  ;; 0x40064006
   \   0000011A   0x781B             LDRB     R3,[R3, #+0]
   \   0000011C   0x06DB             LSLS     R3,R3,#+27
   \   0000011E   0xD5F5             BPL      ??fbe_fbi_20
    319            }
    320            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set
   \                     ??fbe_fbi_21:
   \   00000120   0x....             LDR      R2,??DataTable5  ;; 0x40064006
   \   00000122   0x7812             LDRB     R2,[R2, #+0]
   \   00000124   0x06D2             LSLS     R2,R2,#+27
   \   00000126   0xD401             BMI      ??fbe_fbi_22
   \   00000128   0x2012             MOVS     R0,#+18
   \   0000012A   0xE00E             B        ??fbe_fbi_2
    321          //GPIOC_PCOR = 0x00020000; // clear bit 17 of port C   
    322          // Now in FBI mode
    323            
    324            if (irc_select)
   \                     ??fbe_fbi_22:
   \   0000012C   0xB2C9             UXTB     R1,R1
   \   0000012E   0x2900             CMP      R1,#+0
   \   00000130   0xD00B             BEQ      ??fbe_fbi_23
    325            {
    326              fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fast IRC divder factor
   \   00000132   0x2101             MOVS     R1,#+1
   \   00000134   0x....             LDR      R2,??DataTable8  ;; 0x40064008
   \   00000136   0x7812             LDRB     R2,[R2, #+0]
   \   00000138   0xB2D2             UXTB     R2,R2
   \   0000013A   0x0852             LSRS     R2,R2,#+1
   \   0000013C   0x0752             LSLS     R2,R2,#+29       ;; ZeroExtS R2,R2,#+29,#+29
   \   0000013E   0x0F52             LSRS     R2,R2,#+29
   \   00000140   0x4091             LSLS     R1,R1,R2
    327              return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by FCRDIV factor
   \   00000142   0xB2C9             UXTB     R1,R1
   \   00000144   0x.... 0x....      BL       __aeabi_idiv
   \   00000148   0xE7FF             B        ??fbe_fbi_2
    328            }
    329            else
    330            {
    331              return irc_freq; // MCGOUT frequency equals slow IRC frequency
   \                     ??fbe_fbi_23:
   \                     ??fbe_fbi_2:
   \   0000014A   0xBD00             POP      {PC}             ;; return
    332            }
    333          } //fbe_fbi
    334          
    335          

   \                                 In section .text, align 2, keep-with-next
    336          int fbi_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
    337          {
   \                     fbi_fbe:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
    338            unsigned char temp_reg;
    339            unsigned char frdiv_val;
    340            short i;
    341            
    342          // check if in FBI mode
    343            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
    344                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
    345              //  (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    346                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
   \   00000002   0x....             LDR      R3,??DataTable8_1  ;; 0x40064006
   \   00000004   0x781B             LDRB     R3,[R3, #+0]
   \   00000006   0xB2DB             UXTB     R3,R3
   \   00000008   0x089B             LSRS     R3,R3,#+2
   \   0000000A   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   0000000C   0x0F9B             LSRS     R3,R3,#+30
   \   0000000E   0x2B01             CMP      R3,#+1
   \   00000010   0xD107             BNE      ??fbi_fbe_0
   \   00000012   0x....             LDR      R3,??DataTable8_1  ;; 0x40064006
   \   00000014   0x781B             LDRB     R3,[R3, #+0]
   \   00000016   0x06DB             LSLS     R3,R3,#+27
   \   00000018   0xD503             BPL      ??fbi_fbe_0
   \   0000001A   0x....             LDR      R3,??DataTable8_2  ;; 0x40064001
   \   0000001C   0x781B             LDRB     R3,[R3, #+0]
   \   0000001E   0x079B             LSLS     R3,R3,#+30
   \   00000020   0xD501             BPL      ??fbi_fbe_1
    347            {  
    348              return 0x3;                                                       // MCG not in correct mode return fail code 
   \                     ??fbi_fbe_0:
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xE0AD             B        ??fbi_fbe_2
    349            }
    350           
    351          // check external frequency is less than the maximum frequency
    352            if  (crystal_val > 50000000) {return 0x21;}
   \                     ??fbi_fbe_1:
   \   00000026   0x....             LDR      R3,??DataTable8_3  ;; 0x2faf081
   \   00000028   0x4298             CMP      R0,R3
   \   0000002A   0xDB01             BLT      ??fbi_fbe_3
   \   0000002C   0x2021             MOVS     R0,#+33
   \   0000002E   0xE0A8             B        ??fbi_fbe_2
    353            
    354          // check crystal frequency is within spec. if crystal osc is being used
    355            if (erefs_val)
   \                     ??fbi_fbe_3:
   \   00000030   0xB2D2             UXTB     R2,R2
   \   00000032   0x2A00             CMP      R2,#+0
   \   00000034   0xD00C             BEQ      ??fbi_fbe_4
    356            {
    357              if ((crystal_val < 30000) ||
    358                  ((crystal_val > 40000) && (crystal_val < 3000000)) ||
    359                  (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal options is not available
   \   00000036   0x....             LDR      R3,??DataTable8_4  ;; 0x7530
   \   00000038   0x4298             CMP      R0,R3
   \   0000003A   0xDB07             BLT      ??fbi_fbe_5
   \   0000003C   0x....             LDR      R3,??DataTable8_5  ;; 0x9c41
   \   0000003E   0x1AC3             SUBS     R3,R0,R3
   \   00000040   0x....             LDR      R4,??DataTable8_6  ;; 0x2d2a7f
   \   00000042   0x42A3             CMP      R3,R4
   \   00000044   0xD302             BCC      ??fbi_fbe_5
   \   00000046   0x....             LDR      R3,??DataTable8_7  ;; 0x1e84801
   \   00000048   0x4298             CMP      R0,R3
   \   0000004A   0xDB01             BLT      ??fbi_fbe_4
   \                     ??fbi_fbe_5:
   \   0000004C   0x2022             MOVS     R0,#+34
   \   0000004E   0xE098             B        ??fbi_fbe_2
    360            }
    361          
    362          // make sure HGO will never be greater than 1. Could return an error instead if desired.  
    363            if (hgo_val > 0)
   \                     ??fbi_fbe_4:
   \   00000050   0xB2C9             UXTB     R1,R1
   \   00000052   0x2901             CMP      R1,#+1
   \   00000054   0xD300             BCC      ??fbi_fbe_6
    364            {
    365              hgo_val = 1; // force hgo_val to 1 if > 0
   \   00000056   0x2101             MOVS     R1,#+1
    366            }
    367          
    368          // configure the MCG_C2 register
    369          // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
    370          // it still needs to be set correctly even if the oscillator is not being used
    371            temp_reg = MCG_C2;
   \                     ??fbi_fbe_6:
   \   00000058   0x....             LDR      R3,??DataTable8_2  ;; 0x40064001
   \   0000005A   0x781B             LDRB     R3,[R3, #+0]
    372            temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
   \   0000005C   0x001C             MOVS     R4,R3
   \   0000005E   0x23C3             MOVS     R3,#+195
   \   00000060   0x4023             ANDS     R3,R3,R4
    373            if (crystal_val <= 40000)
   \   00000062   0x....             LDR      R4,??DataTable8_5  ;; 0x9c41
   \   00000064   0x42A0             CMP      R0,R4
   \   00000066   0xDA07             BGE      ??fbi_fbe_7
    374            {
    375              temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   00000068   0x001C             MOVS     R4,R3
   \   0000006A   0xB2C9             UXTB     R1,R1
   \   0000006C   0x00C9             LSLS     R1,R1,#+3
   \   0000006E   0xB2D2             UXTB     R2,R2
   \   00000070   0x0093             LSLS     R3,R2,#+2
   \   00000072   0x430B             ORRS     R3,R3,R1
   \   00000074   0x4323             ORRS     R3,R3,R4
   \   00000076   0xE015             B        ??fbi_fbe_8
    376            }
    377            else if (crystal_val <= 8000000)
   \                     ??fbi_fbe_7:
   \   00000078   0x....             LDR      R4,??DataTable8_8  ;; 0x7a1201
   \   0000007A   0x42A0             CMP      R0,R4
   \   0000007C   0xDA09             BGE      ??fbi_fbe_9
    378            {
    379              temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   0000007E   0x001D             MOVS     R5,R3
   \   00000080   0xB2C9             UXTB     R1,R1
   \   00000082   0x00C9             LSLS     R1,R1,#+3
   \   00000084   0xB2D2             UXTB     R2,R2
   \   00000086   0x0094             LSLS     R4,R2,#+2
   \   00000088   0x430C             ORRS     R4,R4,R1
   \   0000008A   0x2310             MOVS     R3,#+16
   \   0000008C   0x4323             ORRS     R3,R3,R4
   \   0000008E   0x432B             ORRS     R3,R3,R5
   \   00000090   0xE008             B        ??fbi_fbe_8
    380            }
    381            else
    382            {
    383              temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \                     ??fbi_fbe_9:
   \   00000092   0x001D             MOVS     R5,R3
   \   00000094   0xB2C9             UXTB     R1,R1
   \   00000096   0x00C9             LSLS     R1,R1,#+3
   \   00000098   0xB2D2             UXTB     R2,R2
   \   0000009A   0x0094             LSLS     R4,R2,#+2
   \   0000009C   0x430C             ORRS     R4,R4,R1
   \   0000009E   0x2320             MOVS     R3,#+32
   \   000000A0   0x4323             ORRS     R3,R3,R4
   \   000000A2   0x432B             ORRS     R3,R3,R5
    384            }
    385            MCG_C2 = temp_reg;
   \                     ??fbi_fbe_8:
   \   000000A4   0x....             LDR      R1,??DataTable8_2  ;; 0x40064001
   \   000000A6   0x700B             STRB     R3,[R1, #+0]
    386          
    387          // determine FRDIV based on reference clock frequency
    388          // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
    389            if (crystal_val <= 1250000) {frdiv_val = 0;}
   \   000000A8   0x....             LDR      R1,??DataTable8_9  ;; 0x1312d1
   \   000000AA   0x4288             CMP      R0,R1
   \   000000AC   0xDA01             BGE      ??fbi_fbe_10
   \   000000AE   0x2100             MOVS     R1,#+0
   \   000000B0   0xE014             B        ??fbi_fbe_11
    390            else if (crystal_val <= 2500000) {frdiv_val = 1;}
   \                     ??fbi_fbe_10:
   \   000000B2   0x....             LDR      R1,??DataTable8_10  ;; 0x2625a1
   \   000000B4   0x4288             CMP      R0,R1
   \   000000B6   0xDA01             BGE      ??fbi_fbe_12
   \   000000B8   0x2101             MOVS     R1,#+1
   \   000000BA   0xE00F             B        ??fbi_fbe_11
    391            else if (crystal_val <= 5000000) {frdiv_val = 2;}
   \                     ??fbi_fbe_12:
   \   000000BC   0x....             LDR      R1,??DataTable8_11  ;; 0x4c4b41
   \   000000BE   0x4288             CMP      R0,R1
   \   000000C0   0xDA01             BGE      ??fbi_fbe_13
   \   000000C2   0x2102             MOVS     R1,#+2
   \   000000C4   0xE00A             B        ??fbi_fbe_11
    392            else if (crystal_val <= 10000000) {frdiv_val = 3;}
   \                     ??fbi_fbe_13:
   \   000000C6   0x....             LDR      R1,??DataTable8_12  ;; 0x989681
   \   000000C8   0x4288             CMP      R0,R1
   \   000000CA   0xDA01             BGE      ??fbi_fbe_14
   \   000000CC   0x2103             MOVS     R1,#+3
   \   000000CE   0xE005             B        ??fbi_fbe_11
    393            else if (crystal_val <= 20000000) {frdiv_val = 4;}
   \                     ??fbi_fbe_14:
   \   000000D0   0x....             LDR      R1,??DataTable8_13  ;; 0x1312d01
   \   000000D2   0x4288             CMP      R0,R1
   \   000000D4   0xDA01             BGE      ??fbi_fbe_15
   \   000000D6   0x2104             MOVS     R1,#+4
   \   000000D8   0xE000             B        ??fbi_fbe_11
    394            else {frdiv_val = 5;}
   \                     ??fbi_fbe_15:
   \   000000DA   0x2105             MOVS     R1,#+5
    395            
    396          // Select external oscilator and Reference Divider and clear IREFS to start ext osc
    397          // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
    398          // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
    399            temp_reg = MCG_C1;
   \                     ??fbi_fbe_11:
   \   000000DC   0x....             LDR      R3,??DataTable6  ;; 0x40064000
   \   000000DE   0x781B             LDRB     R3,[R3, #+0]
    400            temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these fields
   \   000000E0   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   000000E2   0x0F9B             LSRS     R3,R3,#+30
    401            temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
   \   000000E4   0x001D             MOVS     R5,R3
   \   000000E6   0x00C9             LSLS     R1,R1,#+3
   \   000000E8   0x2438             MOVS     R4,#+56
   \   000000EA   0x400C             ANDS     R4,R4,R1
   \   000000EC   0x2380             MOVS     R3,#+128
   \   000000EE   0x4323             ORRS     R3,R3,R4
   \   000000F0   0x432B             ORRS     R3,R3,R5
    402            MCG_C1 = temp_reg;
   \   000000F2   0x....             LDR      R1,??DataTable6  ;; 0x40064000
   \   000000F4   0x700B             STRB     R3,[R1, #+0]
    403          
    404          // if the external oscillator is used need to wait for OSCINIT to set
    405            if (erefs_val)
   \   000000F6   0xB2D2             UXTB     R2,R2
   \   000000F8   0x2A00             CMP      R2,#+0
   \   000000FA   0xD010             BEQ      ??fbi_fbe_16
    406            {
    407              for (i = 0 ; i < 10000 ; i++)
   \   000000FC   0x2100             MOVS     R1,#+0
   \   000000FE   0xE000             B        ??fbi_fbe_17
   \                     ??fbi_fbe_18:
   \   00000100   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fbe_17:
   \   00000102   0x....             LDR      R2,??DataTable8_14  ;; 0x2710
   \   00000104   0xB209             SXTH     R1,R1
   \   00000106   0x4291             CMP      R1,R2
   \   00000108   0xDA03             BGE      ??fbi_fbe_19
    408              {
    409                if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
   \   0000010A   0x....             LDR      R2,??DataTable8_1  ;; 0x40064006
   \   0000010C   0x7812             LDRB     R2,[R2, #+0]
   \   0000010E   0x0792             LSLS     R2,R2,#+30
   \   00000110   0xD5F6             BPL      ??fbi_fbe_18
    410              }
    411              if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
   \                     ??fbi_fbe_19:
   \   00000112   0x....             LDR      R1,??DataTable8_1  ;; 0x40064006
   \   00000114   0x7809             LDRB     R1,[R1, #+0]
   \   00000116   0x0789             LSLS     R1,R1,#+30
   \   00000118   0xD401             BMI      ??fbi_fbe_16
   \   0000011A   0x2023             MOVS     R0,#+35
   \   0000011C   0xE031             B        ??fbi_fbe_2
    412            }
    413          
    414          // wait for Reference clock Status bit to clear
    415            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbi_fbe_16:
   \   0000011E   0x2100             MOVS     R1,#+0
   \   00000120   0xE000             B        ??fbi_fbe_20
   \                     ??fbi_fbe_21:
   \   00000122   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fbe_20:
   \   00000124   0x22FA             MOVS     R2,#+250
   \   00000126   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000128   0xB209             SXTH     R1,R1
   \   0000012A   0x4291             CMP      R1,R2
   \   0000012C   0xDA03             BGE      ??fbi_fbe_22
    416            {
    417              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   \   0000012E   0x....             LDR      R2,??DataTable8_1  ;; 0x40064006
   \   00000130   0x7812             LDRB     R2,[R2, #+0]
   \   00000132   0x06D2             LSLS     R2,R2,#+27
   \   00000134   0xD4F5             BMI      ??fbi_fbe_21
    418            }
    419            if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
   \                     ??fbi_fbe_22:
   \   00000136   0x....             LDR      R1,??DataTable8_1  ;; 0x40064006
   \   00000138   0x7809             LDRB     R1,[R1, #+0]
   \   0000013A   0x06C9             LSLS     R1,R1,#+27
   \   0000013C   0xD501             BPL      ??fbi_fbe_23
   \   0000013E   0x2011             MOVS     R0,#+17
   \   00000140   0xE01F             B        ??fbi_fbe_2
    420            
    421          // Wait for clock status bits to show clock source is ext ref clk
    422            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbi_fbe_23:
   \   00000142   0x2100             MOVS     R1,#+0
   \   00000144   0xE000             B        ??fbi_fbe_24
   \                     ??fbi_fbe_25:
   \   00000146   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fbe_24:
   \   00000148   0x22FA             MOVS     R2,#+250
   \   0000014A   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   0000014C   0xB209             SXTH     R1,R1
   \   0000014E   0x4291             CMP      R1,R2
   \   00000150   0xDA07             BGE      ??fbi_fbe_26
    423            {
    424              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \   00000152   0x....             LDR      R2,??DataTable8_1  ;; 0x40064006
   \   00000154   0x7812             LDRB     R2,[R2, #+0]
   \   00000156   0xB2D2             UXTB     R2,R2
   \   00000158   0x0892             LSRS     R2,R2,#+2
   \   0000015A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000015C   0x0F92             LSRS     R2,R2,#+30
   \   0000015E   0x2A02             CMP      R2,#+2
   \   00000160   0xD1F1             BNE      ??fbi_fbe_25
    425            }
    426            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
   \                     ??fbi_fbe_26:
   \   00000162   0x....             LDR      R1,??DataTable8_1  ;; 0x40064006
   \   00000164   0x7809             LDRB     R1,[R1, #+0]
   \   00000166   0xB2C9             UXTB     R1,R1
   \   00000168   0x0889             LSRS     R1,R1,#+2
   \   0000016A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000016C   0x0F89             LSRS     R1,R1,#+30
   \   0000016E   0x2902             CMP      R1,#+2
   \   00000170   0xD001             BEQ      ??fbi_fbe_27
   \   00000172   0x201A             MOVS     R0,#+26
   \   00000174   0xE005             B        ??fbi_fbe_2
    427           
    428          // Now in FBE  
    429          // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
    430          // It is enabled here but can be removed if this is not required.
    431           // MCG_C6 |= MCG_C6_CME0_MASK;
    432            MCG_C6 |= MCG_C6_CME0_MASK;
   \                     ??fbi_fbe_27:
   \   00000176   0x....             LDR      R1,??DataTable9  ;; 0x40064005
   \   00000178   0x7809             LDRB     R1,[R1, #+0]
   \   0000017A   0x2220             MOVS     R2,#+32
   \   0000017C   0x430A             ORRS     R2,R2,R1
   \   0000017E   0x....             LDR      R1,??DataTable9  ;; 0x40064005
   \   00000180   0x700A             STRB     R2,[R1, #+0]
    433            
    434            return crystal_val; // MCGOUT frequency equals external clock frequency  
   \                     ??fbi_fbe_2:
   \   00000182   0xBD30             POP      {R4,R5,PC}       ;; return
    435          } // fbi_fbe
    436          
    437          
    438          /********************************************************************/
    439          /* Functon name : fbi_blpi
    440           *
    441           * Mode transition: FBI to BLPI mode
    442           *
    443           * This function transitions the MCG from FBI mode to BLPI mode. This is
    444           * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
    445           * check so 0 is always returned if the function was called with the MCG
    446           * in FBI mode. 
    447           *
    448           * Parameters: irc_freq - internal reference clock frequency
    449           *             ircs_select - 0 if slow irc, 1 if fast irc
    450           *
    451           * Return value : MCGOUT frequency or error code 0x13
    452           */

   \                                 In section .text, align 2, keep-with-next
    453          int fbi_blpi(int irc_freq, unsigned char irc_select)
    454          {
   \                     fbi_blpi:
   \   00000000   0xB500             PUSH     {LR}
    455            unsigned char fcrdiv_val;
    456            
    457          // check if in FBI mode
    458            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
    459                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
    460             //   (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    461                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
   \   00000002   0x....             LDR      R2,??DataTable8_1  ;; 0x40064006
   \   00000004   0x7812             LDRB     R2,[R2, #+0]
   \   00000006   0xB2D2             UXTB     R2,R2
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000000C   0x0F92             LSRS     R2,R2,#+30
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xD107             BNE      ??fbi_blpi_0
   \   00000012   0x....             LDR      R2,??DataTable8_1  ;; 0x40064006
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x06D2             LSLS     R2,R2,#+27
   \   00000018   0xD503             BPL      ??fbi_blpi_0
   \   0000001A   0x....             LDR      R2,??DataTable8_2  ;; 0x40064001
   \   0000001C   0x7812             LDRB     R2,[R2, #+0]
   \   0000001E   0x0792             LSLS     R2,R2,#+30
   \   00000020   0xD501             BPL      ??fbi_blpi_1
    462            {  
    463              return 0x3;                                                       // MCG not in correct mode return fail code 
   \                     ??fbi_blpi_0:
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xE014             B        ??fbi_blpi_2
    464            }
    465          
    466          // Set LP bit to disable the FLL and enter BLPI
    467            MCG_C2 |= MCG_C2_LP_MASK;
   \                     ??fbi_blpi_1:
   \   00000026   0x....             LDR      R2,??DataTable8_2  ;; 0x40064001
   \   00000028   0x7812             LDRB     R2,[R2, #+0]
   \   0000002A   0x2302             MOVS     R3,#+2
   \   0000002C   0x4313             ORRS     R3,R3,R2
   \   0000002E   0x....             LDR      R2,??DataTable8_2  ;; 0x40064001
   \   00000030   0x7013             STRB     R3,[R2, #+0]
    468            
    469          // Now in BLPI
    470            if (irc_select)
   \   00000032   0xB2C9             UXTB     R1,R1
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD00B             BEQ      ??fbi_blpi_3
    471            {
    472              fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fast IRC divder factor
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x....             LDR      R2,??DataTable8  ;; 0x40064008
   \   0000003C   0x7812             LDRB     R2,[R2, #+0]
   \   0000003E   0xB2D2             UXTB     R2,R2
   \   00000040   0x0852             LSRS     R2,R2,#+1
   \   00000042   0x0752             LSLS     R2,R2,#+29       ;; ZeroExtS R2,R2,#+29,#+29
   \   00000044   0x0F52             LSRS     R2,R2,#+29
   \   00000046   0x4091             LSLS     R1,R1,R2
    473              return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
   \   00000048   0xB2C9             UXTB     R1,R1
   \   0000004A   0x.... 0x....      BL       __aeabi_idiv
   \   0000004E   0xE7FF             B        ??fbi_blpi_2
    474            }
    475            else
    476            {
    477              return irc_freq; // MCGOUT frequency equals slow IRC frequency
   \                     ??fbi_blpi_3:
   \                     ??fbi_blpi_2:
   \   00000050   0xBD00             POP      {PC}             ;; return
    478            }   
    479          } // fbi_blpi
    480          
    481          
    482          
    483          /********************************************************************/
    484          /* Functon name : blpi_fbi
    485           *
    486           * Mode transition: BLPI to FBI mode
    487           *
    488           * This function transitions the MCG from BLPI mode to FBI mode. This is
    489           * achieved by clearing the MCG_C2[LP] bit. There is no status bit to 
    490           * check so 0 is always returned if the function was called with the MCG
    491           * in BLPI mode. 
    492           *
    493           * Parameters: irc_freq - internal reference clock frequency
    494           *             ircs_select - 0 if slow irc, 1 if fast irc
    495           *
    496           * Return value : MCGOUT frequency or error code 0x15
    497           */

   \                                 In section .text, align 2, keep-with-next
    498          int blpi_fbi(int irc_freq, unsigned char irc_select)
    499          {
   \                     blpi_fbi:
   \   00000000   0xB500             PUSH     {LR}
    500            unsigned char fcrdiv_val;
    501            // check if in BLPI mode
    502            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
    503                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
    504             //   (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    505                (MCG_C2 & MCG_C2_LP_MASK)))                                     // check LP bit is set
   \   00000002   0x....             LDR      R2,??DataTable8_1  ;; 0x40064006
   \   00000004   0x7812             LDRB     R2,[R2, #+0]
   \   00000006   0xB2D2             UXTB     R2,R2
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000000C   0x0F92             LSRS     R2,R2,#+30
   \   0000000E   0x2A01             CMP      R2,#+1
   \   00000010   0xD107             BNE      ??blpi_fbi_0
   \   00000012   0x....             LDR      R2,??DataTable8_1  ;; 0x40064006
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x06D2             LSLS     R2,R2,#+27
   \   00000018   0xD503             BPL      ??blpi_fbi_0
   \   0000001A   0x....             LDR      R2,??DataTable8_2  ;; 0x40064001
   \   0000001C   0x7812             LDRB     R2,[R2, #+0]
   \   0000001E   0x0792             LSLS     R2,R2,#+30
   \   00000020   0xD401             BMI      ??blpi_fbi_1
    506            {
    507              return 0x5;                                                       // MCG not in correct mode return fail code
   \                     ??blpi_fbi_0:
   \   00000022   0x2005             MOVS     R0,#+5
   \   00000024   0xE014             B        ??blpi_fbi_2
    508            }
    509          
    510          // Clear LP bit to enable the FLL and enter FBI mode   
    511            MCG_C2 &= ~MCG_C2_LP_MASK;
   \                     ??blpi_fbi_1:
   \   00000026   0x....             LDR      R2,??DataTable8_2  ;; 0x40064001
   \   00000028   0x7812             LDRB     R2,[R2, #+0]
   \   0000002A   0x23FD             MOVS     R3,#+253
   \   0000002C   0x4013             ANDS     R3,R3,R2
   \   0000002E   0x....             LDR      R2,??DataTable8_2  ;; 0x40064001
   \   00000030   0x7013             STRB     R3,[R2, #+0]
    512            
    513          // Now in FBI mode
    514            if (irc_select)
   \   00000032   0xB2C9             UXTB     R1,R1
   \   00000034   0x2900             CMP      R1,#+0
   \   00000036   0xD00B             BEQ      ??blpi_fbi_3
    515            {
    516              fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fast IRC divder factor
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x....             LDR      R2,??DataTable8  ;; 0x40064008
   \   0000003C   0x7812             LDRB     R2,[R2, #+0]
   \   0000003E   0xB2D2             UXTB     R2,R2
   \   00000040   0x0852             LSRS     R2,R2,#+1
   \   00000042   0x0752             LSLS     R2,R2,#+29       ;; ZeroExtS R2,R2,#+29,#+29
   \   00000044   0x0F52             LSRS     R2,R2,#+29
   \   00000046   0x4091             LSLS     R1,R1,R2
    517              return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
   \   00000048   0xB2C9             UXTB     R1,R1
   \   0000004A   0x.... 0x....      BL       __aeabi_idiv
   \   0000004E   0xE7FF             B        ??blpi_fbi_2
    518            }
    519            else
    520            {
    521              return irc_freq; // MCGOUT frequency equals slow IRC frequency
   \                     ??blpi_fbi_3:
   \                     ??blpi_fbi_2:
   \   00000050   0xBD00             POP      {PC}             ;; return
    522            }
    523          } // blpi_fbi
    524          
    525          

   \                                 In section .text, align 2, keep-with-next
    526          int fbi_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
    527          {
   \                     fbi_fee:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0015             MOVS     R5,R2
    528            unsigned char temp_reg;
    529            unsigned char frdiv_val;
    530            short i;
    531            int mcg_out, fll_ref_freq;
    532          
    533          // check if in FBI mode
    534            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
    535                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
    536             //   (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    537                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
   \   00000004   0x....             LDR      R2,??DataTable9_1  ;; 0x40064006
   \   00000006   0x7812             LDRB     R2,[R2, #+0]
   \   00000008   0xB2D2             UXTB     R2,R2
   \   0000000A   0x0892             LSRS     R2,R2,#+2
   \   0000000C   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000000E   0x0F92             LSRS     R2,R2,#+30
   \   00000010   0x2A01             CMP      R2,#+1
   \   00000012   0xD107             BNE      ??fbi_fee_0
   \   00000014   0x....             LDR      R2,??DataTable9_1  ;; 0x40064006
   \   00000016   0x7812             LDRB     R2,[R2, #+0]
   \   00000018   0x06D2             LSLS     R2,R2,#+27
   \   0000001A   0xD503             BPL      ??fbi_fee_0
   \   0000001C   0x....             LDR      R2,??DataTable9_2  ;; 0x40064001
   \   0000001E   0x7812             LDRB     R2,[R2, #+0]
   \   00000020   0x0792             LSLS     R2,R2,#+30
   \   00000022   0xD501             BPL      ??fbi_fee_1
    538            {  
    539              return 0x3;                                                       // MCG not in correct mode return fail code 
   \                     ??fbi_fee_0:
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0xE0C0             B        ??fbi_fee_2
    540            }
    541            
    542          // check external frequency is less than the maximum frequency
    543            if  (crystal_val > 50000000) {return 0x21;}
   \                     ??fbi_fee_1:
   \   00000028   0x....             LDR      R2,??DataTable9_3  ;; 0x2faf081
   \   0000002A   0x4290             CMP      R0,R2
   \   0000002C   0xDB01             BLT      ??fbi_fee_3
   \   0000002E   0x2021             MOVS     R0,#+33
   \   00000030   0xE0BB             B        ??fbi_fee_2
    544            
    545          // check crystal frequency is within spec. if crystal osc is being used
    546            if (erefs_val)
   \                     ??fbi_fee_3:
   \   00000032   0xB2ED             UXTB     R5,R5
   \   00000034   0x2D00             CMP      R5,#+0
   \   00000036   0xD00C             BEQ      ??fbi_fee_4
    547            {
    548              if ((crystal_val < 30000) ||
    549                  ((crystal_val > 40000) && (crystal_val < 3000000)) ||
    550                  (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal options is not available
   \   00000038   0x....             LDR      R2,??DataTable9_4  ;; 0x7530
   \   0000003A   0x4290             CMP      R0,R2
   \   0000003C   0xDB07             BLT      ??fbi_fee_5
   \   0000003E   0x....             LDR      R2,??DataTable9_5  ;; 0x9c41
   \   00000040   0x1A82             SUBS     R2,R0,R2
   \   00000042   0x....             LDR      R3,??DataTable9_6  ;; 0x2d2a7f
   \   00000044   0x429A             CMP      R2,R3
   \   00000046   0xD302             BCC      ??fbi_fee_5
   \   00000048   0x....             LDR      R2,??DataTable9_7  ;; 0x1e84801
   \   0000004A   0x4290             CMP      R0,R2
   \   0000004C   0xDB01             BLT      ??fbi_fee_4
   \                     ??fbi_fee_5:
   \   0000004E   0x2022             MOVS     R0,#+34
   \   00000050   0xE0AB             B        ??fbi_fee_2
    551            }
    552          
    553          // make sure HGO will never be greater than 1. Could return an error instead if desired.  
    554            if (hgo_val > 0)
   \                     ??fbi_fee_4:
   \   00000052   0xB2C9             UXTB     R1,R1
   \   00000054   0x2901             CMP      R1,#+1
   \   00000056   0xD300             BCC      ??fbi_fee_6
    555            {
    556              hgo_val = 1; // force hgo_val to 1 if > 0
   \   00000058   0x2101             MOVS     R1,#+1
    557            }
    558          
    559          // configure the MCG_C2 register
    560          // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
    561          // it still needs to be set correctly even if the oscillator is not being used
    562            temp_reg = MCG_C2;
   \                     ??fbi_fee_6:
   \   0000005A   0x....             LDR      R2,??DataTable9_2  ;; 0x40064001
   \   0000005C   0x7812             LDRB     R2,[R2, #+0]
    563            temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
   \   0000005E   0x0013             MOVS     R3,R2
   \   00000060   0x22C3             MOVS     R2,#+195
   \   00000062   0x401A             ANDS     R2,R2,R3
    564            if (crystal_val <= 40000)
   \   00000064   0x....             LDR      R3,??DataTable9_5  ;; 0x9c41
   \   00000066   0x4298             CMP      R0,R3
   \   00000068   0xDA07             BGE      ??fbi_fee_7
    565            {
    566              temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   0000006A   0x0013             MOVS     R3,R2
   \   0000006C   0xB2C9             UXTB     R1,R1
   \   0000006E   0x00C9             LSLS     R1,R1,#+3
   \   00000070   0xB2ED             UXTB     R5,R5
   \   00000072   0x00AA             LSLS     R2,R5,#+2
   \   00000074   0x430A             ORRS     R2,R2,R1
   \   00000076   0x431A             ORRS     R2,R2,R3
   \   00000078   0xE015             B        ??fbi_fee_8
    567            }
    568            else if (crystal_val <= 8000000)
   \                     ??fbi_fee_7:
   \   0000007A   0x....             LDR      R3,??DataTable9_8  ;; 0x7a1201
   \   0000007C   0x4298             CMP      R0,R3
   \   0000007E   0xDA09             BGE      ??fbi_fee_9
    569            {
    570              temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   00000080   0xB2C9             UXTB     R1,R1
   \   00000082   0x00C9             LSLS     R1,R1,#+3
   \   00000084   0xB2ED             UXTB     R5,R5
   \   00000086   0x00AB             LSLS     R3,R5,#+2
   \   00000088   0x430B             ORRS     R3,R3,R1
   \   0000008A   0x2110             MOVS     R1,#+16
   \   0000008C   0x4319             ORRS     R1,R1,R3
   \   0000008E   0x4311             ORRS     R1,R1,R2
   \   00000090   0x000A             MOVS     R2,R1
   \   00000092   0xE008             B        ??fbi_fee_8
    571            }
    572            else
    573            {
    574              temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \                     ??fbi_fee_9:
   \   00000094   0x0014             MOVS     R4,R2
   \   00000096   0xB2C9             UXTB     R1,R1
   \   00000098   0x00C9             LSLS     R1,R1,#+3
   \   0000009A   0xB2ED             UXTB     R5,R5
   \   0000009C   0x00AB             LSLS     R3,R5,#+2
   \   0000009E   0x430B             ORRS     R3,R3,R1
   \   000000A0   0x2220             MOVS     R2,#+32
   \   000000A2   0x431A             ORRS     R2,R2,R3
   \   000000A4   0x4322             ORRS     R2,R2,R4
    575            }
    576            MCG_C2 = temp_reg;
   \                     ??fbi_fee_8:
   \   000000A6   0x....             LDR      R1,??DataTable9_2  ;; 0x40064001
   \   000000A8   0x700A             STRB     R2,[R1, #+0]
    577          
    578          // determine FRDIV based on reference clock frequency
    579          // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
    580            if (crystal_val <= 1250000) {frdiv_val = 0;}
   \   000000AA   0x....             LDR      R1,??DataTable10  ;; 0x1312d1
   \   000000AC   0x4288             CMP      R0,R1
   \   000000AE   0xDA01             BGE      ??fbi_fee_10
   \   000000B0   0x2400             MOVS     R4,#+0
   \   000000B2   0xE014             B        ??fbi_fee_11
    581            else if (crystal_val <= 2500000) {frdiv_val = 1;}
   \                     ??fbi_fee_10:
   \   000000B4   0x....             LDR      R1,??DataTable10_1  ;; 0x2625a1
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xDA01             BGE      ??fbi_fee_12
   \   000000BA   0x2401             MOVS     R4,#+1
   \   000000BC   0xE00F             B        ??fbi_fee_11
    582            else if (crystal_val <= 5000000) {frdiv_val = 2;}
   \                     ??fbi_fee_12:
   \   000000BE   0x....             LDR      R1,??DataTable10_2  ;; 0x4c4b41
   \   000000C0   0x4288             CMP      R0,R1
   \   000000C2   0xDA01             BGE      ??fbi_fee_13
   \   000000C4   0x2402             MOVS     R4,#+2
   \   000000C6   0xE00A             B        ??fbi_fee_11
    583            else if (crystal_val <= 10000000) {frdiv_val = 3;}
   \                     ??fbi_fee_13:
   \   000000C8   0x....             LDR      R1,??DataTable10_3  ;; 0x989681
   \   000000CA   0x4288             CMP      R0,R1
   \   000000CC   0xDA01             BGE      ??fbi_fee_14
   \   000000CE   0x2403             MOVS     R4,#+3
   \   000000D0   0xE005             B        ??fbi_fee_11
    584            else if (crystal_val <= 20000000) {frdiv_val = 4;}
   \                     ??fbi_fee_14:
   \   000000D2   0x....             LDR      R1,??DataTable10_4  ;; 0x1312d01
   \   000000D4   0x4288             CMP      R0,R1
   \   000000D6   0xDA01             BGE      ??fbi_fee_15
   \   000000D8   0x2404             MOVS     R4,#+4
   \   000000DA   0xE000             B        ??fbi_fee_11
    585            else {frdiv_val = 5;}
   \                     ??fbi_fee_15:
   \   000000DC   0x2405             MOVS     R4,#+5
    586          // The FLL ref clk divide value depends on FRDIV and the RANGE value
    587            if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
   \                     ??fbi_fee_11:
   \   000000DE   0x....             LDR      R1,??DataTable9_2  ;; 0x40064001
   \   000000E0   0x7809             LDRB     R1,[R1, #+0]
   \   000000E2   0xB2C9             UXTB     R1,R1
   \   000000E4   0x0909             LSRS     R1,R1,#+4
   \   000000E6   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   000000E8   0x0F89             LSRS     R1,R1,#+30
   \   000000EA   0x2900             CMP      R1,#+0
   \   000000EC   0xD004             BEQ      ??fbi_fee_16
    588            {
    589              fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
   \   000000EE   0x2120             MOVS     R1,#+32
   \   000000F0   0x40A1             LSLS     R1,R1,R4
   \   000000F2   0x.... 0x....      BL       __aeabi_idiv
   \   000000F6   0xE003             B        ??fbi_fee_17
    590            }
    591            else
    592            {
    593              fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
   \                     ??fbi_fee_16:
   \   000000F8   0x2101             MOVS     R1,#+1
   \   000000FA   0x40A1             LSLS     R1,R1,R4
   \   000000FC   0x.... 0x....      BL       __aeabi_idiv
    594            }
    595            
    596          // Check resulting FLL frequency 
    597            mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRDIV
   \                     ??fbi_fee_17:
   \   00000100   0x.... 0x....      BL       fll_freq
    598            if (mcg_out < 0x5B) {return mcg_out;} // If error code returned, return the code to calling function
   \   00000104   0x285B             CMP      R0,#+91
   \   00000106   0xDB50             BLT      ??fbi_fee_2
    599            
    600          // Select external oscilator and Reference Divider and clear IREFS to start ext osc
    601          // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
    602          // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=?, IREFSTEN=?
    603            temp_reg = MCG_C1;
   \                     ??fbi_fee_18:
   \   00000108   0x....             LDR      R1,??DataTable10_5  ;; 0x40064000
   \   0000010A   0x780A             LDRB     R2,[R1, #+0]
    604            temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear CLKS, FRDIV and IREFS fields
   \   0000010C   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000010E   0x0F92             LSRS     R2,R2,#+30
    605            temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
   \   00000110   0x0013             MOVS     R3,R2
   \   00000112   0x00E1             LSLS     R1,R4,#+3
   \   00000114   0x2238             MOVS     R2,#+56
   \   00000116   0x400A             ANDS     R2,R2,R1
   \   00000118   0x431A             ORRS     R2,R2,R3
    606            MCG_C1 = temp_reg;
   \   0000011A   0x....             LDR      R1,??DataTable10_5  ;; 0x40064000
   \   0000011C   0x700A             STRB     R2,[R1, #+0]
    607          
    608          // if the external oscillator is used need to wait for OSCINIT to set
    609            if (erefs_val)
   \   0000011E   0xB2ED             UXTB     R5,R5
   \   00000120   0x2D00             CMP      R5,#+0
   \   00000122   0xD010             BEQ      ??fbi_fee_19
    610            {
    611              for (i = 0 ; i < 10000 ; i++)
   \   00000124   0x2100             MOVS     R1,#+0
   \   00000126   0xE000             B        ??fbi_fee_20
   \                     ??fbi_fee_21:
   \   00000128   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fee_20:
   \   0000012A   0x....             LDR      R2,??DataTable10_6  ;; 0x2710
   \   0000012C   0xB209             SXTH     R1,R1
   \   0000012E   0x4291             CMP      R1,R2
   \   00000130   0xDA03             BGE      ??fbi_fee_22
    612              {
    613                if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
   \   00000132   0x....             LDR      R2,??DataTable9_1  ;; 0x40064006
   \   00000134   0x7812             LDRB     R2,[R2, #+0]
   \   00000136   0x0792             LSLS     R2,R2,#+30
   \   00000138   0xD5F6             BPL      ??fbi_fee_21
    614              }
    615              if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
   \                     ??fbi_fee_22:
   \   0000013A   0x....             LDR      R1,??DataTable9_1  ;; 0x40064006
   \   0000013C   0x7809             LDRB     R1,[R1, #+0]
   \   0000013E   0x0789             LSLS     R1,R1,#+30
   \   00000140   0xD401             BMI      ??fbi_fee_19
   \   00000142   0x2023             MOVS     R0,#+35
   \   00000144   0xE031             B        ??fbi_fee_2
    616            }
    617          
    618          // wait for Reference clock Status bit to clear
    619            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbi_fee_19:
   \   00000146   0x2100             MOVS     R1,#+0
   \   00000148   0xE000             B        ??fbi_fee_23
   \                     ??fbi_fee_24:
   \   0000014A   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fee_23:
   \   0000014C   0x22FA             MOVS     R2,#+250
   \   0000014E   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000150   0xB209             SXTH     R1,R1
   \   00000152   0x4291             CMP      R1,R2
   \   00000154   0xDA03             BGE      ??fbi_fee_25
    620            {
    621              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   \   00000156   0x....             LDR      R2,??DataTable9_1  ;; 0x40064006
   \   00000158   0x7812             LDRB     R2,[R2, #+0]
   \   0000015A   0x06D2             LSLS     R2,R2,#+27
   \   0000015C   0xD4F5             BMI      ??fbi_fee_24
    622            }
    623            if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
   \                     ??fbi_fee_25:
   \   0000015E   0x....             LDR      R1,??DataTable9_1  ;; 0x40064006
   \   00000160   0x7809             LDRB     R1,[R1, #+0]
   \   00000162   0x06C9             LSLS     R1,R1,#+27
   \   00000164   0xD501             BPL      ??fbi_fee_26
   \   00000166   0x2011             MOVS     R0,#+17
   \   00000168   0xE01F             B        ??fbi_fee_2
    624            
    625          // Wait for clock status bits to show clock source is ext ref clk
    626            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbi_fee_26:
   \   0000016A   0x2100             MOVS     R1,#+0
   \   0000016C   0xE000             B        ??fbi_fee_27
   \                     ??fbi_fee_28:
   \   0000016E   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fee_27:
   \   00000170   0x22FA             MOVS     R2,#+250
   \   00000172   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000174   0xB209             SXTH     R1,R1
   \   00000176   0x4291             CMP      R1,R2
   \   00000178   0xDA07             BGE      ??fbi_fee_29
    627            {
    628              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST shows FLL selected before loop finishes
   \   0000017A   0x....             LDR      R2,??DataTable9_1  ;; 0x40064006
   \   0000017C   0x7812             LDRB     R2,[R2, #+0]
   \   0000017E   0xB2D2             UXTB     R2,R2
   \   00000180   0x0892             LSRS     R2,R2,#+2
   \   00000182   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   00000184   0x0F92             LSRS     R2,R2,#+30
   \   00000186   0x2A00             CMP      R2,#+0
   \   00000188   0xD1F1             BNE      ??fbi_fee_28
    629            }
    630            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLLK is really selected and return with error if not
   \                     ??fbi_fee_29:
   \   0000018A   0x....             LDR      R1,??DataTable9_1  ;; 0x40064006
   \   0000018C   0x7809             LDRB     R1,[R1, #+0]
   \   0000018E   0xB2C9             UXTB     R1,R1
   \   00000190   0x0889             LSRS     R1,R1,#+2
   \   00000192   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   00000194   0x0F89             LSRS     R1,R1,#+30
   \   00000196   0x2900             CMP      R1,#+0
   \   00000198   0xD001             BEQ      ??fbi_fee_30
   \   0000019A   0x2018             MOVS     R0,#+24
   \   0000019C   0xE005             B        ??fbi_fee_2
    631           
    632          // Now in FEE  
    633          // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
    634          // It is enabled here but can be removed if this is not required.
    635          // The clock monitor MUST be disabled when returning to a non-external clock mode (FEI, FBI and BLPI)
    636           // MCG_C6 |= MCG_C6_CME0_MASK;
    637            MCG_C6 |= MCG_C6_CME0_MASK;
   \                     ??fbi_fee_30:
   \   0000019E   0x....             LDR      R1,??DataTable11  ;; 0x40064005
   \   000001A0   0x7809             LDRB     R1,[R1, #+0]
   \   000001A2   0x2220             MOVS     R2,#+32
   \   000001A4   0x430A             ORRS     R2,R2,R1
   \   000001A6   0x....             LDR      R1,??DataTable11  ;; 0x40064005
   \   000001A8   0x700A             STRB     R2,[R1, #+0]
    638            
    639            return mcg_out; // MCGOUT frequency equals FLL frequency
   \                     ??fbi_fee_2:
   \   000001AA   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    640          } //fbi_fee
    641          
    642          

   \                                 In section .text, align 2, keep-with-next
    643          int fee_fbi(int irc_freq, unsigned char irc_select)
    644          { 
   \                     fee_fbi:
   \   00000000   0xB500             PUSH     {LR}
    645            unsigned char fcrdiv_val;
    646            short i;
    647            
    648          // Check MCG is in FEE mode
    649          /*
    650            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
    651                (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external ref clk
    652                (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected FLL
    653          */ 
    654           if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
    655          		 (!(MCG_S & MCG_S_IREFST_MASK))))	
   \   00000002   0x....             LDR      R2,??DataTable11_1  ;; 0x40064006
   \   00000004   0x7812             LDRB     R2,[R2, #+0]
   \   00000006   0xB2D2             UXTB     R2,R2
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000000C   0x0F92             LSRS     R2,R2,#+30
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD103             BNE      ??fee_fbi_0
   \   00000012   0x....             LDR      R2,??DataTable11_1  ;; 0x40064006
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x06D2             LSLS     R2,R2,#+27
   \   00000018   0xD501             BPL      ??fee_fbi_1
    656          
    657            {
    658              return 0x2;                                                     // return error code
   \                     ??fee_fbi_0:
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE08E             B        ??fee_fbi_2
    659            }
    660            
    661            // Check that the irc frequency matches the selected IRC 
    662            if (!(irc_select))
   \                     ??fee_fbi_1:
   \   0000001E   0xB2C9             UXTB     R1,R1
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD106             BNE      ??fee_fbi_3
    663            {    
    664              if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
   \   00000024   0x....             LDR      R2,??DataTable11_2  ;; 0x7a12
   \   00000026   0x1A82             SUBS     R2,R0,R2
   \   00000028   0x....             LDR      R3,??DataTable11_3  ;; 0x1e86
   \   0000002A   0x429A             CMP      R2,R3
   \   0000002C   0xD308             BCC      ??fee_fbi_4
   \   0000002E   0x2031             MOVS     R0,#+49
   \   00000030   0xE084             B        ??fee_fbi_2
    665            }
    666            else
    667            {
    668              if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
   \                     ??fee_fbi_3:
   \   00000032   0x....             LDR      R2,??DataTable11_4  ;; 0x2dc6c0
   \   00000034   0x1A82             SUBS     R2,R0,R2
   \   00000036   0x....             LDR      R3,??DataTable11_5  ;; 0x1e8481
   \   00000038   0x429A             CMP      R2,R3
   \   0000003A   0xD301             BCC      ??fee_fbi_4
   \   0000003C   0x2032             MOVS     R0,#+50
   \   0000003E   0xE07D             B        ??fee_fbi_2
    669            }
    670            
    671          // Select the required IRC
    672            if (irc_select)
   \                     ??fee_fbi_4:
   \   00000040   0xB2C9             UXTB     R1,R1
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xD006             BEQ      ??fee_fbi_5
    673            {
    674              MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRC by setting IRCS
   \   00000046   0x....             LDR      R2,??DataTable11_6  ;; 0x40064001
   \   00000048   0x7812             LDRB     R2,[R2, #+0]
   \   0000004A   0x2301             MOVS     R3,#+1
   \   0000004C   0x4313             ORRS     R3,R3,R2
   \   0000004E   0x....             LDR      R2,??DataTable11_6  ;; 0x40064001
   \   00000050   0x7013             STRB     R3,[R2, #+0]
   \   00000052   0xE005             B        ??fee_fbi_6
    675            }
    676            else
    677            {
    678              MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRC by clearing IRCS
   \                     ??fee_fbi_5:
   \   00000054   0x....             LDR      R2,??DataTable11_6  ;; 0x40064001
   \   00000056   0x7812             LDRB     R2,[R2, #+0]
   \   00000058   0x23FE             MOVS     R3,#+254
   \   0000005A   0x4013             ANDS     R3,R3,R2
   \   0000005C   0x....             LDR      R2,??DataTable11_6  ;; 0x40064001
   \   0000005E   0x7013             STRB     R3,[R2, #+0]
    679            }
    680            
    681          // Make sure the clock monitor is disabled before switching modes otherwise it will trigger
    682           // MCG_C6 &= ~MCG_C6_CME0_MASK;
    683             MCG_C6 &= ~MCG_C6_CME0_MASK;
   \                     ??fee_fbi_6:
   \   00000060   0x....             LDR      R2,??DataTable11  ;; 0x40064005
   \   00000062   0x7812             LDRB     R2,[R2, #+0]
   \   00000064   0x23DF             MOVS     R3,#+223
   \   00000066   0x4013             ANDS     R3,R3,R2
   \   00000068   0x....             LDR      R2,??DataTable11  ;; 0x40064005
   \   0000006A   0x7013             STRB     R3,[R2, #+0]
    684            
    685          // Select the IRC as the CLKS mux selection
    686            MCG_C1 |= MCG_C1_CLKS(1) | MCG_C1_IREFS_MASK; // set IREFS and select IRC as MCGOUT
   \   0000006C   0x....             LDR      R2,??DataTable10_5  ;; 0x40064000
   \   0000006E   0x7812             LDRB     R2,[R2, #+0]
   \   00000070   0x2344             MOVS     R3,#+68
   \   00000072   0x4313             ORRS     R3,R3,R2
   \   00000074   0x....             LDR      R2,??DataTable10_5  ;; 0x40064000
   \   00000076   0x7013             STRB     R3,[R2, #+0]
    687           
    688          // wait until internal reference switches to requested irc.
    689            if (!(irc_select))
   \   00000078   0xB2C9             UXTB     R1,R1
   \   0000007A   0x2900             CMP      R1,#+0
   \   0000007C   0xD111             BNE      ??fee_fbi_7
    690            {
    691              for (i = 0 ; i < 2000 ; i++)
   \   0000007E   0x2200             MOVS     R2,#+0
   \   00000080   0xE000             B        ??fee_fbi_8
   \                     ??fee_fbi_9:
   \   00000082   0x1C52             ADDS     R2,R2,#+1
   \                     ??fee_fbi_8:
   \   00000084   0x23FA             MOVS     R3,#+250
   \   00000086   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   00000088   0xB212             SXTH     R2,R2
   \   0000008A   0x429A             CMP      R2,R3
   \   0000008C   0xDA03             BGE      ??fee_fbi_10
    692              {
    693                if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishes
   \   0000008E   0x....             LDR      R3,??DataTable11_1  ;; 0x40064006
   \   00000090   0x781B             LDRB     R3,[R3, #+0]
   \   00000092   0x07DB             LSLS     R3,R3,#+31
   \   00000094   0xD4F5             BMI      ??fee_fbi_9
    694              }
    695              if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error if set
   \                     ??fee_fbi_10:
   \   00000096   0x....             LDR      R2,??DataTable11_1  ;; 0x40064006
   \   00000098   0x7812             LDRB     R2,[R2, #+0]
   \   0000009A   0x07D2             LSLS     R2,R2,#+31
   \   0000009C   0xD513             BPL      ??fee_fbi_11
   \   0000009E   0x2013             MOVS     R0,#+19
   \   000000A0   0xE04C             B        ??fee_fbi_2
    696            }
    697            else
    698            {
    699              for (i = 0 ; i < 2000 ; i++)
   \                     ??fee_fbi_7:
   \   000000A2   0x2200             MOVS     R2,#+0
   \   000000A4   0xE000             B        ??fee_fbi_12
   \                     ??fee_fbi_13:
   \   000000A6   0x1C52             ADDS     R2,R2,#+1
   \                     ??fee_fbi_12:
   \   000000A8   0x23FA             MOVS     R3,#+250
   \   000000AA   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   000000AC   0xB212             SXTH     R2,R2
   \   000000AE   0x429A             CMP      R2,R3
   \   000000B0   0xDA03             BGE      ??fee_fbi_14
    700              {
    701                if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
   \   000000B2   0x....             LDR      R3,??DataTable11_1  ;; 0x40064006
   \   000000B4   0x781B             LDRB     R3,[R3, #+0]
   \   000000B6   0x07DB             LSLS     R3,R3,#+31
   \   000000B8   0xD5F5             BPL      ??fee_fbi_13
    702              }
    703              if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error if not set
   \                     ??fee_fbi_14:
   \   000000BA   0x....             LDR      R2,??DataTable11_1  ;; 0x40064006
   \   000000BC   0x7812             LDRB     R2,[R2, #+0]
   \   000000BE   0x07D2             LSLS     R2,R2,#+31
   \   000000C0   0xD401             BMI      ??fee_fbi_11
   \   000000C2   0x2014             MOVS     R0,#+20
   \   000000C4   0xE03A             B        ??fee_fbi_2
    704            }
    705            
    706          // Wait for clock status bits to update
    707            for (i = 0 ; i < 2000 ; i++)
   \                     ??fee_fbi_11:
   \   000000C6   0x2200             MOVS     R2,#+0
   \   000000C8   0xE000             B        ??fee_fbi_15
   \                     ??fee_fbi_16:
   \   000000CA   0x1C52             ADDS     R2,R2,#+1
   \                     ??fee_fbi_15:
   \   000000CC   0x23FA             MOVS     R3,#+250
   \   000000CE   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   000000D0   0xB212             SXTH     R2,R2
   \   000000D2   0x429A             CMP      R2,R3
   \   000000D4   0xDA07             BGE      ??fee_fbi_17
    708            {
    709              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST shows IRC slected before loop finishes
   \   000000D6   0x....             LDR      R3,??DataTable11_1  ;; 0x40064006
   \   000000D8   0x781B             LDRB     R3,[R3, #+0]
   \   000000DA   0xB2DB             UXTB     R3,R3
   \   000000DC   0x089B             LSRS     R3,R3,#+2
   \   000000DE   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   000000E0   0x0F9B             LSRS     R3,R3,#+30
   \   000000E2   0x2B01             CMP      R3,#+1
   \   000000E4   0xD1F1             BNE      ??fee_fbi_16
    710            }
    711            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really selected and return with error if not
   \                     ??fee_fbi_17:
   \   000000E6   0x....             LDR      R2,??DataTable11_1  ;; 0x40064006
   \   000000E8   0x7812             LDRB     R2,[R2, #+0]
   \   000000EA   0xB2D2             UXTB     R2,R2
   \   000000EC   0x0892             LSRS     R2,R2,#+2
   \   000000EE   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   000000F0   0x0F92             LSRS     R2,R2,#+30
   \   000000F2   0x2A01             CMP      R2,#+1
   \   000000F4   0xD001             BEQ      ??fee_fbi_18
   \   000000F6   0x2019             MOVS     R0,#+25
   \   000000F8   0xE020             B        ??fee_fbi_2
    712            
    713          // wait for Reference clock Status bit to set
    714            for (i = 0 ; i < 2000 ; i++)
   \                     ??fee_fbi_18:
   \   000000FA   0x2200             MOVS     R2,#+0
   \   000000FC   0xE000             B        ??fee_fbi_19
   \                     ??fee_fbi_20:
   \   000000FE   0x1C52             ADDS     R2,R2,#+1
   \                     ??fee_fbi_19:
   \   00000100   0x23FA             MOVS     R3,#+250
   \   00000102   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   00000104   0xB212             SXTH     R2,R2
   \   00000106   0x429A             CMP      R2,R3
   \   00000108   0xDA03             BGE      ??fee_fbi_21
    715            {
    716              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
   \   0000010A   0x....             LDR      R3,??DataTable11_1  ;; 0x40064006
   \   0000010C   0x781B             LDRB     R3,[R3, #+0]
   \   0000010E   0x06DB             LSLS     R3,R3,#+27
   \   00000110   0xD5F5             BPL      ??fee_fbi_20
    717            }
    718            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set  
   \                     ??fee_fbi_21:
   \   00000112   0x....             LDR      R2,??DataTable11_1  ;; 0x40064006
   \   00000114   0x7812             LDRB     R2,[R2, #+0]
   \   00000116   0x06D2             LSLS     R2,R2,#+27
   \   00000118   0xD401             BMI      ??fee_fbi_22
   \   0000011A   0x2012             MOVS     R0,#+18
   \   0000011C   0xE00E             B        ??fee_fbi_2
    719            
    720          // Now in FBI mode
    721            if (irc_select)
   \                     ??fee_fbi_22:
   \   0000011E   0xB2C9             UXTB     R1,R1
   \   00000120   0x2900             CMP      R1,#+0
   \   00000122   0xD00B             BEQ      ??fee_fbi_23
    722            {
    723              fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fast IRC divder factor
   \   00000124   0x2101             MOVS     R1,#+1
   \   00000126   0x....             LDR      R2,??DataTable13  ;; 0x40064008
   \   00000128   0x7812             LDRB     R2,[R2, #+0]
   \   0000012A   0xB2D2             UXTB     R2,R2
   \   0000012C   0x0852             LSRS     R2,R2,#+1
   \   0000012E   0x0752             LSLS     R2,R2,#+29       ;; ZeroExtS R2,R2,#+29,#+29
   \   00000130   0x0F52             LSRS     R2,R2,#+29
   \   00000132   0x4091             LSLS     R1,R1,R2
    724              return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
   \   00000134   0xB2C9             UXTB     R1,R1
   \   00000136   0x.... 0x....      BL       __aeabi_idiv
   \   0000013A   0xE7FF             B        ??fee_fbi_2
    725            }
    726            else
    727            {
    728              return irc_freq; // MCGOUT frequency equals slow IRC frequency
   \                     ??fee_fbi_23:
   \                     ??fee_fbi_2:
   \   0000013C   0xBD00             POP      {PC}             ;; return
    729            }
    730          } // fee_fbi 
    731          
    732          

   \                                 In section .text, align 2, keep-with-next
    733          int fbi_fei(int slow_irc_freq)
    734          {
   \                     fbi_fei:
   \   00000000   0xB580             PUSH     {R7,LR}
    735            unsigned char temp_reg;
    736            short i;
    737            int mcg_out;
    738          
    739          // check if in FBI mode
    740            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
    741                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
    742             //   (!(MCG_S & MCG_S_PLLST_MASK)) &&                                // check PLLS mux has selected FLL
    743                (!(MCG_C2 & MCG_C2_LP_MASK))))                                  // check LP bit is clear
   \   00000002   0x....             LDR      R1,??DataTable13_1  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2901             CMP      R1,#+1
   \   00000010   0xD107             BNE      ??fbi_fei_0
   \   00000012   0x....             LDR      R1,??DataTable13_1  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD503             BPL      ??fbi_fei_0
   \   0000001A   0x....             LDR      R1,??DataTable11_6  ;; 0x40064001
   \   0000001C   0x7809             LDRB     R1,[R1, #+0]
   \   0000001E   0x0789             LSLS     R1,R1,#+30
   \   00000020   0xD501             BPL      ??fbi_fei_1
    744            {  
    745              return 0x3;                                                       // MCG not in correct mode return fail code 
   \                     ??fbi_fei_0:
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0xE03F             B        ??fbi_fei_2
    746            }
    747          
    748          // Check IRC frequency is within spec.
    749            if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
   \                     ??fbi_fei_1:
   \   00000026   0x....             LDR      R1,??DataTable11_2  ;; 0x7a12
   \   00000028   0x1A41             SUBS     R1,R0,R1
   \   0000002A   0x....             LDR      R2,??DataTable11_3  ;; 0x1e86
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xD301             BCC      ??fbi_fei_3
    750            {
    751              return 0x31;
   \   00000030   0x2031             MOVS     R0,#+49
   \   00000032   0xE038             B        ??fbi_fei_2
    752            }
    753          
    754          // Check resulting FLL frequency 
    755            mcg_out = fll_freq(slow_irc_freq); 
   \                     ??fbi_fei_3:
   \   00000034   0x.... 0x....      BL       fll_freq
    756            if (mcg_out < 0x5B) {return mcg_out;} // If error code returned, return the code to calling function
   \   00000038   0x285B             CMP      R0,#+91
   \   0000003A   0xDB34             BLT      ??fbi_fei_2
    757            
    758          // Change the CLKS mux to select the FLL output as MCGOUT  
    759            temp_reg = MCG_C1;
   \                     ??fbi_fei_4:
   \   0000003C   0x....             LDR      R1,??DataTable13_2  ;; 0x40064000
   \   0000003E   0x7809             LDRB     R1,[R1, #+0]
    760            temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS field
   \   00000040   0x0689             LSLS     R1,R1,#+26       ;; ZeroExtS R1,R1,#+26,#+26
   \   00000042   0x0E89             LSRS     R1,R1,#+26
    761            temp_reg |= MCG_C1_CLKS(0); // select FLL as MCGOUT
    762            temp_reg |= MCG_C1_IREFS_MASK; // make sure IRC is FLL reference
   \   00000044   0x000A             MOVS     R2,R1
   \   00000046   0x2104             MOVS     R1,#+4
   \   00000048   0x4311             ORRS     R1,R1,R2
    763            MCG_C1 = temp_reg; // update MCG_C1
   \   0000004A   0x....             LDR      R2,??DataTable13_2  ;; 0x40064000
   \   0000004C   0x7011             STRB     R1,[R2, #+0]
    764            
    765          // wait for Reference clock Status bit to clear
    766            for (i = 0 ; i < 2000 ; i++)
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0xE000             B        ??fbi_fei_5
   \                     ??fbi_fei_6:
   \   00000052   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fei_5:
   \   00000054   0x22FA             MOVS     R2,#+250
   \   00000056   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000058   0xB209             SXTH     R1,R1
   \   0000005A   0x4291             CMP      R1,R2
   \   0000005C   0xDA03             BGE      ??fbi_fei_7
    767            {
    768              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST clears before loop finishes
   \   0000005E   0x....             LDR      R2,??DataTable13_1  ;; 0x40064006
   \   00000060   0x7812             LDRB     R2,[R2, #+0]
   \   00000062   0x06D2             LSLS     R2,R2,#+27
   \   00000064   0xD5F5             BPL      ??fbi_fei_6
    769            }
    770            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set
   \                     ??fbi_fei_7:
   \   00000066   0x....             LDR      R1,??DataTable13_1  ;; 0x40064006
   \   00000068   0x7809             LDRB     R1,[R1, #+0]
   \   0000006A   0x06C9             LSLS     R1,R1,#+27
   \   0000006C   0xD401             BMI      ??fbi_fei_8
   \   0000006E   0x2012             MOVS     R0,#+18
   \   00000070   0xE019             B        ??fbi_fei_2
    771            
    772          // Wait for clock status bits to show clock source is ext ref clk
    773            for (i = 0 ; i < 2000 ; i++)
   \                     ??fbi_fei_8:
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0xE000             B        ??fbi_fei_9
   \                     ??fbi_fei_10:
   \   00000076   0x1C49             ADDS     R1,R1,#+1
   \                     ??fbi_fei_9:
   \   00000078   0x22FA             MOVS     R2,#+250
   \   0000007A   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   0000007C   0xB209             SXTH     R1,R1
   \   0000007E   0x4291             CMP      R1,R2
   \   00000080   0xDA07             BGE      ??fbi_fei_11
    774            {
    775              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) break; // jump out early if CLKST shows FLL slected before loop finishes
   \   00000082   0x....             LDR      R2,??DataTable13_1  ;; 0x40064006
   \   00000084   0x7812             LDRB     R2,[R2, #+0]
   \   00000086   0xB2D2             UXTB     R2,R2
   \   00000088   0x0892             LSRS     R2,R2,#+2
   \   0000008A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000008C   0x0F92             LSRS     R2,R2,#+30
   \   0000008E   0x2A00             CMP      R2,#+0
   \   00000090   0xD1F1             BNE      ??fbi_fei_10
    776            }
    777            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x0) return 0x18; // check FLL is really selected and return with error if not
   \                     ??fbi_fei_11:
   \   00000092   0x....             LDR      R1,??DataTable13_1  ;; 0x40064006
   \   00000094   0x7809             LDRB     R1,[R1, #+0]
   \   00000096   0xB2C9             UXTB     R1,R1
   \   00000098   0x0889             LSRS     R1,R1,#+2
   \   0000009A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000009C   0x0F89             LSRS     R1,R1,#+30
   \   0000009E   0x2900             CMP      R1,#+0
   \   000000A0   0xD001             BEQ      ??fbi_fei_12
   \   000000A2   0x2018             MOVS     R0,#+24
   \   000000A4   0xE7FF             B        ??fbi_fei_2
    778          
    779          // Now in FEI mode
    780            return mcg_out;  
   \                     ??fbi_fei_12:
   \                     ??fbi_fei_2:
   \   000000A6   0xBD02             POP      {R1,PC}          ;; return
    781          } // fbi_fei
    782          
    783          

   \                                 In section .text, align 2, keep-with-next
    784          int fei_fbi(int irc_freq, unsigned char irc_select)
    785          {
   \                     fei_fbi:
   \   00000000   0xB500             PUSH     {LR}
    786            unsigned char temp_reg;
    787            unsigned char fcrdiv_val;
    788            short i;
    789            
    790          // Check MCG is in FEI mode
    791          /*
    792            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
    793                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
    794                (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
    795          */
    796          	if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
    797          		(MCG_S & MCG_S_IREFST_MASK))) 								// check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R2,??DataTable13_1  ;; 0x40064006
   \   00000004   0x7812             LDRB     R2,[R2, #+0]
   \   00000006   0xB2D2             UXTB     R2,R2
   \   00000008   0x0892             LSRS     R2,R2,#+2
   \   0000000A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000000C   0x0F92             LSRS     R2,R2,#+30
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD103             BNE      ??fei_fbi_0
   \   00000012   0x....             LDR      R2,??DataTable13_1  ;; 0x40064006
   \   00000014   0x7812             LDRB     R2,[R2, #+0]
   \   00000016   0x06D2             LSLS     R2,R2,#+27
   \   00000018   0xD401             BMI      ??fei_fbi_1
    798          
    799            {
    800              return 0x1;                                                       // return error code
   \                     ??fei_fbi_0:
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE079             B        ??fei_fbi_2
    801            } 
    802          
    803          // Check that the irc frequency matches the selected IRC 
    804            if (!(irc_select))
   \                     ??fei_fbi_1:
   \   0000001E   0xB2C9             UXTB     R1,R1
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0xD106             BNE      ??fei_fbi_3
    805            {    
    806              if ((irc_freq < 31250) || (irc_freq > 39063)) {return 0x31;}
   \   00000024   0x....             LDR      R2,??DataTable13_3  ;; 0x7a12
   \   00000026   0x1A82             SUBS     R2,R0,R2
   \   00000028   0x....             LDR      R3,??DataTable13_4  ;; 0x1e86
   \   0000002A   0x429A             CMP      R2,R3
   \   0000002C   0xD308             BCC      ??fei_fbi_4
   \   0000002E   0x2031             MOVS     R0,#+49
   \   00000030   0xE06F             B        ??fei_fbi_2
    807            }
    808            else
    809            {
    810              if ((irc_freq < 3000000) || (irc_freq > 5000000)) {return 0x32;} // Fast IRC freq
   \                     ??fei_fbi_3:
   \   00000032   0x....             LDR      R2,??DataTable13_5  ;; 0x2dc6c0
   \   00000034   0x1A82             SUBS     R2,R0,R2
   \   00000036   0x....             LDR      R3,??DataTable13_6  ;; 0x1e8481
   \   00000038   0x429A             CMP      R2,R3
   \   0000003A   0xD301             BCC      ??fei_fbi_4
   \   0000003C   0x2032             MOVS     R0,#+50
   \   0000003E   0xE068             B        ??fei_fbi_2
    811            }
    812            
    813          // Select the desired IRC
    814            if (irc_select)
   \                     ??fei_fbi_4:
   \   00000040   0xB2C9             UXTB     R1,R1
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xD006             BEQ      ??fei_fbi_5
    815            {
    816              MCG_C2 |= MCG_C2_IRCS_MASK; // select fast IRCS
   \   00000046   0x....             LDR      R2,??DataTable13_7  ;; 0x40064001
   \   00000048   0x7812             LDRB     R2,[R2, #+0]
   \   0000004A   0x2301             MOVS     R3,#+1
   \   0000004C   0x4313             ORRS     R3,R3,R2
   \   0000004E   0x....             LDR      R2,??DataTable13_7  ;; 0x40064001
   \   00000050   0x7013             STRB     R3,[R2, #+0]
   \   00000052   0xE005             B        ??fei_fbi_6
    817            }
    818            else
    819            {
    820              MCG_C2 &= ~MCG_C2_IRCS_MASK; // select slow IRCS
   \                     ??fei_fbi_5:
   \   00000054   0x....             LDR      R2,??DataTable13_7  ;; 0x40064001
   \   00000056   0x7812             LDRB     R2,[R2, #+0]
   \   00000058   0x23FE             MOVS     R3,#+254
   \   0000005A   0x4013             ANDS     R3,R3,R2
   \   0000005C   0x....             LDR      R2,??DataTable13_7  ;; 0x40064001
   \   0000005E   0x7013             STRB     R3,[R2, #+0]
    821            }
    822            
    823          // Change the CLKS mux to select the IRC as the MCGOUT
    824            temp_reg = MCG_C1;
   \                     ??fei_fbi_6:
   \   00000060   0x....             LDR      R2,??DataTable13_2  ;; 0x40064000
   \   00000062   0x7812             LDRB     R2,[R2, #+0]
    825            temp_reg &= ~MCG_C1_CLKS_MASK; // clear CLKS
   \   00000064   0x0692             LSLS     R2,R2,#+26       ;; ZeroExtS R2,R2,#+26,#+26
   \   00000066   0x0E92             LSRS     R2,R2,#+26
    826            temp_reg |= MCG_C1_CLKS(1); // select IRC as the MCG clock sourse
   \   00000068   0x0013             MOVS     R3,R2
   \   0000006A   0x2240             MOVS     R2,#+64
   \   0000006C   0x431A             ORRS     R2,R2,R3
    827            MCG_C1 = temp_reg;
   \   0000006E   0x....             LDR      R3,??DataTable13_2  ;; 0x40064000
   \   00000070   0x701A             STRB     R2,[R3, #+0]
    828          
    829          // wait until internal reference switches to requested irc.
    830            if (!(irc_select))
   \   00000072   0xB2C9             UXTB     R1,R1
   \   00000074   0x2900             CMP      R1,#+0
   \   00000076   0xD111             BNE      ??fei_fbi_7
    831            {
    832              for (i = 0 ; i < 2000 ; i++)
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0xE000             B        ??fei_fbi_8
   \                     ??fei_fbi_9:
   \   0000007C   0x1C52             ADDS     R2,R2,#+1
   \                     ??fei_fbi_8:
   \   0000007E   0x23FA             MOVS     R3,#+250
   \   00000080   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   00000082   0xB212             SXTH     R2,R2
   \   00000084   0x429A             CMP      R2,R3
   \   00000086   0xDA03             BGE      ??fei_fbi_10
    833              {
    834                if (!(MCG_S & MCG_S_IRCST_MASK)) break; // jump out early if IRCST clears before loop finishes
   \   00000088   0x....             LDR      R3,??DataTable13_1  ;; 0x40064006
   \   0000008A   0x781B             LDRB     R3,[R3, #+0]
   \   0000008C   0x07DB             LSLS     R3,R3,#+31
   \   0000008E   0xD4F5             BMI      ??fei_fbi_9
    835              }
    836              if (MCG_S & MCG_S_IRCST_MASK) return 0x13; // check bit is really clear and return with error if set
   \                     ??fei_fbi_10:
   \   00000090   0x....             LDR      R2,??DataTable13_1  ;; 0x40064006
   \   00000092   0x7812             LDRB     R2,[R2, #+0]
   \   00000094   0x07D2             LSLS     R2,R2,#+31
   \   00000096   0xD513             BPL      ??fei_fbi_11
   \   00000098   0x2013             MOVS     R0,#+19
   \   0000009A   0xE03A             B        ??fei_fbi_2
    837            }
    838            else
    839            {
    840              for (i = 0 ; i < 2000 ; i++)
   \                     ??fei_fbi_7:
   \   0000009C   0x2200             MOVS     R2,#+0
   \   0000009E   0xE000             B        ??fei_fbi_12
   \                     ??fei_fbi_13:
   \   000000A0   0x1C52             ADDS     R2,R2,#+1
   \                     ??fei_fbi_12:
   \   000000A2   0x23FA             MOVS     R3,#+250
   \   000000A4   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   000000A6   0xB212             SXTH     R2,R2
   \   000000A8   0x429A             CMP      R2,R3
   \   000000AA   0xDA03             BGE      ??fei_fbi_14
    841              {
    842                if (MCG_S & MCG_S_IRCST_MASK) break; // jump out early if IRCST sets before loop finishes
   \   000000AC   0x....             LDR      R3,??DataTable13_1  ;; 0x40064006
   \   000000AE   0x781B             LDRB     R3,[R3, #+0]
   \   000000B0   0x07DB             LSLS     R3,R3,#+31
   \   000000B2   0xD5F5             BPL      ??fei_fbi_13
    843              }
    844              if (!(MCG_S & MCG_S_IRCST_MASK)) return 0x14; // check bit is really set and return with error if not set
   \                     ??fei_fbi_14:
   \   000000B4   0x....             LDR      R2,??DataTable13_1  ;; 0x40064006
   \   000000B6   0x7812             LDRB     R2,[R2, #+0]
   \   000000B8   0x07D2             LSLS     R2,R2,#+31
   \   000000BA   0xD401             BMI      ??fei_fbi_11
   \   000000BC   0x2014             MOVS     R0,#+20
   \   000000BE   0xE028             B        ??fei_fbi_2
    845            }
    846            
    847          // Wait for clock status bits to update
    848            for (i = 0 ; i < 2000 ; i++)
   \                     ??fei_fbi_11:
   \   000000C0   0x2200             MOVS     R2,#+0
   \   000000C2   0xE000             B        ??fei_fbi_15
   \                     ??fei_fbi_16:
   \   000000C4   0x1C52             ADDS     R2,R2,#+1
   \                     ??fei_fbi_15:
   \   000000C6   0x23FA             MOVS     R3,#+250
   \   000000C8   0x00DB             LSLS     R3,R3,#+3        ;; #+2000
   \   000000CA   0xB212             SXTH     R2,R2
   \   000000CC   0x429A             CMP      R2,R3
   \   000000CE   0xDA07             BGE      ??fei_fbi_17
    849            {
    850              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) break; // jump out early if CLKST shows IRC slected before loop finishes
   \   000000D0   0x....             LDR      R3,??DataTable13_1  ;; 0x40064006
   \   000000D2   0x781B             LDRB     R3,[R3, #+0]
   \   000000D4   0xB2DB             UXTB     R3,R3
   \   000000D6   0x089B             LSRS     R3,R3,#+2
   \   000000D8   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   000000DA   0x0F9B             LSRS     R3,R3,#+30
   \   000000DC   0x2B01             CMP      R3,#+1
   \   000000DE   0xD1F1             BNE      ??fei_fbi_16
    851            }
    852            if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x1) return 0x19; // check IRC is really selected and return with error if not
   \                     ??fei_fbi_17:
   \   000000E0   0x....             LDR      R2,??DataTable13_1  ;; 0x40064006
   \   000000E2   0x7812             LDRB     R2,[R2, #+0]
   \   000000E4   0xB2D2             UXTB     R2,R2
   \   000000E6   0x0892             LSRS     R2,R2,#+2
   \   000000E8   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   000000EA   0x0F92             LSRS     R2,R2,#+30
   \   000000EC   0x2A01             CMP      R2,#+1
   \   000000EE   0xD001             BEQ      ??fei_fbi_18
   \   000000F0   0x2019             MOVS     R0,#+25
   \   000000F2   0xE00E             B        ??fei_fbi_2
    853            
    854          // Now in FBI mode
    855            if (irc_select)
   \                     ??fei_fbi_18:
   \   000000F4   0xB2C9             UXTB     R1,R1
   \   000000F6   0x2900             CMP      R1,#+0
   \   000000F8   0xD00B             BEQ      ??fei_fbi_19
    856            {
    857              fcrdiv_val = (1 << ((MCG_SC & MCG_SC_FCRDIV_MASK) >> MCG_SC_FCRDIV_SHIFT)); // calculate the fast IRC divder factor
   \   000000FA   0x2101             MOVS     R1,#+1
   \   000000FC   0x....             LDR      R2,??DataTable13  ;; 0x40064008
   \   000000FE   0x7812             LDRB     R2,[R2, #+0]
   \   00000100   0xB2D2             UXTB     R2,R2
   \   00000102   0x0852             LSRS     R2,R2,#+1
   \   00000104   0x0752             LSLS     R2,R2,#+29       ;; ZeroExtS R2,R2,#+29,#+29
   \   00000106   0x0F52             LSRS     R2,R2,#+29
   \   00000108   0x4091             LSLS     R1,R1,R2
    858              return (irc_freq / fcrdiv_val); // MCGOUT frequency equals fast IRC frequency divided by 2
   \   0000010A   0xB2C9             UXTB     R1,R1
   \   0000010C   0x.... 0x....      BL       __aeabi_idiv
   \   00000110   0xE7FF             B        ??fei_fbi_2
    859            }
    860            else
    861            {
    862              return irc_freq; // MCGOUT frequency equals slow IRC frequency
   \                     ??fei_fbi_19:
   \                     ??fei_fbi_2:
   \   00000112   0xBD00             POP      {PC}             ;; return
    863            }   
    864          } // fei_fbi
    865          
    866          
    867          
    868          

   \                                 In section .text, align 2, keep-with-next
    869          int fee_fei(int slow_irc_freq)
    870          {
   \                     fee_fei:
   \   00000000   0xB580             PUSH     {R7,LR}
    871            short i;
    872            int mcg_out;
    873          
    874          // Check MCG is in FEE mode
    875          /*
    876            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL
    877                (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external ref clk
    878                (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected FLL
    879          */
    880          	if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL
    881          		(!(MCG_S & MCG_S_IREFST_MASK)))) 							  // check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R1,??DataTable13_1  ;; 0x40064006
   \   00000004   0x7809             LDRB     R1,[R1, #+0]
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x0889             LSRS     R1,R1,#+2
   \   0000000A   0x0789             LSLS     R1,R1,#+30       ;; ZeroExtS R1,R1,#+30,#+30
   \   0000000C   0x0F89             LSRS     R1,R1,#+30
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD103             BNE      ??fee_fei_0
   \   00000012   0x....             LDR      R1,??DataTable13_1  ;; 0x40064006
   \   00000014   0x7809             LDRB     R1,[R1, #+0]
   \   00000016   0x06C9             LSLS     R1,R1,#+27
   \   00000018   0xD501             BPL      ??fee_fei_1
    882          
    883            {
    884              return 0x2;                                                     // return error code
   \                     ??fee_fei_0:
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE028             B        ??fee_fei_2
    885            } 
    886                
    887          // Check IRC frequency is within spec.
    888            if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
   \                     ??fee_fei_1:
   \   0000001E   0x....             LDR      R1,??DataTable13_3  ;; 0x7a12
   \   00000020   0x1A41             SUBS     R1,R0,R1
   \   00000022   0x....             LDR      R2,??DataTable13_4  ;; 0x1e86
   \   00000024   0x4291             CMP      R1,R2
   \   00000026   0xD301             BCC      ??fee_fei_3
    889            {
    890              return 0x31;
   \   00000028   0x2031             MOVS     R0,#+49
   \   0000002A   0xE021             B        ??fee_fei_2
    891            }
    892          
    893            // Check resulting FLL frequency 
    894            mcg_out = fll_freq(slow_irc_freq); 
   \                     ??fee_fei_3:
   \   0000002C   0x.... 0x....      BL       fll_freq
    895            if (mcg_out < 0x5B) {return mcg_out;} // If error code returned, return the code to calling function
   \   00000030   0x285B             CMP      R0,#+91
   \   00000032   0xDB1D             BLT      ??fee_fei_2
    896            
    897          // Ensure clock monitor is disabled before switching to FEI otherwise a loss of clock will trigger
    898            MCG_C6 &= ~MCG_C6_CME0_MASK;
   \                     ??fee_fei_4:
   \   00000034   0x....             LDR      R1,??DataTable14  ;; 0x40064005
   \   00000036   0x7809             LDRB     R1,[R1, #+0]
   \   00000038   0x22DF             MOVS     R2,#+223
   \   0000003A   0x400A             ANDS     R2,R2,R1
   \   0000003C   0x....             LDR      R1,??DataTable14  ;; 0x40064005
   \   0000003E   0x700A             STRB     R2,[R1, #+0]
    899          
    900          // Change FLL reference clock from external to internal by setting IREFS bit
    901            MCG_C1 |= MCG_C1_IREFS_MASK; // select internal reference
   \   00000040   0x....             LDR      R1,??DataTable13_2  ;; 0x40064000
   \   00000042   0x7809             LDRB     R1,[R1, #+0]
   \   00000044   0x2204             MOVS     R2,#+4
   \   00000046   0x430A             ORRS     R2,R2,R1
   \   00000048   0x....             LDR      R1,??DataTable13_2  ;; 0x40064000
   \   0000004A   0x700A             STRB     R2,[R1, #+0]
    902            
    903          // wait for Reference clock to switch to internal reference 
    904            for (i = 0 ; i < 2000 ; i++)
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0xE000             B        ??fee_fei_5
   \                     ??fee_fei_6:
   \   00000050   0x1C49             ADDS     R1,R1,#+1
   \                     ??fee_fei_5:
   \   00000052   0x22FA             MOVS     R2,#+250
   \   00000054   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000056   0xB209             SXTH     R1,R1
   \   00000058   0x4291             CMP      R1,R2
   \   0000005A   0xDA03             BGE      ??fee_fei_7
    905            {
    906              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
   \   0000005C   0x....             LDR      R2,??DataTable13_1  ;; 0x40064006
   \   0000005E   0x7812             LDRB     R2,[R2, #+0]
   \   00000060   0x06D2             LSLS     R2,R2,#+27
   \   00000062   0xD5F5             BPL      ??fee_fei_6
    907            }
    908            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set  
   \                     ??fee_fei_7:
   \   00000064   0x....             LDR      R1,??DataTable13_1  ;; 0x40064006
   \   00000066   0x7809             LDRB     R1,[R1, #+0]
   \   00000068   0x06C9             LSLS     R1,R1,#+27
   \   0000006A   0xD401             BMI      ??fee_fei_8
   \   0000006C   0x2012             MOVS     R0,#+18
   \   0000006E   0xE7FF             B        ??fee_fei_2
    909            
    910          // Now in FEI mode  
    911            return mcg_out;  
   \                     ??fee_fei_8:
   \                     ??fee_fei_2:
   \   00000070   0xBD02             POP      {R1,PC}          ;; return
    912          } // fee_fei
    913          
    914          
    915          /********************************************************************/
    916          /* Functon name : fei_fee_rtc
    917           *
    918           * Mode transition: FEI to FEE mode with the RTC clock as the FLL ref clock
    919           *
    920           * This function transitions the MCG from FEI mode to FEE mode with the RTC clock 
    921           * being used as the FLL reference clock. The switching of the OSCSEL mux must be
    922           * made in a non-external clock mode (FEI,FBI or BLPI).
    923           * This driver only makes the changes necessary to the the RTC registers to perform
    924           * the task of enabling and verifying the RTC OSC and only leaves the RTC OSC enabled. 
    925           * After enabling the oscillator the Timer Prescaler Register is used to count 4086 
    926           * cycles to ensure the RTC OSC is running.
    927           * The RTC clock monitor is enabled by means of the CME1 bit (called CME3 in the
    928           * header file.
    929           *
    930           * Parameters: rtc_freq - RTC clock frequency in Hz
    931           *
    932           * Return value : MCGCLKOUT frequency (Hz) or error code
    933           */
    934          /*
    935          int fei_fee_rtc(int rtc_freq)
    936          {
    937            unsigned char disable_rtc_clk_gate = 0;
    938            unsigned char disable_rtc_tce = 0;
    939            unsigned char temp_reg;
    940           
    941            int rtc_count;
    942            int mcg_out, i;
    943            
    944          // check if in FEI mode
    945            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
    946                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
    947                (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
    948            {
    949              return 0x1;                                                     // return error code
    950            }
    951          
    952          // check RTC frequency is within spec.
    953            if  ((rtc_freq > 40000) || (rtc_freq < 30000)) {return 0x24;}
    954            
    955          // check if RTC clock gate is enabled
    956            if (!(SIM_SCGC6 & SIM_SCGC6_RTC_MASK))
    957            {
    958              SIM_SCGC6 |= SIM_SCGC6_RTC_MASK; // enable RTC clock gate
    959              disable_rtc_clk_gate = 1; // flag clock gate needs disabled when complete
    960            }
    961          
    962          // check if RTC TCE is enabled
    963            if (!(RTC_SR & RTC_SR_TCE_MASK))
    964            {
    965              RTC_SR |= RTC_SR_TCE_MASK; // enable RTC clock gate
    966              disable_rtc_tce = 1; // flag TCE needs disabled when complete
    967            }
    968            
    969          // check if RTC oscillator is already enabled and enable it if not
    970            if (!(RTC_CR & RTC_CR_OSCE_MASK))
    971            {
    972              RTC_CR |= RTC_CR_OSCE_MASK; // enable RTC oscillator
    973            }
    974          // check oscillator is running
    975            if (RTC_SR & RTC_SR_TIF_MASK) // check if time invalid flag is set
    976            {
    977              RTC_SR &= ~RTC_SR_TCE_MASK; // make sure time counter enable is cleared to allow TSR to be writable
    978              RTC_TSR = 0x00000000; // clears TIF
    979              RTC_SR |= RTC_SR_TCE_MASK; // re-enable time counter
    980            }
    981          // take a snapshot of counter and add 4096, handling roll-over condition  
    982            if (RTC_TPR > 0x6FFF) 
    983            {
    984              rtc_count = (0x8000 - RTC_TPR); 
    985            }
    986            else
    987            {
    988              rtc_count = (RTC_TPR + 4096);
    989            }
    990            
    991            for (i = 0 ; i < 11250000 ; i++) // allows for > 1 second osc start up time
    992            {
    993              if (RTC_TPR == rtc_count) break; // jump out early if RTC_TPR > desired count before loop finishes
    994            }
    995            if (RTC_TPR != rtc_count) // check if RTC is counting correctly and return with error if not
    996            {
    997              if (disable_rtc_tce)
    998              {
    999                RTC_SR &= ~RTC_SR_TCE_MASK; // disable TCE
   1000              }
   1001              
   1002              if (disable_rtc_clk_gate)
   1003              {
   1004                SIM_SCGC6 &= ~SIM_SCGC6_RTC_MASK; // disable RTC clock gate
   1005              }
   1006              return 0x25; 
   1007            }
   1008          // disable anything that was was originally disabled  
   1009            if (disable_rtc_tce)
   1010            {
   1011              RTC_SR &= ~RTC_SR_TCE_MASK; // disable TCE
   1012            }
   1013            
   1014            if (disable_rtc_clk_gate)
   1015            {
   1016              SIM_SCGC6 &= ~SIM_SCGC6_RTC_MASK; // disable RTC clock gate
   1017            }
   1018            
   1019          // select the RTC oscillator as the MCG reference clock before the external clock is used
   1020            //MCG_C7 |= MCG_C7_OSCSEL_MASK;
   1021           
   1022          // clear IREFS to switch to ext ref clock and set FRDIV to divide by 1 and keep CLKS = 0
   1023          // keep state of IRCLKEN and IREFSTEN
   1024            temp_reg = MCG_C1;
   1025            temp_reg &= (MCG_C1_IRCLKEN_MASK | MCG_C1_IREFSTEN_MASK);
   1026            MCG_C1 = temp_reg;
   1027          
   1028          // wait for Reference clock Status bit to clear
   1029            for (i = 0 ; i < 2000 ; i++)
   1030            {
   1031              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   1032            }
   1033            if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
   1034            
   1035          // Now in FEE 
   1036            
   1037          // Check resulting FLL frequency 
   1038            mcg_out = fll_freq(rtc_freq); // FLL reference frequency calculated from ext ref freq and FRDIV
   1039            if (mcg_out < 0x5B) {return mcg_out;} // If error code returned, return the code to calling function
   1040            
   1041            return mcg_out; // MCGOUT frequency equals FLL frequency
   1042          } // fei_fee_rtc
   1043          */
   1044          
   1045          /********************************************************************/
   1046          /* Functon name : fee_fei_rtc
   1047           *
   1048           * Mode transition: FEE with the RTC clock as the FLL ref clock to FEI mode 
   1049           *
   1050           * This function transitions the MCG from FEE with the RTC clock as the FLL ref clock  
   1051           * to FEI mode. The switching of the OSCSEL mux must be made in a non-external clock 
   1052           * mode (FEI,FBI or BLPI) so the MCG is transitioned to FEI mode before switching the
   1053           * mux.
   1054           * This driver does not make any changes to the the RTC registers and leaves the RTC
   1055           * OSC enabled. 
   1056           * The RTC clock monitor is disabled by means of clearing the CME1 bit (called CME3 
   1057           * in the header file) before switching to FEI mode. If the RTC OSC is to be permanently 
   1058           * kept running then the RTC clock monitor can be left enabled. However, it is 
   1059           * recommended that when the RTC OSC is not used as the system reference clock the 
   1060           * MCG_C8[LOCRE1] bit be cleared and the MCG isr be included which handles the loss of
   1061           * clock interrupt appropriately.
   1062           *
   1063           * Parameters: slow_irc_freq - slow IRC clock frequency in Hz
   1064           *
   1065           * Return value : MCGCLKOUT frequency (Hz) or error code
   1066           */
   1067          /*
   1068          int fee_fei_rtc(int slow_irc_freq)
   1069          {
   1070            int mcg_out, i;
   1071            
   1072          // Check MCG is in FEE mode
   1073            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL
   1074                (!(MCG_S & MCG_S_IREFST_MASK)) &&                             // check FLL ref is external ref clk
   1075                (!(MCG_S & MCG_S_PLLST_MASK))))                               // check PLLS mux has selected FLL
   1076            {
   1077              return 0x2;                                                     // return error code
   1078            } 
   1079                
   1080          // Check IRC frequency is within spec.
   1081            if ((slow_irc_freq < 31250) || (slow_irc_freq > 39063))
   1082            {
   1083              return 0x31;
   1084            }
   1085          
   1086            // Check resulting FLL frequency 
   1087            mcg_out = fll_freq(slow_irc_freq); 
   1088            if (mcg_out < 0x5B) {return mcg_out;} // If error code returned, return the code to calling function
   1089          
   1090          // Change FLL reference clock from external to internal by setting IREFS bit
   1091            MCG_C1 |= MCG_C1_IREFS_MASK; // select internal reference
   1092            
   1093          // wait for Reference clock to switch to internal reference 
   1094            for (i = 0 ; i < 2000 ; i++)
   1095            {
   1096              if (MCG_S & MCG_S_IREFST_MASK) break; // jump out early if IREFST sets before loop finishes
   1097            }
   1098            if (!(MCG_S & MCG_S_IREFST_MASK)) return 0x12; // check bit is really set and return with error if not set  
   1099            
   1100          // Now in FEI mode  
   1101          
   1102          // Switch CLKSEL mux back to system oscillator once external clock is not being used. 
   1103           // MCG_C7 &= ~MCG_C7_OSCSEL_MASK;
   1104            
   1105            return mcg_out; // MCGOUT frequency equals FLL frequency
   1106          } // fee_fei_rtc
   1107          */
   1108          

   \                                 In section .text, align 2, keep-with-next
   1109          unsigned char atc(unsigned char irc_select, int irc_freq, int mcg_out_freq)
   1110          {
   \                     atc:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   1111            unsigned char mcg_mode;
   1112            unsigned short atcv;
   1113            int bus_clock_freq;
   1114            int  bus_clk_div_val;
   1115            int orig_div;
   1116            int temp_reg;
   1117            
   1118            if (irc_select > 0) // force irc to 1 if greater than 0
   \   00000008   0xB2E4             UXTB     R4,R4
   \   0000000A   0x2C01             CMP      R4,#+1
   \   0000000C   0xD300             BCC      ??atc_0
   1119            {
   1120              irc_select = 1;
   \   0000000E   0x2401             MOVS     R4,#+1
   1121            }
   1122            
   1123            mcg_mode = what_mcg_mode(); // get present MCG mode
   \                     ??atc_0:
   \   00000010   0x.... 0x....      BL       what_mcg_mode
   1124            if ((mcg_mode != PEE) && (mcg_mode != PBE) && (mcg_mode != FBE))
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0x2808             CMP      R0,#+8
   \   00000018   0xD007             BEQ      ??atc_1
   \   0000001A   0xB2C0             UXTB     R0,R0
   \   0000001C   0x2807             CMP      R0,#+7
   \   0000001E   0xD004             BEQ      ??atc_1
   \   00000020   0xB2C0             UXTB     R0,R0
   \   00000022   0x2805             CMP      R0,#+5
   \   00000024   0xD001             BEQ      ??atc_1
   1125            {
   1126              return 1; // return error code if not in PEE, PBE or FBE modes
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xE0B1             B        ??atc_2
   1127            }
   1128            
   1129            orig_div = SIM_CLKDIV1; //store present clock divider values
   \                     ??atc_1:
   \   0000002A   0x....             LDR      R0,??DataTable16  ;; 0x40048044
   \   0000002C   0x6807             LDR      R7,[R0, #+0]
   1130            
   1131            bus_clk_div_val = mcg_out_freq / 16000000; // calculate bus clock divider to generate fastest allowed bus clock for autotrim
   \   0000002E   0x0030             MOVS     R0,R6
   \   00000030   0x....             LDR      R1,??DataTable16_1  ;; 0xf42400
   \   00000032   0x.... 0x....      BL       __aeabi_idiv
   1132            temp_reg = SIM_CLKDIV1;
   \   00000036   0x....             LDR      R1,??DataTable16  ;; 0x40048044
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   1133            temp_reg &= ~SIM_CLKDIV1_OUTDIV4_MASK; // clear dividers except core
   \   0000003A   0x000A             MOVS     R2,R1
   \   0000003C   0x....             LDR      R1,??DataTable16_2  ;; 0xfff8ffff
   \   0000003E   0x4011             ANDS     R1,R1,R2
   1134            // set all bus and flash dividers to same value to ensure clocking restrictions are met
   1135            temp_reg |= SIM_CLKDIV1_OUTDIV4(bus_clk_div_val);
   \   00000040   0x000A             MOVS     R2,R1
   \   00000042   0x0400             LSLS     R0,R0,#+16
   \   00000044   0x21E0             MOVS     R1,#+224
   \   00000046   0x02C9             LSLS     R1,R1,#+11       ;; #+458752
   \   00000048   0x4001             ANDS     R1,R1,R0
   \   0000004A   0x4311             ORRS     R1,R1,R2
   1136            SIM_CLKDIV1 = temp_reg; // set actual dividers
   \   0000004C   0x....             LDR      R0,??DataTable16  ;; 0x40048044
   \   0000004E   0x6001             STR      R1,[R0, #+0]
   1137            
   1138            bus_clock_freq = mcg_out_freq / (((SIM_CLKDIV1) >> 16)+ 1);//For L1PT, flash and bus use the same bus div
   \   00000050   0x0030             MOVS     R0,R6
   \   00000052   0x....             LDR      R1,??DataTable16  ;; 0x40048044
   \   00000054   0x6809             LDR      R1,[R1, #+0]
   \   00000056   0x0C09             LSRS     R1,R1,#+16
   \   00000058   0x1C49             ADDS     R1,R1,#+1
   \   0000005A   0x.... 0x....      BL       __aeabi_uidiv
   1139            if ((bus_clock_freq < 8000000) || (bus_clock_freq > 16000000))
   \   0000005E   0x....             LDR      R1,??DataTable16_3  ;; 0x7a1200
   \   00000060   0x1A41             SUBS     R1,R0,R1
   \   00000062   0x....             LDR      R2,??DataTable16_4  ;; 0x7a1201
   \   00000064   0x4291             CMP      R1,R2
   \   00000066   0xD303             BCC      ??atc_3
   1140            {
   1141              SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   00000068   0x....             LDR      R0,??DataTable16  ;; 0x40048044
   \   0000006A   0x6007             STR      R7,[R0, #+0]
   1142              return 3; // error, bus clock frequency is not within 8MHz to 16MHz
   \   0000006C   0x2003             MOVS     R0,#+3
   \   0000006E   0xE08E             B        ??atc_2
   1143            }
   1144                          
   1145            if(!irc_select) //determine if slow or fast IRC to be trimmed
   \                     ??atc_3:
   \   00000070   0xB2E4             UXTB     R4,R4
   \   00000072   0x2C00             CMP      R4,#+0
   \   00000074   0xD10D             BNE      ??atc_4
   1146            {
   1147              if (irc_freq < 31250) // check frequency is above min spec.
   \   00000076   0x....             LDR      R1,??DataTable16_5  ;; 0x7a12
   \   00000078   0x428D             CMP      R5,R1
   \   0000007A   0xDA03             BGE      ??atc_5
   1148              {
   1149                SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   0000007C   0x....             LDR      R0,??DataTable16  ;; 0x40048044
   \   0000007E   0x6007             STR      R7,[R0, #+0]
   1150                return 4;
   \   00000080   0x2004             MOVS     R0,#+4
   \   00000082   0xE084             B        ??atc_2
   1151              }
   1152              if (irc_freq > 39062) // check frequency is below max spec.
   \                     ??atc_5:
   \   00000084   0x....             LDR      R1,??DataTable16_6  ;; 0x9897
   \   00000086   0x428D             CMP      R5,R1
   \   00000088   0xDB11             BLT      ??atc_6
   1153              {
   1154                SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   0000008A   0x....             LDR      R0,??DataTable16  ;; 0x40048044
   \   0000008C   0x6007             STR      R7,[R0, #+0]
   1155                return 5;
   \   0000008E   0x2005             MOVS     R0,#+5
   \   00000090   0xE07D             B        ??atc_2
   1156              }         
   1157            }
   1158            else
   1159            {
   1160              if (irc_freq < 3000000) // check frequency is above min spec.
   \                     ??atc_4:
   \   00000092   0x....             LDR      R1,??DataTable16_7  ;; 0x2dc6c0
   \   00000094   0x428D             CMP      R5,R1
   \   00000096   0xDA03             BGE      ??atc_7
   1161              {
   1162                SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   00000098   0x....             LDR      R0,??DataTable16  ;; 0x40048044
   \   0000009A   0x6007             STR      R7,[R0, #+0]
   1163                return 6;
   \   0000009C   0x2006             MOVS     R0,#+6
   \   0000009E   0xE076             B        ??atc_2
   1164              }
   1165              if (irc_freq > 5000000) // check frequency is below max spec.
   \                     ??atc_7:
   \   000000A0   0x....             LDR      R1,??DataTable16_8  ;; 0x4c4b41
   \   000000A2   0x428D             CMP      R5,R1
   \   000000A4   0xDB03             BLT      ??atc_6
   1166              {
   1167                SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   000000A6   0x....             LDR      R0,??DataTable16  ;; 0x40048044
   \   000000A8   0x6007             STR      R7,[R0, #+0]
   1168                return 7;
   \   000000AA   0x2007             MOVS     R0,#+7
   \   000000AC   0xE06F             B        ??atc_2
   1169              }            
   1170            } // if
   1171                  
   1172          // Set up autocal registers, must use floating point calculation
   1173            if (irc_select) 
   \                     ??atc_6:
   \   000000AE   0xB2E4             UXTB     R4,R4
   \   000000B0   0x2C00             CMP      R4,#+0
   \   000000B2   0xD013             BEQ      ??atc_8
   1174              atcv = (unsigned short)(128.0f * (21.0f * (bus_clock_freq / (float)irc_freq)));
   \   000000B4   0x.... 0x....      BL       __aeabi_i2f
   \   000000B8   0x0006             MOVS     R6,R0
   \   000000BA   0x0028             MOVS     R0,R5
   \   000000BC   0x.... 0x....      BL       __aeabi_i2f
   \   000000C0   0x0001             MOVS     R1,R0
   \   000000C2   0x0030             MOVS     R0,R6
   \   000000C4   0x.... 0x....      BL       __aeabi_fdiv
   \   000000C8   0x....             LDR      R1,??DataTable16_9  ;; 0x41a80000
   \   000000CA   0x.... 0x....      BL       __aeabi_fmul
   \   000000CE   0x2186             MOVS     R1,#+134
   \   000000D0   0x05C9             LSLS     R1,R1,#+23       ;; #+1124073472
   \   000000D2   0x.... 0x....      BL       __aeabi_fmul
   \   000000D6   0x.... 0x....      BL       __aeabi_f2iz
   \   000000DA   0xE00E             B        ??atc_9
   1175            else
   1176              atcv = (unsigned short)(21.0f * (bus_clock_freq / (float)irc_freq));
   \                     ??atc_8:
   \   000000DC   0x.... 0x....      BL       __aeabi_i2f
   \   000000E0   0x0006             MOVS     R6,R0
   \   000000E2   0x0028             MOVS     R0,R5
   \   000000E4   0x.... 0x....      BL       __aeabi_i2f
   \   000000E8   0x0001             MOVS     R1,R0
   \   000000EA   0x0030             MOVS     R0,R6
   \   000000EC   0x.... 0x....      BL       __aeabi_fdiv
   \   000000F0   0x....             LDR      R1,??DataTable16_9  ;; 0x41a80000
   \   000000F2   0x.... 0x....      BL       __aeabi_fmul
   \   000000F6   0x.... 0x....      BL       __aeabi_f2iz
   1177                  
   1178            MCG_ATCVL = (atcv & 0xFF); //Set ATCVL to lower 8 bits of count value
   \                     ??atc_9:
   \   000000FA   0x....             LDR      R1,??DataTable16_10  ;; 0x4006400b
   \   000000FC   0x0002             MOVS     R2,R0
   \   000000FE   0x700A             STRB     R2,[R1, #+0]
   1179            MCG_ATCVH = ((atcv & 0xFF00) >> 8); // Set ATCVH to upper 8 bits of count value
   \   00000100   0xB280             UXTH     R0,R0
   \   00000102   0x0A00             LSRS     R0,R0,#+8
   \   00000104   0x....             LDR      R1,??DataTable16_11  ;; 0x4006400a
   \   00000106   0x7008             STRB     R0,[R1, #+0]
   1180          
   1181          // Enable autocal
   1182            MCG_SC &= ~(MCG_SC_ATME_MASK | MCG_SC_ATMS_MASK |MCG_SC_ATMF_MASK); // clear auto trim settings
   \   00000108   0x....             LDR      R0,??DataTable16_12  ;; 0x40064008
   \   0000010A   0x7800             LDRB     R0,[R0, #+0]
   \   0000010C   0x06C0             LSLS     R0,R0,#+27       ;; ZeroExtS R0,R0,#+27,#+27
   \   0000010E   0x0EC0             LSRS     R0,R0,#+27
   \   00000110   0x....             LDR      R1,??DataTable16_12  ;; 0x40064008
   \   00000112   0x7008             STRB     R0,[R1, #+0]
   1183            temp_reg = (MCG_SC_ATME_MASK | (irc_select << MCG_SC_ATMS_SHIFT)); //Select IRC to trim and enable trim machine
   \   00000114   0xB2E4             UXTB     R4,R4
   \   00000116   0x01A0             LSLS     R0,R4,#+6
   \   00000118   0x2180             MOVS     R1,#+128
   \   0000011A   0x4301             ORRS     R1,R1,R0
   1184            MCG_SC |= temp_reg;
   \   0000011C   0x....             LDR      R0,??DataTable16_12  ;; 0x40064008
   \   0000011E   0x7800             LDRB     R0,[R0, #+0]
   \   00000120   0x4301             ORRS     R1,R1,R0
   \   00000122   0x....             LDR      R0,??DataTable16_12  ;; 0x40064008
   \   00000124   0x7001             STRB     R1,[R0, #+0]
   1185                  
   1186            while (MCG_SC & MCG_SC_ATME_MASK) {}; //poll for ATME bit to clear
   \                     ??atc_10:
   \   00000126   0x....             LDR      R0,??DataTable16_12  ;; 0x40064008
   \   00000128   0x7800             LDRB     R0,[R0, #+0]
   \   0000012A   0x0600             LSLS     R0,R0,#+24
   \   0000012C   0xD4FB             BMI      ??atc_10
   1187                  
   1188            if (MCG_SC & MCG_SC_ATMF_MASK) // check if error flag set
   \   0000012E   0x....             LDR      R0,??DataTable16_12  ;; 0x40064008
   \   00000130   0x7800             LDRB     R0,[R0, #+0]
   \   00000132   0x0680             LSLS     R0,R0,#+26
   \   00000134   0xD503             BPL      ??atc_11
   1189            {
   1190              SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \   00000136   0x....             LDR      R0,??DataTable16  ;; 0x40048044
   \   00000138   0x6007             STR      R7,[R0, #+0]
   1191              return 8;
   \   0000013A   0x2008             MOVS     R0,#+8
   \   0000013C   0xE027             B        ??atc_2
   1192            } 
   1193            else 
   1194            {      
   1195              if (!irc_select)
   \                     ??atc_11:
   \   0000013E   0xB2E4             UXTB     R4,R4
   \   00000140   0x2C00             CMP      R4,#+0
   \   00000142   0xD10D             BNE      ??atc_12
   1196              {
   1197                if ((MCG_C3 == 0xFF) || (MCG_C3 == 0))
   \   00000144   0x....             LDR      R0,??DataTable16_13  ;; 0x40064002
   \   00000146   0x7800             LDRB     R0,[R0, #+0]
   \   00000148   0xB2C0             UXTB     R0,R0
   \   0000014A   0x28FF             CMP      R0,#+255
   \   0000014C   0xD004             BEQ      ??atc_13
   \   0000014E   0x....             LDR      R0,??DataTable16_13  ;; 0x40064002
   \   00000150   0x7800             LDRB     R0,[R0, #+0]
   \   00000152   0xB2C0             UXTB     R0,R0
   \   00000154   0x2800             CMP      R0,#+0
   \   00000156   0xD117             BNE      ??atc_14
   1198                {
   1199                  SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \                     ??atc_13:
   \   00000158   0x....             LDR      R0,??DataTable16  ;; 0x40048044
   \   0000015A   0x6007             STR      R7,[R0, #+0]
   1200                  return 9;
   \   0000015C   0x2009             MOVS     R0,#+9
   \   0000015E   0xE016             B        ??atc_2
   1201                }
   1202              }
   1203              else
   1204              {
   1205                if ((((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0xF) ||
   1206                    (((MCG_C4 & MCG_C4_FCTRIM_MASK) >> MCG_C4_FCTRIM_SHIFT) == 0))
   \                     ??atc_12:
   \   00000160   0x....             LDR      R0,??DataTable16_14  ;; 0x40064003
   \   00000162   0x7800             LDRB     R0,[R0, #+0]
   \   00000164   0xB2C0             UXTB     R0,R0
   \   00000166   0x0840             LSRS     R0,R0,#+1
   \   00000168   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   0000016A   0x0F00             LSRS     R0,R0,#+28
   \   0000016C   0x280F             CMP      R0,#+15
   \   0000016E   0xD007             BEQ      ??atc_15
   \   00000170   0x....             LDR      R0,??DataTable16_14  ;; 0x40064003
   \   00000172   0x7800             LDRB     R0,[R0, #+0]
   \   00000174   0xB2C0             UXTB     R0,R0
   \   00000176   0x0840             LSRS     R0,R0,#+1
   \   00000178   0x0700             LSLS     R0,R0,#+28       ;; ZeroExtS R0,R0,#+28,#+28
   \   0000017A   0x0F00             LSRS     R0,R0,#+28
   \   0000017C   0x2800             CMP      R0,#+0
   \   0000017E   0xD103             BNE      ??atc_14
   1207                {
   1208                  SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \                     ??atc_15:
   \   00000180   0x....             LDR      R0,??DataTable16  ;; 0x40048044
   \   00000182   0x6007             STR      R7,[R0, #+0]
   1209                  return 10;
   \   00000184   0x200A             MOVS     R0,#+10
   \   00000186   0xE002             B        ??atc_2
   1210                }
   1211              }
   1212            }
   1213            SIM_CLKDIV1 = orig_div; // set SIM_CLKDIV1 back to original value
   \                     ??atc_14:
   \   00000188   0x....             LDR      R0,??DataTable16  ;; 0x40048044
   \   0000018A   0x6007             STR      R7,[R0, #+0]
   1214            return 0;
   \   0000018C   0x2000             MOVS     R0,#+0
   \                     ??atc_2:
   \   0000018E   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1215          }// atc
   1216          
   1217          
   1218          
   1219          
   1220          
   1221          
   1222          

   \                                 In section .text, align 2, keep-with-next
   1223          unsigned char what_mcg_mode(void)
   1224          {
   \                     what_mcg_mode:
   \   00000000   0xB500             PUSH     {LR}
   1225            // check if in FEI mode
   1226            /*
   1227            if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) &&      // check CLKS mux has selcted FLL output
   1228                (MCG_S & MCG_S_IREFST_MASK) &&                                     // check FLL ref is internal ref clk
   1229                (!(MCG_S & MCG_S_PLLST_MASK)))                                     // check PLLS mux has selected FLL
   1230            */
   1231            if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && 	 // check CLKS mux has selcted FLL output
   1232          		  (MCG_S & MCG_S_IREFST_MASK))									 // check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R0,??DataTable17  ;; 0x40064006
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0x0880             LSRS     R0,R0,#+2
   \   0000000A   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000000C   0x0F80             LSRS     R0,R0,#+30
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD105             BNE      ??what_mcg_mode_0
   \   00000012   0x....             LDR      R0,??DataTable17  ;; 0x40064006
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0x06C0             LSLS     R0,R0,#+27
   \   00000018   0xD501             BPL      ??what_mcg_mode_0
   1233          
   1234            {
   1235              return FEI;                                                          // return FEI code
   \   0000001A   0x2003             MOVS     R0,#+3
   \   0000001C   0xE056             B        ??what_mcg_mode_1
   1236            }
   1237            // Check MCG is in PEE mode
   1238            /*
   1239            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) && // check CLKS mux has selcted PLL output
   1240                    (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is external ref clk
   1241                    (MCG_S & MCG_S_PLLST_MASK))                                    // check PLLS mux has selected PLL 
   1242            {
   1243              return PEE;                                                          // return PEE code
   1244            }
   1245            */
   1246            // Check MCG is in PBE mode
   1247            /*
   1248            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
   1249                    (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is external ref clk
   1250                    (MCG_S & MCG_S_PLLST_MASK) &&                                  // check PLLS mux has selected PLL
   1251                    (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is not set
   1252            {
   1253              return PBE;                                                          // return PBE code
   1254            }
   1255            */
   1256          
   1257            // Check MCG is in FBE mode
   1258            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
   1259                    (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is external ref clk
   1260                  //  (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has selected FLL
   1261                    (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check MCG_C2[LP] bit is not set   
   \                     ??what_mcg_mode_0:
   \   0000001E   0x....             LDR      R0,??DataTable17  ;; 0x40064006
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x0880             LSRS     R0,R0,#+2
   \   00000026   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000028   0x0F80             LSRS     R0,R0,#+30
   \   0000002A   0x2802             CMP      R0,#+2
   \   0000002C   0xD109             BNE      ??what_mcg_mode_2
   \   0000002E   0x....             LDR      R0,??DataTable17  ;; 0x40064006
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x06C0             LSLS     R0,R0,#+27
   \   00000034   0xD405             BMI      ??what_mcg_mode_2
   \   00000036   0x....             LDR      R0,??DataTable17_1  ;; 0x40064001
   \   00000038   0x7800             LDRB     R0,[R0, #+0]
   \   0000003A   0x0780             LSLS     R0,R0,#+30
   \   0000003C   0xD401             BMI      ??what_mcg_mode_2
   1262            {
   1263              return FBE;                                                          // return FBE code
   \   0000003E   0x2005             MOVS     R0,#+5
   \   00000040   0xE044             B        ??what_mcg_mode_1
   1264            }
   1265            // Check MCG is in BLPE mode
   1266            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) && // check CLKS mux has selcted external reference
   1267                    (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is external ref clk
   1268                    (MCG_C2 & MCG_C2_LP_MASK))                                     // check MCG_C2[LP] bit is set   
   \                     ??what_mcg_mode_2:
   \   00000042   0x....             LDR      R0,??DataTable17  ;; 0x40064006
   \   00000044   0x7800             LDRB     R0,[R0, #+0]
   \   00000046   0xB2C0             UXTB     R0,R0
   \   00000048   0x0880             LSRS     R0,R0,#+2
   \   0000004A   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000004C   0x0F80             LSRS     R0,R0,#+30
   \   0000004E   0x2802             CMP      R0,#+2
   \   00000050   0xD109             BNE      ??what_mcg_mode_3
   \   00000052   0x....             LDR      R0,??DataTable17  ;; 0x40064006
   \   00000054   0x7800             LDRB     R0,[R0, #+0]
   \   00000056   0x06C0             LSLS     R0,R0,#+27
   \   00000058   0xD405             BMI      ??what_mcg_mode_3
   \   0000005A   0x....             LDR      R0,??DataTable17_1  ;; 0x40064001
   \   0000005C   0x7800             LDRB     R0,[R0, #+0]
   \   0000005E   0x0780             LSLS     R0,R0,#+30
   \   00000060   0xD501             BPL      ??what_mcg_mode_3
   1269            {
   1270              return BLPE;                                                         // return BLPE code
   \   00000062   0x2006             MOVS     R0,#+6
   \   00000064   0xE032             B        ??what_mcg_mode_1
   1271            }
   1272            // check if in BLPI mode
   1273            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
   1274                    (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is internal ref clk
   1275                //    (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has selected FLL
   1276                    (MCG_C2 & MCG_C2_LP_MASK))                                     // check LP bit is set
   \                     ??what_mcg_mode_3:
   \   00000066   0x....             LDR      R0,??DataTable17  ;; 0x40064006
   \   00000068   0x7800             LDRB     R0,[R0, #+0]
   \   0000006A   0xB2C0             UXTB     R0,R0
   \   0000006C   0x0880             LSRS     R0,R0,#+2
   \   0000006E   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000070   0x0F80             LSRS     R0,R0,#+30
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD109             BNE      ??what_mcg_mode_4
   \   00000076   0x....             LDR      R0,??DataTable17  ;; 0x40064006
   \   00000078   0x7800             LDRB     R0,[R0, #+0]
   \   0000007A   0x06C0             LSLS     R0,R0,#+27
   \   0000007C   0xD505             BPL      ??what_mcg_mode_4
   \   0000007E   0x....             LDR      R0,??DataTable17_1  ;; 0x40064001
   \   00000080   0x7800             LDRB     R0,[R0, #+0]
   \   00000082   0x0780             LSLS     R0,R0,#+30
   \   00000084   0xD501             BPL      ??what_mcg_mode_4
   1277            {
   1278              return BLPI;                                                         // return BLPI code
   \   00000086   0x2001             MOVS     R0,#+1
   \   00000088   0xE020             B        ??what_mcg_mode_1
   1279            }
   1280            // check if in FBI mode
   1281            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x1) && // check CLKS mux has selcted int ref clk
   1282                    (MCG_S & MCG_S_IREFST_MASK) &&                                 // check FLL ref is internal ref clk
   1283               //     (!(MCG_S & MCG_S_PLLST_MASK)) &&                               // check PLLS mux has selected FLL
   1284                    (!(MCG_C2 & MCG_C2_LP_MASK)))                                  // check LP bit is clear
   \                     ??what_mcg_mode_4:
   \   0000008A   0x....             LDR      R0,??DataTable17  ;; 0x40064006
   \   0000008C   0x7800             LDRB     R0,[R0, #+0]
   \   0000008E   0xB2C0             UXTB     R0,R0
   \   00000090   0x0880             LSRS     R0,R0,#+2
   \   00000092   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000094   0x0F80             LSRS     R0,R0,#+30
   \   00000096   0x2801             CMP      R0,#+1
   \   00000098   0xD109             BNE      ??what_mcg_mode_5
   \   0000009A   0x....             LDR      R0,??DataTable17  ;; 0x40064006
   \   0000009C   0x7800             LDRB     R0,[R0, #+0]
   \   0000009E   0x06C0             LSLS     R0,R0,#+27
   \   000000A0   0xD505             BPL      ??what_mcg_mode_5
   \   000000A2   0x....             LDR      R0,??DataTable17_1  ;; 0x40064001
   \   000000A4   0x7800             LDRB     R0,[R0, #+0]
   \   000000A6   0x0780             LSLS     R0,R0,#+30
   \   000000A8   0xD401             BMI      ??what_mcg_mode_5
   1285            {  
   1286              return FBI;                                                          // return FBI code 
   \   000000AA   0x2002             MOVS     R0,#+2
   \   000000AC   0xE00E             B        ??what_mcg_mode_1
   1287            }
   1288          
   1289            // Check MCG is in FEE mode
   1290            /*
   1291            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL
   1292                    (!(MCG_S & MCG_S_IREFST_MASK)) &&                              // check FLL ref is external ref clk
   1293                    (!(MCG_S & MCG_S_PLLST_MASK)))                                 // check PLLS mux has selected FLL
   1294            */
   1295            
   1296            else if ((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL
   1297                    (!(MCG_S & MCG_S_IREFST_MASK)))                                 // check PLLS mux has selected FLL
   \                     ??what_mcg_mode_5:
   \   000000AE   0x....             LDR      R0,??DataTable17  ;; 0x40064006
   \   000000B0   0x7800             LDRB     R0,[R0, #+0]
   \   000000B2   0xB2C0             UXTB     R0,R0
   \   000000B4   0x0880             LSRS     R0,R0,#+2
   \   000000B6   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   000000B8   0x0F80             LSRS     R0,R0,#+30
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD105             BNE      ??what_mcg_mode_6
   \   000000BE   0x....             LDR      R0,??DataTable17  ;; 0x40064006
   \   000000C0   0x7800             LDRB     R0,[R0, #+0]
   \   000000C2   0x06C0             LSLS     R0,R0,#+27
   \   000000C4   0xD401             BMI      ??what_mcg_mode_6
   1298            {
   1299              return FEE;                                                          // return FEE code
   \   000000C6   0x2004             MOVS     R0,#+4
   \   000000C8   0xE000             B        ??what_mcg_mode_1
   1300            }
   1301            else
   1302            {
   1303              return 0;                                                            // error condition
   \                     ??what_mcg_mode_6:
   \   000000CA   0x2000             MOVS     R0,#+0
   \                     ??what_mcg_mode_1:
   \   000000CC   0xBD00             POP      {PC}             ;; return
   1304            }
   1305          } // what_mcg_mode
   1306          
   1307          
   1308          /********************************************************************/
   1309          /* Functon name : clk_monitor_0
   1310           *
   1311           * This function simply enables or disables the OSC 0 clock monitor. This is
   1312           * achieved by setting or clearing the MCG_C6[CME] bit. It is recommended to  
   1313           * enable this monitor in external clock modes (FEE, FBE, BLPE, PBE and PEE.
   1314           * It MUST be disabled in all other modes or a reset may be generated. It must
   1315           * also be disabled if it is desired to enter VLPR from BLPE mode.
   1316           *
   1317           * Parameters: en_dis - enables (= 1) or disables (= 0) the OSC 0 clock monitor
   1318           *
   1319           * Return value : none
   1320           */

   \                                 In section .text, align 2, keep-with-next
   1321          void clk_monitor_0(unsigned char en_dis)
   1322          {         
   \                     clk_monitor_0:
   \   00000000   0xB500             PUSH     {LR}
   1323            if (en_dis)
   \   00000002   0xB2C0             UXTB     R0,R0
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD006             BEQ      ??clk_monitor_0_0
   1324            {
   1325            //  MCG_C6 |= MCG_C6_CME0_MASK;   
   1326              MCG_C6 |= MCG_C6_CME0_MASK; 
   \   00000008   0x....             LDR      R0,??DataTable17_2  ;; 0x40064005
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x2120             MOVS     R1,#+32
   \   0000000E   0x4301             ORRS     R1,R1,R0
   \   00000010   0x....             LDR      R0,??DataTable17_2  ;; 0x40064005
   \   00000012   0x7001             STRB     R1,[R0, #+0]
   \   00000014   0xE005             B        ??clk_monitor_0_1
   1327            }
   1328            else
   1329            {
   1330            //  MCG_C6 &= ~MCG_C6_CME0_MASK;
   1331               MCG_C6 &= ~MCG_C6_CME0_MASK;
   \                     ??clk_monitor_0_0:
   \   00000016   0x....             LDR      R0,??DataTable17_2  ;; 0x40064005
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x21DF             MOVS     R1,#+223
   \   0000001C   0x4001             ANDS     R1,R1,R0
   \   0000001E   0x....             LDR      R0,??DataTable17_2  ;; 0x40064005
   \   00000020   0x7001             STRB     R1,[R0, #+0]
   1332            }
   1333          }    // end clk_monitor_0
   \                     ??clk_monitor_0_1:
   \   00000022   0xBD00             POP      {PC}             ;; return
   1334          
   1335          /********************************************************************/
   1336          /* Functon name : fei_fbe
   1337           *
   1338           * Mode transition: FEI to FBE mode
   1339           *
   1340           * This function transitions the MCG from FEI mode to FBE mode. This is
   1341           * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
   1342           * check so 0 is always returned if the function was called with the MCG
   1343           * in FBI mode. The MCGCLKOUT frequency does not change
   1344           *
   1345           * Parameters: crystal_val - external clock frequency in Hz
   1346           *             hgo_val     - selects whether low power or high gain mode is selected
   1347           *                           for the crystal oscillator. This has no meaning if an 
   1348           *                           external clock is used.
   1349           *             erefs_val   - selects external clock (=0) or crystal osc (=1)
   1350           *
   1351           * Return value : MCGCLKOUT frequency (Hz) or error code
   1352           */

   \                                 In section .text, align 2, keep-with-next
   1353          int fei_fbe(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
   1354          {
   \                     fei_fbe:
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   1355            unsigned char frdiv_val;
   1356            unsigned char temp_reg;
   1357            short i;
   1358            
   1359          // check if in FEI mode
   1360          /*
   1361            if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
   1362                (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
   1363                (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
   1364          */
   1365          	if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
   1366          		(MCG_S & MCG_S_IREFST_MASK))) 								// check PLLS mux has selected FLL
   \   00000002   0x....             LDR      R3,??DataTable17  ;; 0x40064006
   \   00000004   0x781B             LDRB     R3,[R3, #+0]
   \   00000006   0xB2DB             UXTB     R3,R3
   \   00000008   0x089B             LSRS     R3,R3,#+2
   \   0000000A   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   0000000C   0x0F9B             LSRS     R3,R3,#+30
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD103             BNE      ??fei_fbe_0
   \   00000012   0x....             LDR      R3,??DataTable17  ;; 0x40064006
   \   00000014   0x781B             LDRB     R3,[R3, #+0]
   \   00000016   0x06DB             LSLS     R3,R3,#+27
   \   00000018   0xD401             BMI      ??fei_fbe_1
   1367          
   1368          {
   1369              return 0x1;                                                     // return error code
   \                     ??fei_fbe_0:
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xE097             B        ??fei_fbe_2
   1370            }
   1371          
   1372          // check external frequency is less than the maximum frequency
   1373            if  (crystal_val > 50000000) {return 0x21;}
   \                     ??fei_fbe_1:
   \   0000001E   0x....             LDR      R3,??DataTable17_3  ;; 0x2faf081
   \   00000020   0x4298             CMP      R0,R3
   \   00000022   0xDB01             BLT      ??fei_fbe_3
   \   00000024   0x2021             MOVS     R0,#+33
   \   00000026   0xE092             B        ??fei_fbe_2
   1374            
   1375          // check crystal frequency is within spec. if crystal osc is being used
   1376            if (erefs_val)
   \                     ??fei_fbe_3:
   \   00000028   0xB2D2             UXTB     R2,R2
   \   0000002A   0x2A00             CMP      R2,#+0
   \   0000002C   0xD00C             BEQ      ??fei_fbe_4
   1377            {
   1378              if ((crystal_val < 30000) ||
   1379                  ((crystal_val > 40000) && (crystal_val < 3000000)) ||
   1380                  (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal options is not available
   \   0000002E   0x....             LDR      R3,??DataTable17_4  ;; 0x7530
   \   00000030   0x4298             CMP      R0,R3
   \   00000032   0xDB07             BLT      ??fei_fbe_5
   \   00000034   0x....             LDR      R3,??DataTable17_5  ;; 0x9c41
   \   00000036   0x1AC3             SUBS     R3,R0,R3
   \   00000038   0x....             LDR      R4,??DataTable17_6  ;; 0x2d2a7f
   \   0000003A   0x42A3             CMP      R3,R4
   \   0000003C   0xD302             BCC      ??fei_fbe_5
   \   0000003E   0x....             LDR      R3,??DataTable17_7  ;; 0x1e84801
   \   00000040   0x4298             CMP      R0,R3
   \   00000042   0xDB01             BLT      ??fei_fbe_4
   \                     ??fei_fbe_5:
   \   00000044   0x2022             MOVS     R0,#+34
   \   00000046   0xE082             B        ??fei_fbe_2
   1381            }
   1382          
   1383          // make sure HGO will never be greater than 1. Could return an error instead if desired.  
   1384            if (hgo_val > 0)
   \                     ??fei_fbe_4:
   \   00000048   0xB2C9             UXTB     R1,R1
   \   0000004A   0x2901             CMP      R1,#+1
   \   0000004C   0xD300             BCC      ??fei_fbe_6
   1385            {
   1386              hgo_val = 1; // force hgo_val to 1 if > 0
   \   0000004E   0x2101             MOVS     R1,#+1
   1387            }
   1388          
   1389          // configure the MCG_C2 register
   1390          // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
   1391          // it still needs to be set correctly even if the oscillator is not being used
   1392            temp_reg = MCG_C2;
   \                     ??fei_fbe_6:
   \   00000050   0x....             LDR      R3,??DataTable17_1  ;; 0x40064001
   \   00000052   0x781B             LDRB     R3,[R3, #+0]
   1393            temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
   \   00000054   0x001C             MOVS     R4,R3
   \   00000056   0x23C3             MOVS     R3,#+195
   \   00000058   0x4023             ANDS     R3,R3,R4
   1394            if (crystal_val <= 40000)
   \   0000005A   0x....             LDR      R4,??DataTable17_5  ;; 0x9c41
   \   0000005C   0x42A0             CMP      R0,R4
   \   0000005E   0xDA07             BGE      ??fei_fbe_7
   1395            {
   1396              temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   00000060   0x001C             MOVS     R4,R3
   \   00000062   0xB2C9             UXTB     R1,R1
   \   00000064   0x00C9             LSLS     R1,R1,#+3
   \   00000066   0xB2D2             UXTB     R2,R2
   \   00000068   0x0093             LSLS     R3,R2,#+2
   \   0000006A   0x430B             ORRS     R3,R3,R1
   \   0000006C   0x4323             ORRS     R3,R3,R4
   \   0000006E   0xE015             B        ??fei_fbe_8
   1397            }
   1398            else if (crystal_val <= 8000000)
   \                     ??fei_fbe_7:
   \   00000070   0x....             LDR      R4,??DataTable17_8  ;; 0x7a1201
   \   00000072   0x42A0             CMP      R0,R4
   \   00000074   0xDA09             BGE      ??fei_fbe_9
   1399            {
   1400              temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   00000076   0x001D             MOVS     R5,R3
   \   00000078   0xB2C9             UXTB     R1,R1
   \   0000007A   0x00C9             LSLS     R1,R1,#+3
   \   0000007C   0xB2D2             UXTB     R2,R2
   \   0000007E   0x0094             LSLS     R4,R2,#+2
   \   00000080   0x430C             ORRS     R4,R4,R1
   \   00000082   0x2310             MOVS     R3,#+16
   \   00000084   0x4323             ORRS     R3,R3,R4
   \   00000086   0x432B             ORRS     R3,R3,R5
   \   00000088   0xE008             B        ??fei_fbe_8
   1401            }
   1402            else
   1403            {
   1404              temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \                     ??fei_fbe_9:
   \   0000008A   0x001D             MOVS     R5,R3
   \   0000008C   0xB2C9             UXTB     R1,R1
   \   0000008E   0x00C9             LSLS     R1,R1,#+3
   \   00000090   0xB2D2             UXTB     R2,R2
   \   00000092   0x0094             LSLS     R4,R2,#+2
   \   00000094   0x430C             ORRS     R4,R4,R1
   \   00000096   0x2320             MOVS     R3,#+32
   \   00000098   0x4323             ORRS     R3,R3,R4
   \   0000009A   0x432B             ORRS     R3,R3,R5
   1405            }
   1406            MCG_C2 = temp_reg;
   \                     ??fei_fbe_8:
   \   0000009C   0x....             LDR      R1,??DataTable17_1  ;; 0x40064001
   \   0000009E   0x700B             STRB     R3,[R1, #+0]
   1407          // determine FRDIV based on reference clock frequency
   1408          // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
   1409            if (crystal_val <= 1250000) {frdiv_val = 0;}
   \   000000A0   0x....             LDR      R1,??DataTable18  ;; 0x1312d1
   \   000000A2   0x4288             CMP      R0,R1
   \   000000A4   0xDA01             BGE      ??fei_fbe_10
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0xE014             B        ??fei_fbe_11
   1410            else if (crystal_val <= 2500000) {frdiv_val = 1;}
   \                     ??fei_fbe_10:
   \   000000AA   0x....             LDR      R1,??DataTable18_1  ;; 0x2625a1
   \   000000AC   0x4288             CMP      R0,R1
   \   000000AE   0xDA01             BGE      ??fei_fbe_12
   \   000000B0   0x2101             MOVS     R1,#+1
   \   000000B2   0xE00F             B        ??fei_fbe_11
   1411            else if (crystal_val <= 5000000) {frdiv_val = 2;}
   \                     ??fei_fbe_12:
   \   000000B4   0x....             LDR      R1,??DataTable18_2  ;; 0x4c4b41
   \   000000B6   0x4288             CMP      R0,R1
   \   000000B8   0xDA01             BGE      ??fei_fbe_13
   \   000000BA   0x2102             MOVS     R1,#+2
   \   000000BC   0xE00A             B        ??fei_fbe_11
   1412            else if (crystal_val <= 10000000) {frdiv_val = 3;}
   \                     ??fei_fbe_13:
   \   000000BE   0x....             LDR      R1,??DataTable18_3  ;; 0x989681
   \   000000C0   0x4288             CMP      R0,R1
   \   000000C2   0xDA01             BGE      ??fei_fbe_14
   \   000000C4   0x2103             MOVS     R1,#+3
   \   000000C6   0xE005             B        ??fei_fbe_11
   1413            else if (crystal_val <= 20000000) {frdiv_val = 4;}
   \                     ??fei_fbe_14:
   \   000000C8   0x....             LDR      R1,??DataTable18_4  ;; 0x1312d01
   \   000000CA   0x4288             CMP      R0,R1
   \   000000CC   0xDA01             BGE      ??fei_fbe_15
   \   000000CE   0x2104             MOVS     R1,#+4
   \   000000D0   0xE000             B        ??fei_fbe_11
   1414            else {frdiv_val = 5;}
   \                     ??fei_fbe_15:
   \   000000D2   0x2105             MOVS     R1,#+5
   1415            
   1416          // Select external oscilator and Reference Divider and clear IREFS to start ext osc
   1417          // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
   1418          // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
   1419            temp_reg = MCG_C1;
   \                     ??fei_fbe_11:
   \   000000D4   0x....             LDR      R3,??DataTable18_5  ;; 0x40064000
   \   000000D6   0x781B             LDRB     R3,[R3, #+0]
   1420            temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these fields
   \   000000D8   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   000000DA   0x0F9B             LSRS     R3,R3,#+30
   1421            temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
   \   000000DC   0x001D             MOVS     R5,R3
   \   000000DE   0x00C9             LSLS     R1,R1,#+3
   \   000000E0   0x2438             MOVS     R4,#+56
   \   000000E2   0x400C             ANDS     R4,R4,R1
   \   000000E4   0x2380             MOVS     R3,#+128
   \   000000E6   0x4323             ORRS     R3,R3,R4
   \   000000E8   0x432B             ORRS     R3,R3,R5
   1422            MCG_C1 = temp_reg;
   \   000000EA   0x....             LDR      R1,??DataTable18_5  ;; 0x40064000
   \   000000EC   0x700B             STRB     R3,[R1, #+0]
   1423          
   1424          // if the external oscillator is used need to wait for OSCINIT to set
   1425            if (erefs_val)
   \   000000EE   0xB2D2             UXTB     R2,R2
   \   000000F0   0x2A00             CMP      R2,#+0
   \   000000F2   0xD00A             BEQ      ??fei_fbe_16
   1426            {
   1427              for (i = 0 ; i < 10000 ; i++)
   \   000000F4   0x2100             MOVS     R1,#+0
   \   000000F6   0xE000             B        ??fei_fbe_17
   \                     ??fei_fbe_18:
   \   000000F8   0x1C49             ADDS     R1,R1,#+1
   \                     ??fei_fbe_17:
   \   000000FA   0x....             LDR      R2,??DataTable18_6  ;; 0x2710
   \   000000FC   0xB209             SXTH     R1,R1
   \   000000FE   0x4291             CMP      R1,R2
   \   00000100   0xDA03             BGE      ??fei_fbe_16
   1428              {
   1429                if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
   \   00000102   0x....             LDR      R2,??DataTable17  ;; 0x40064006
   \   00000104   0x7812             LDRB     R2,[R2, #+0]
   \   00000106   0x0792             LSLS     R2,R2,#+30
   \   00000108   0xD5F6             BPL      ??fei_fbe_18
   1430              }
   1431              //if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
   1432            }
   1433          
   1434          // wait for Reference clock Status bit to clear
   1435            for (i = 0 ; i < 2000 ; i++)
   \                     ??fei_fbe_16:
   \   0000010A   0x2100             MOVS     R1,#+0
   \   0000010C   0xE000             B        ??fei_fbe_19
   \                     ??fei_fbe_20:
   \   0000010E   0x1C49             ADDS     R1,R1,#+1
   \                     ??fei_fbe_19:
   \   00000110   0x22FA             MOVS     R2,#+250
   \   00000112   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   00000114   0xB209             SXTH     R1,R1
   \   00000116   0x4291             CMP      R1,R2
   \   00000118   0xDA03             BGE      ??fei_fbe_21
   1436            {
   1437              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   \   0000011A   0x....             LDR      R2,??DataTable17  ;; 0x40064006
   \   0000011C   0x7812             LDRB     R2,[R2, #+0]
   \   0000011E   0x06D2             LSLS     R2,R2,#+27
   \   00000120   0xD4F5             BMI      ??fei_fbe_20
   1438            }
   1439            //if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
   1440            
   1441          // Wait for clock status bits to show clock source is ext ref clk
   1442            for (i = 0 ; i < 2000 ; i++)
   \                     ??fei_fbe_21:
   \   00000122   0x2100             MOVS     R1,#+0
   \   00000124   0xE000             B        ??fei_fbe_22
   \                     ??fei_fbe_23:
   \   00000126   0x1C49             ADDS     R1,R1,#+1
   \                     ??fei_fbe_22:
   \   00000128   0x22FA             MOVS     R2,#+250
   \   0000012A   0x00D2             LSLS     R2,R2,#+3        ;; #+2000
   \   0000012C   0xB209             SXTH     R1,R1
   \   0000012E   0x4291             CMP      R1,R2
   \   00000130   0xDA07             BGE      ??fei_fbe_24
   1443            {
   1444              if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
   \   00000132   0x....             LDR      R2,??DataTable17  ;; 0x40064006
   \   00000134   0x7812             LDRB     R2,[R2, #+0]
   \   00000136   0xB2D2             UXTB     R2,R2
   \   00000138   0x0892             LSRS     R2,R2,#+2
   \   0000013A   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   0000013C   0x0F92             LSRS     R2,R2,#+30
   \   0000013E   0x2A02             CMP      R2,#+2
   \   00000140   0xD1F1             BNE      ??fei_fbe_23
   1445            }
   1446            //if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
   1447           
   1448          // Now in FBE  
   1449          // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
   1450          // It is enabled here but can be removed if this is not required.
   1451           // MCG_C6 |= MCG_C6_CME0_MASK;
   1452            MCG_C6 |= MCG_C6_CME0_MASK;
   \                     ??fei_fbe_24:
   \   00000142   0x....             LDR      R1,??DataTable17_2  ;; 0x40064005
   \   00000144   0x7809             LDRB     R1,[R1, #+0]
   \   00000146   0x2220             MOVS     R2,#+32
   \   00000148   0x430A             ORRS     R2,R2,R1
   \   0000014A   0x....             LDR      R1,??DataTable17_2  ;; 0x40064005
   \   0000014C   0x700A             STRB     R2,[R1, #+0]
   1453            
   1454            return crystal_val; // MCGOUT frequency equals external clock frequency
   \                     ??fei_fbe_2:
   \   0000014E   0xBD30             POP      {R4,R5,PC}       ;; return
   1455          } // fei_fbe
   1456          
   1457          
   1458          /********************************************************************/
   1459          /* Functon name : fei_fee
   1460           *
   1461           * Mode transition: FEI to FEE mode
   1462           *
   1463           * This function transitions the MCG from FEI mode to FEE mode. This is
   1464           * achieved by setting the MCG_C2[LP] bit. There is no status bit to 
   1465           * check so 0 is always returned if the function was called with the MCG
   1466           * in FBI mode. The MCGCLKOUT frequency does not change
   1467           *
   1468           * Parameters: crystal_val - external clock frequency in Hz
   1469           *             hgo_val     - selects whether low power or high gain mode is selected
   1470           *                           for the crystal oscillator. This has no meaning if an 
   1471           *                           external clock is used.
   1472           *             erefs_val   - selects external clock (=0) or crystal osc (=1)
   1473           *
   1474           * Return value : MCGCLKOUT frequency (Hz) or error code
   1475           */

   \                                 In section .text, align 2, keep-with-next
   1476          int fei_fee(int crystal_val, unsigned char hgo_val, unsigned char erefs_val)
   1477          {
   \                     fei_fee:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0005             MOVS     R5,R0
   1478            unsigned char frdiv_val;
   1479            unsigned char temp_reg;
   1480           // short i;
   1481            int mcg_out, fll_ref_freq, i;
   1482            
   1483          // check if in FEI mode
   1484          
   1485          	if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
   1486          		(MCG_S & MCG_S_IREFST_MASK))) 								// check PLLS mux has selected FLL
   \   00000004   0x....             LDR      R0,??DataTable18_7  ;; 0x40064006
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xB2C0             UXTB     R0,R0
   \   0000000A   0x0880             LSRS     R0,R0,#+2
   \   0000000C   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   0000000E   0x0F80             LSRS     R0,R0,#+30
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD103             BNE      ??fei_fee_0
   \   00000014   0x....             LDR      R0,??DataTable18_7  ;; 0x40064006
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x06C0             LSLS     R0,R0,#+27
   \   0000001A   0xD401             BMI      ??fei_fee_1
   1487          
   1488              {
   1489                  return 0x1;                                                     // return error code
   \                     ??fei_fee_0:
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xE0AF             B        ??fei_fee_2
   1490              }
   1491          
   1492          // check external frequency is less than the maximum frequency
   1493            if  (crystal_val > 50000000) {return 0x21;}
   \                     ??fei_fee_1:
   \   00000020   0x....             LDR      R0,??fll_freq_0  ;; 0x2faf081
   \   00000022   0x4285             CMP      R5,R0
   \   00000024   0xDB01             BLT      ??fei_fee_3
   \   00000026   0x2021             MOVS     R0,#+33
   \   00000028   0xE0AA             B        ??fei_fee_2
   1494            
   1495           //check crystal frequency is within spec. if crystal osc is being used
   1496            if (erefs_val)
   \                     ??fei_fee_3:
   \   0000002A   0xB2D2             UXTB     R2,R2
   \   0000002C   0x2A00             CMP      R2,#+0
   \   0000002E   0xD009             BEQ      ??fei_fee_4
   1497            {
   1498            if (
   1499                 ((crystal_val > 40000) && (crystal_val < 3000000)) ||
   1500                (crystal_val > 32000000)) {return 0x22;} // return error if one of the available crystal options is not available
   \   00000030   0x....             LDR      R0,??DataTable18_8  ;; 0x9c41
   \   00000032   0x1A28             SUBS     R0,R5,R0
   \   00000034   0x....             LDR      R3,??DataTable18_9  ;; 0x2d2a7f
   \   00000036   0x4298             CMP      R0,R3
   \   00000038   0xD302             BCC      ??fei_fee_5
   \   0000003A   0x....             LDR      R0,??DataTable18_10  ;; 0x1e84801
   \   0000003C   0x4285             CMP      R5,R0
   \   0000003E   0xDB01             BLT      ??fei_fee_4
   \                     ??fei_fee_5:
   \   00000040   0x2022             MOVS     R0,#+34
   \   00000042   0xE09D             B        ??fei_fee_2
   1501            }
   1502          
   1503          // make sure HGO will never be greater than 1. Could return an error instead if desired.  
   1504            if (hgo_val > 0)
   \                     ??fei_fee_4:
   \   00000044   0xB2C9             UXTB     R1,R1
   \   00000046   0x2901             CMP      R1,#+1
   \   00000048   0xD300             BCC      ??fei_fee_6
   1505            {
   1506              hgo_val = 1; // force hgo_val to 1 if > 0
   \   0000004A   0x2101             MOVS     R1,#+1
   1507            }
   1508          
   1509            OSC0_CR = OSC_CR_ERCLKEN_MASK
   1510          	  |OSC_CR_EREFSTEN_MASK
   1511          	  |OSC_CR_SC16P_MASK;
   \                     ??fei_fee_6:
   \   0000004C   0x....             LDR      R0,??DataTable18_11  ;; 0x40065000
   \   0000004E   0x23A1             MOVS     R3,#+161
   \   00000050   0x7003             STRB     R3,[R0, #+0]
   1512          
   1513          // configure the MCG_C2 register
   1514          // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
   1515          // it still needs to be set correctly even if the oscillator is not being used
   1516            temp_reg = MCG_C2;
   \   00000052   0x....             LDR      R0,??DataTable18_12  ;; 0x40064001
   \   00000054   0x7803             LDRB     R3,[R0, #+0]
   1517            temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
   \   00000056   0x0018             MOVS     R0,R3
   \   00000058   0x23C3             MOVS     R3,#+195
   \   0000005A   0x4003             ANDS     R3,R3,R0
   1518            if (crystal_val <= 40000)
   \   0000005C   0x....             LDR      R0,??DataTable18_8  ;; 0x9c41
   \   0000005E   0x4285             CMP      R5,R0
   \   00000060   0xDA07             BGE      ??fei_fee_7
   1519            {
   1520              temp_reg |= (MCG_C2_RANGE0(0) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   00000062   0x001C             MOVS     R4,R3
   \   00000064   0xB2C9             UXTB     R1,R1
   \   00000066   0x00C8             LSLS     R0,R1,#+3
   \   00000068   0xB2D2             UXTB     R2,R2
   \   0000006A   0x0093             LSLS     R3,R2,#+2
   \   0000006C   0x4303             ORRS     R3,R3,R0
   \   0000006E   0x4323             ORRS     R3,R3,R4
   \   00000070   0xE015             B        ??fei_fee_8
   1521            }
   1522            else if (crystal_val <= 8000000)
   \                     ??fei_fee_7:
   \   00000072   0x....             LDR      R0,??DataTable18_13  ;; 0x7a1201
   \   00000074   0x4285             CMP      R5,R0
   \   00000076   0xDA09             BGE      ??fei_fee_9
   1523            {
   1524              temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \   00000078   0x001C             MOVS     R4,R3
   \   0000007A   0xB2C9             UXTB     R1,R1
   \   0000007C   0x00C8             LSLS     R0,R1,#+3
   \   0000007E   0xB2D2             UXTB     R2,R2
   \   00000080   0x0091             LSLS     R1,R2,#+2
   \   00000082   0x4301             ORRS     R1,R1,R0
   \   00000084   0x2310             MOVS     R3,#+16
   \   00000086   0x430B             ORRS     R3,R3,R1
   \   00000088   0x4323             ORRS     R3,R3,R4
   \   0000008A   0xE008             B        ??fei_fee_8
   1525            }
   1526            else
   1527            {
   1528              temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
   \                     ??fei_fee_9:
   \   0000008C   0x001C             MOVS     R4,R3
   \   0000008E   0xB2C9             UXTB     R1,R1
   \   00000090   0x00C8             LSLS     R0,R1,#+3
   \   00000092   0xB2D2             UXTB     R2,R2
   \   00000094   0x0091             LSLS     R1,R2,#+2
   \   00000096   0x4301             ORRS     R1,R1,R0
   \   00000098   0x2320             MOVS     R3,#+32
   \   0000009A   0x430B             ORRS     R3,R3,R1
   \   0000009C   0x4323             ORRS     R3,R3,R4
   1529            }
   1530            MCG_C2 = temp_reg;
   \                     ??fei_fee_8:
   \   0000009E   0x....             LDR      R0,??DataTable18_12  ;; 0x40064001
   \   000000A0   0x7003             STRB     R3,[R0, #+0]
   1531            // if the external oscillator is used need to wait for OSCINIT to set
   1532             if (erefs_val)
   \   000000A2   0xB2D2             UXTB     R2,R2
   \   000000A4   0x2A00             CMP      R2,#+0
   \   000000A6   0xD00F             BEQ      ??fei_fee_10
   1533            {
   1534          	for (i = 0 ; i < 20000000 ; i++)
   \   000000A8   0x2100             MOVS     R1,#+0
   \   000000AA   0xE000             B        ??fei_fee_11
   \                     ??fei_fee_12:
   \   000000AC   0x1C49             ADDS     R1,R1,#+1
   \                     ??fei_fee_11:
   \   000000AE   0x....             LDR      R0,??DataTable19  ;; 0x1312d00
   \   000000B0   0x4281             CMP      R1,R0
   \   000000B2   0xDA03             BGE      ??fei_fee_13
   1535          	{
   1536          	  if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
   \   000000B4   0x....             LDR      R0,??DataTable18_7  ;; 0x40064006
   \   000000B6   0x7800             LDRB     R0,[R0, #+0]
   \   000000B8   0x0780             LSLS     R0,R0,#+30
   \   000000BA   0xD5F7             BPL      ??fei_fee_12
   1537          	}
   1538          	if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
   \                     ??fei_fee_13:
   \   000000BC   0x....             LDR      R0,??DataTable18_7  ;; 0x40064006
   \   000000BE   0x7800             LDRB     R0,[R0, #+0]
   \   000000C0   0x0780             LSLS     R0,R0,#+30
   \   000000C2   0xD401             BMI      ??fei_fee_10
   \   000000C4   0x2023             MOVS     R0,#+35
   \   000000C6   0xE05B             B        ??fei_fee_2
   1539            }
   1540          
   1541          // determine FRDIV based on reference clock frequency
   1542          // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
   1543            if (crystal_val <= 1250000) {frdiv_val = 0;}
   \                     ??fei_fee_10:
   \   000000C8   0x....             LDR      R0,??DataTable18  ;; 0x1312d1
   \   000000CA   0x4285             CMP      R5,R0
   \   000000CC   0xDA01             BGE      ??fei_fee_14
   \   000000CE   0x2400             MOVS     R4,#+0
   \   000000D0   0xE014             B        ??fei_fee_15
   1544            else if (crystal_val <= 2500000) {frdiv_val = 1;}
   \                     ??fei_fee_14:
   \   000000D2   0x....             LDR      R0,??DataTable18_1  ;; 0x2625a1
   \   000000D4   0x4285             CMP      R5,R0
   \   000000D6   0xDA01             BGE      ??fei_fee_16
   \   000000D8   0x2401             MOVS     R4,#+1
   \   000000DA   0xE00F             B        ??fei_fee_15
   1545            else if (crystal_val <= 5000000) {frdiv_val = 2;}
   \                     ??fei_fee_16:
   \   000000DC   0x....             LDR      R0,??DataTable18_2  ;; 0x4c4b41
   \   000000DE   0x4285             CMP      R5,R0
   \   000000E0   0xDA01             BGE      ??fei_fee_17
   \   000000E2   0x2402             MOVS     R4,#+2
   \   000000E4   0xE00A             B        ??fei_fee_15
   1546            else if (crystal_val <= 10000000) {frdiv_val = 3;}
   \                     ??fei_fee_17:
   \   000000E6   0x....             LDR      R0,??DataTable18_3  ;; 0x989681
   \   000000E8   0x4285             CMP      R5,R0
   \   000000EA   0xDA01             BGE      ??fei_fee_18
   \   000000EC   0x2403             MOVS     R4,#+3
   \   000000EE   0xE005             B        ??fei_fee_15
   1547            else if (crystal_val <= 20000000) {frdiv_val = 4;}
   \                     ??fei_fee_18:
   \   000000F0   0x....             LDR      R0,??DataTable18_4  ;; 0x1312d01
   \   000000F2   0x4285             CMP      R5,R0
   \   000000F4   0xDA01             BGE      ??fei_fee_19
   \   000000F6   0x2404             MOVS     R4,#+4
   \   000000F8   0xE000             B        ??fei_fee_15
   1548            else {frdiv_val = 5;}
   \                     ??fei_fee_19:
   \   000000FA   0x2405             MOVS     R4,#+5
   1549             
   1550            // The FLL ref clk divide value depends on FRDIV and the RANGE value
   1551            if (((MCG_C2 & MCG_C2_RANGE0_MASK) >> MCG_C2_RANGE0_SHIFT) > 0)
   \                     ??fei_fee_15:
   \   000000FC   0x....             LDR      R0,??DataTable18_12  ;; 0x40064001
   \   000000FE   0x7800             LDRB     R0,[R0, #+0]
   \   00000100   0xB2C0             UXTB     R0,R0
   \   00000102   0x0900             LSRS     R0,R0,#+4
   \   00000104   0x0780             LSLS     R0,R0,#+30       ;; ZeroExtS R0,R0,#+30,#+30
   \   00000106   0x0F80             LSRS     R0,R0,#+30
   \   00000108   0x2800             CMP      R0,#+0
   \   0000010A   0xD005             BEQ      ??fei_fee_20
   1552            {
   1553              fll_ref_freq = ((crystal_val) / (32 << frdiv_val));
   \   0000010C   0x0028             MOVS     R0,R5
   \   0000010E   0x2120             MOVS     R1,#+32
   \   00000110   0x40A1             LSLS     R1,R1,R4
   \   00000112   0x.... 0x....      BL       __aeabi_idiv
   \   00000116   0xE004             B        ??fei_fee_21
   1554            }
   1555            else
   1556            {
   1557              fll_ref_freq = ((crystal_val) / (1 << frdiv_val));
   \                     ??fei_fee_20:
   \   00000118   0x0028             MOVS     R0,R5
   \   0000011A   0x2101             MOVS     R1,#+1
   \   0000011C   0x40A1             LSLS     R1,R1,R4
   \   0000011E   0x.... 0x....      BL       __aeabi_idiv
   1558            }
   1559             if( crystal_val == 32768 )
   \                     ??fei_fee_21:
   \   00000122   0x2180             MOVS     R1,#+128
   \   00000124   0x0209             LSLS     R1,R1,#+8        ;; #+32768
   \   00000126   0x428D             CMP      R5,R1
   \   00000128   0xD105             BNE      ??fei_fee_22
   1560             {
   1561                MCG_C4 |= MCG_C4_DMX32_MASK | MCG_C4_DRST_DRS(1);
   \   0000012A   0x....             LDR      R1,??DataTable19_1  ;; 0x40064003
   \   0000012C   0x7809             LDRB     R1,[R1, #+0]
   \   0000012E   0x22A0             MOVS     R2,#+160
   \   00000130   0x430A             ORRS     R2,R2,R1
   \   00000132   0x....             LDR      R1,??DataTable19_1  ;; 0x40064003
   \   00000134   0x700A             STRB     R2,[R1, #+0]
   1562             }
   1563            
   1564          // Check resulting FLL frequency 
   1565            mcg_out = fll_freq(fll_ref_freq); // FLL reference frequency calculated from ext ref freq and FRDIV
   \                     ??fei_fee_22:
   \   00000136   0x.... 0x....      BL       fll_freq
   1566            if (mcg_out < 0x5B) {return mcg_out;} // If error code returned, return the code to calling function
   \   0000013A   0x285B             CMP      R0,#+91
   \   0000013C   0xDB20             BLT      ??fei_fee_2
   1567            
   1568          // Select external oscilator and Reference Divider and clear IREFS to start ext osc
   1569          // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
   1570          // CLKS=0, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
   1571            temp_reg = MCG_C1;
   \                     ??fei_fee_23:
   \   0000013E   0x....             LDR      R1,??DataTable18_5  ;; 0x40064000
   \   00000140   0x780B             LDRB     R3,[R1, #+0]
   1572            temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these fields
   \   00000142   0x079B             LSLS     R3,R3,#+30       ;; ZeroExtS R3,R3,#+30,#+30
   \   00000144   0x0F9B             LSRS     R3,R3,#+30
   1573            temp_reg |= (MCG_C1_CLKS(0) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
   \   00000146   0x001A             MOVS     R2,R3
   \   00000148   0x00E1             LSLS     R1,R4,#+3
   \   0000014A   0x2338             MOVS     R3,#+56
   \   0000014C   0x400B             ANDS     R3,R3,R1
   \   0000014E   0x4313             ORRS     R3,R3,R2
   1574            MCG_C1 = temp_reg;
   \   00000150   0x....             LDR      R1,??DataTable18_5  ;; 0x40064000
   \   00000152   0x700B             STRB     R3,[R1, #+0]
   1575          
   1576          // wait for Reference clock Status bit to clear
   1577            for (i = 0 ; i < 20000 ; i++)
   \   00000154   0x2100             MOVS     R1,#+0
   \   00000156   0xE000             B        ??fei_fee_24
   \                     ??fei_fee_25:
   \   00000158   0x1C49             ADDS     R1,R1,#+1
   \                     ??fei_fee_24:
   \   0000015A   0x....             LDR      R2,??DataTable19_2  ;; 0x4e20
   \   0000015C   0x4291             CMP      R1,R2
   \   0000015E   0xDA03             BGE      ??fei_fee_26
   1578            {
   1579              if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
   \   00000160   0x....             LDR      R2,??DataTable18_7  ;; 0x40064006
   \   00000162   0x7812             LDRB     R2,[R2, #+0]
   \   00000164   0x06D2             LSLS     R2,R2,#+27
   \   00000166   0xD4F7             BMI      ??fei_fee_25
   1580            }
   1581            if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
   \                     ??fei_fee_26:
   \   00000168   0x....             LDR      R1,??DataTable18_7  ;; 0x40064006
   \   0000016A   0x7809             LDRB     R1,[R1, #+0]
   \   0000016C   0x06C9             LSLS     R1,R1,#+27
   \   0000016E   0xD501             BPL      ??fei_fee_27
   \   00000170   0x2011             MOVS     R0,#+17
   \   00000172   0xE005             B        ??fei_fee_2
   1582            
   1583          // Now in FBE  
   1584          // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
   1585          // It is enabled here but can be removed if this is not required.
   1586            MCG_C6 |= MCG_C6_CME0_MASK;
   \                     ??fei_fee_27:
   \   00000174   0x....             LDR      R1,??DataTable19_3  ;; 0x40064005
   \   00000176   0x7809             LDRB     R1,[R1, #+0]
   \   00000178   0x2220             MOVS     R2,#+32
   \   0000017A   0x430A             ORRS     R2,R2,R1
   \   0000017C   0x....             LDR      R1,??DataTable19_3  ;; 0x40064005
   \   0000017E   0x700A             STRB     R2,[R1, #+0]
   1587            
   1588            return mcg_out; // MCGOUT frequency equals FLL frequency
   \                     ??fei_fee_2:
   \   00000180   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1589          } // fei_fee
   1590          

   \                                 In section .text, align 4, keep-with-next
   1591          int fll_freq(int fll_ref)
   1592          {
   \                     fll_freq:
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0x0001             MOVS     R1,R0
   1593            int fll_freq_hz;
   1594            
   1595            if (MCG_C4 & MCG_C4_DMX32_MASK) // if DMX32 set
   \   00000004   0x....             LDR      R2,??DataTable19_1  ;; 0x40064003
   \   00000006   0x7812             LDRB     R2,[R2, #+0]
   \   00000008   0x0612             LSLS     R2,R2,#+24
   \   0000000A   0xD547             BPL      ??fll_freq_1
   1596            {
   1597              switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based on DRS
   \   0000000C   0x....             LDR      R2,??DataTable19_1  ;; 0x40064003
   \   0000000E   0x7812             LDRB     R2,[R2, #+0]
   \   00000010   0xB2D2             UXTB     R2,R2
   \   00000012   0x0952             LSRS     R2,R2,#+5
   \   00000014   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   00000016   0x0F92             LSRS     R2,R2,#+30
   \   00000018   0x2A00             CMP      R2,#+0
   \   0000001A   0xD005             BEQ      ??fll_freq_2
   \   0000001C   0x2A02             CMP      R2,#+2
   \   0000001E   0xD021             BEQ      ??fll_freq_3
   \   00000020   0xD311             BCC      ??fll_freq_4
   \   00000022   0x2A03             CMP      R2,#+3
   \   00000024   0xD02C             BEQ      ??fll_freq_5
   \   00000026   0xE084             B        ??fll_freq_6
   1598              {
   1599              case 0:
   1600                fll_freq_hz = (fll_ref * 732);
   \                     ??fll_freq_2:
   \   00000028   0x20B7             MOVS     R0,#+183
   \   0000002A   0x0080             LSLS     R0,R0,#+2        ;; #+732
   \   0000002C   0x4341             MULS     R1,R0,R1
   \   0000002E   0x0008             MOVS     R0,R1
   1601                if (fll_freq_hz < 20000000) {return 0x33;}
   \   00000030   0x....             LDR      R1,??DataTable19  ;; 0x1312d00
   \   00000032   0x4288             CMP      R0,R1
   \   00000034   0xDA01             BGE      ??fll_freq_7
   \   00000036   0x2033             MOVS     R0,#+51
   \   00000038   0xE07B             B        ??fll_freq_8
   1602                else if (fll_freq_hz > 25000000) {return 0x34;}
   \                     ??fll_freq_7:
   \   0000003A   0x....             LDR      R1,??DataTable19_4  ;; 0x17d7841
   \   0000003C   0x4288             CMP      R0,R1
   \   0000003E   0xDB01             BLT      ??fll_freq_9
   \   00000040   0x2034             MOVS     R0,#+52
   \   00000042   0xE076             B        ??fll_freq_8
   1603                break;
   \                     ??fll_freq_9:
   \   00000044   0xE075             B        ??fll_freq_6
   1604              case 1:
   1605                fll_freq_hz = (fll_ref * 1464);
   \                     ??fll_freq_4:
   \   00000046   0x20B7             MOVS     R0,#+183
   \   00000048   0x00C0             LSLS     R0,R0,#+3        ;; #+1464
   \   0000004A   0x4341             MULS     R1,R0,R1
   \   0000004C   0x0008             MOVS     R0,R1
   1606                if (fll_freq_hz < 40000000) {return 0x35;}
   \   0000004E   0x....             LDR      R1,??DataTable19_5  ;; 0x2625a00
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xDA01             BGE      ??fll_freq_10
   \   00000054   0x2035             MOVS     R0,#+53
   \   00000056   0xE06C             B        ??fll_freq_8
   1607                else if (fll_freq_hz > 50000000) {return 0x36;}
   \                     ??fll_freq_10:
   \   00000058   0x492D             LDR      R1,??fll_freq_0  ;; 0x2faf081
   \   0000005A   0x4288             CMP      R0,R1
   \   0000005C   0xDB01             BLT      ??fll_freq_11
   \   0000005E   0x2036             MOVS     R0,#+54
   \   00000060   0xE067             B        ??fll_freq_8
   1608                break;
   \                     ??fll_freq_11:
   \   00000062   0xE066             B        ??fll_freq_6
   1609              case 2:
   1610                fll_freq_hz = (fll_ref * 2197);
   \                     ??fll_freq_3:
   \   00000064   0x....             LDR      R0,??DataTable19_6  ;; 0x895
   \   00000066   0x4341             MULS     R1,R0,R1
   \   00000068   0x0008             MOVS     R0,R1
   1611                if (fll_freq_hz < 60000000) {return 0x37;}
   \   0000006A   0x....             LDR      R1,??DataTable19_7  ;; 0x3938700
   \   0000006C   0x4288             CMP      R0,R1
   \   0000006E   0xDA01             BGE      ??fll_freq_12
   \   00000070   0x2037             MOVS     R0,#+55
   \   00000072   0xE05E             B        ??fll_freq_8
   1612                else if (fll_freq_hz > 75000000) {return 0x38;}
   \                     ??fll_freq_12:
   \   00000074   0x....             LDR      R1,??DataTable19_8  ;; 0x47868c1
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xDB01             BLT      ??fll_freq_13
   \   0000007A   0x2038             MOVS     R0,#+56
   \   0000007C   0xE059             B        ??fll_freq_8
   1613                break;
   \                     ??fll_freq_13:
   \   0000007E   0xE058             B        ??fll_freq_6
   1614              case 3:
   1615                fll_freq_hz = (fll_ref * 2929);
   \                     ??fll_freq_5:
   \   00000080   0x....             LDR      R0,??DataTable19_9  ;; 0xb71
   \   00000082   0x4341             MULS     R1,R0,R1
   \   00000084   0x0008             MOVS     R0,R1
   1616                if (fll_freq_hz < 80000000) {return 0x39;}
   \   00000086   0x....             LDR      R1,??DataTable19_10  ;; 0x4c4b400
   \   00000088   0x4288             CMP      R0,R1
   \   0000008A   0xDA01             BGE      ??fll_freq_14
   \   0000008C   0x2039             MOVS     R0,#+57
   \   0000008E   0xE050             B        ??fll_freq_8
   1617                else if (fll_freq_hz > 100000000) {return 0x3A;}
   \                     ??fll_freq_14:
   \   00000090   0x....             LDR      R1,??DataTable19_11  ;; 0x5f5e101
   \   00000092   0x4288             CMP      R0,R1
   \   00000094   0xDB01             BLT      ??fll_freq_15
   \   00000096   0x203A             MOVS     R0,#+58
   \   00000098   0xE04B             B        ??fll_freq_8
   1618                break;
   \                     ??fll_freq_15:
   \   0000009A   0xE04A             B        ??fll_freq_6
   1619              }
   1620            }
   1621            else // if DMX32 = 0
   1622            {
   1623              switch ((MCG_C4 & MCG_C4_DRST_DRS_MASK) >> MCG_C4_DRST_DRS_SHIFT) // determine multiplier based on DRS
   \                     ??fll_freq_1:
   \   0000009C   0x....             LDR      R2,??DataTable19_1  ;; 0x40064003
   \   0000009E   0x7812             LDRB     R2,[R2, #+0]
   \   000000A0   0xB2D2             UXTB     R2,R2
   \   000000A2   0x0952             LSRS     R2,R2,#+5
   \   000000A4   0x0792             LSLS     R2,R2,#+30       ;; ZeroExtS R2,R2,#+30,#+30
   \   000000A6   0x0F92             LSRS     R2,R2,#+30
   \   000000A8   0x2A00             CMP      R2,#+0
   \   000000AA   0xD005             BEQ      ??fll_freq_16
   \   000000AC   0x2A02             CMP      R2,#+2
   \   000000AE   0xD021             BEQ      ??fll_freq_17
   \   000000B0   0xD311             BCC      ??fll_freq_18
   \   000000B2   0x2A03             CMP      R2,#+3
   \   000000B4   0xD02F             BEQ      ??fll_freq_19
   \   000000B6   0xE03C             B        ??fll_freq_6
   1624              {
   1625              case 0:
   1626                fll_freq_hz = (fll_ref * 640);
   \                     ??fll_freq_16:
   \   000000B8   0x20A0             MOVS     R0,#+160
   \   000000BA   0x0080             LSLS     R0,R0,#+2        ;; #+640
   \   000000BC   0x4341             MULS     R1,R0,R1
   \   000000BE   0x0008             MOVS     R0,R1
   1627                if (fll_freq_hz < 20000000) {return 0x33;}
   \   000000C0   0x....             LDR      R1,??DataTable19  ;; 0x1312d00
   \   000000C2   0x4288             CMP      R0,R1
   \   000000C4   0xDA01             BGE      ??fll_freq_20
   \   000000C6   0x2033             MOVS     R0,#+51
   \   000000C8   0xE033             B        ??fll_freq_8
   1628                else if (fll_freq_hz > 25000000) {return 0x34;}
   \                     ??fll_freq_20:
   \   000000CA   0x....             LDR      R1,??DataTable19_4  ;; 0x17d7841
   \   000000CC   0x4288             CMP      R0,R1
   \   000000CE   0xDB01             BLT      ??fll_freq_21
   \   000000D0   0x2034             MOVS     R0,#+52
   \   000000D2   0xE02E             B        ??fll_freq_8
   1629                break;
   \                     ??fll_freq_21:
   \   000000D4   0xE02D             B        ??fll_freq_6
   1630              case 1:
   1631                fll_freq_hz = (fll_ref * 1280);
   \                     ??fll_freq_18:
   \   000000D6   0x20A0             MOVS     R0,#+160
   \   000000D8   0x00C0             LSLS     R0,R0,#+3        ;; #+1280
   \   000000DA   0x4341             MULS     R1,R0,R1
   \   000000DC   0x0008             MOVS     R0,R1
   1632                if (fll_freq_hz < 40000000) {return 0x35;}
   \   000000DE   0x....             LDR      R1,??DataTable19_5  ;; 0x2625a00
   \   000000E0   0x4288             CMP      R0,R1
   \   000000E2   0xDA01             BGE      ??fll_freq_22
   \   000000E4   0x2035             MOVS     R0,#+53
   \   000000E6   0xE024             B        ??fll_freq_8
   1633                else if (fll_freq_hz > 50000000) {return 0x36;}
   \                     ??fll_freq_22:
   \   000000E8   0x4909             LDR      R1,??fll_freq_0  ;; 0x2faf081
   \   000000EA   0x4288             CMP      R0,R1
   \   000000EC   0xDB01             BLT      ??fll_freq_23
   \   000000EE   0x2036             MOVS     R0,#+54
   \   000000F0   0xE01F             B        ??fll_freq_8
   1634                break;
   \                     ??fll_freq_23:
   \   000000F2   0xE01E             B        ??fll_freq_6
   1635              case 2:
   1636                fll_freq_hz = (fll_ref * 1920);
   \                     ??fll_freq_17:
   \   000000F4   0x20F0             MOVS     R0,#+240
   \   000000F6   0x00C0             LSLS     R0,R0,#+3        ;; #+1920
   \   000000F8   0x4341             MULS     R1,R0,R1
   \   000000FA   0x0008             MOVS     R0,R1
   1637                if (fll_freq_hz < 60000000) {return 0x37;}
   \   000000FC   0x....             LDR      R1,??DataTable19_7  ;; 0x3938700
   \   000000FE   0x4288             CMP      R0,R1
   \   00000100   0xDA01             BGE      ??fll_freq_24
   \   00000102   0x2037             MOVS     R0,#+55
   \   00000104   0xE015             B        ??fll_freq_8
   1638                else if (fll_freq_hz > 75000000) {return 0x38;}
   \                     ??fll_freq_24:
   \   00000106   0x....             LDR      R1,??DataTable19_8  ;; 0x47868c1
   \   00000108   0x4288             CMP      R0,R1
   \   0000010A   0xDB03             BLT      ??fll_freq_25
   \   0000010C   0x2038             MOVS     R0,#+56
   \   0000010E   0xE010             B        ??fll_freq_8
   \                     ??fll_freq_0:
   \   00000110   0x02FAF081         DC32     0x2faf081
   1639                break;
   \                     ??fll_freq_25:
   \   00000114   0xE00D             B        ??fll_freq_6
   1640              case 3:
   1641                fll_freq_hz = (fll_ref * 2560);
   \                     ??fll_freq_19:
   \   00000116   0x20A0             MOVS     R0,#+160
   \   00000118   0x0100             LSLS     R0,R0,#+4        ;; #+2560
   \   0000011A   0x4341             MULS     R1,R0,R1
   \   0000011C   0x0008             MOVS     R0,R1
   1642                if (fll_freq_hz < 80000000) {return 0x39;}
   \   0000011E   0x....             LDR      R1,??DataTable19_10  ;; 0x4c4b400
   \   00000120   0x4288             CMP      R0,R1
   \   00000122   0xDA01             BGE      ??fll_freq_26
   \   00000124   0x2039             MOVS     R0,#+57
   \   00000126   0xE004             B        ??fll_freq_8
   1643                else if (fll_freq_hz > 100000000) {return 0x3A;}
   \                     ??fll_freq_26:
   \   00000128   0x....             LDR      R1,??DataTable19_11  ;; 0x5f5e101
   \   0000012A   0x4288             CMP      R0,R1
   \   0000012C   0xDB01             BLT      ??fll_freq_27
   \   0000012E   0x203A             MOVS     R0,#+58
   \   00000130   0xE7FF             B        ??fll_freq_8
   1644                break;
   1645              }
   1646            }    
   1647            return fll_freq_hz;
   \                     ??fll_freq_27:
   \                     ??fll_freq_6:
   \                     ??fll_freq_8:
   \   00000132   0xBD00             POP      {PC}             ;; return
   1648          } // fll_freq

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x00007A12         DC32     0x7a12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x00001E86         DC32     0x1e86

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x00007A12         DC32     0x7a12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x00001E86         DC32     0x1e86

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x002DC6C0         DC32     0x2dc6c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x001E8481         DC32     0x1e8481

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x40064008         DC32     0x40064008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x02FAF081         DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x00007530         DC32     0x7530

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x00009C41         DC32     0x9c41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x002D2A7F         DC32     0x2d2a7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x01E84801         DC32     0x1e84801

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x001312D1         DC32     0x1312d1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x002625A1         DC32     0x2625a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x00989681         DC32     0x989681

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x01312D01         DC32     0x1312d01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x02FAF081         DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x00007530         DC32     0x7530

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x00009C41         DC32     0x9c41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x002D2A7F         DC32     0x2d2a7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x01E84801         DC32     0x1e84801

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x001312D1         DC32     0x1312d1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x002625A1         DC32     0x2625a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x00989681         DC32     0x989681

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x01312D01         DC32     0x1312d01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x00007A12         DC32     0x7a12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x00001E86         DC32     0x1e86

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x002DC6C0         DC32     0x2dc6c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x001E8481         DC32     0x1e8481

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x40064008         DC32     0x40064008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_1:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_2:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_3:
   \   00000000   0x00007A12         DC32     0x7a12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_4:
   \   00000000   0x00001E86         DC32     0x1e86

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_5:
   \   00000000   0x002DC6C0         DC32     0x2dc6c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_6:
   \   00000000   0x001E8481         DC32     0x1e8481

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13_7:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0xFFF8FFFF         DC32     0xfff8ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x007A1200         DC32     0x7a1200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x00007A12         DC32     0x7a12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x00009897         DC32     0x9897

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x002DC6C0         DC32     0x2dc6c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x41A80000         DC32     0x41a80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x4006400B         DC32     0x4006400b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x4006400A         DC32     0x4006400a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x40064008         DC32     0x40064008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x40064002         DC32     0x40064002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   0x40064003         DC32     0x40064003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x02FAF081         DC32     0x2faf081

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x00007530         DC32     0x7530

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x00009C41         DC32     0x9c41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x002D2A7F         DC32     0x2d2a7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x01E84801         DC32     0x1e84801

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18:
   \   00000000   0x001312D1         DC32     0x1312d1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_1:
   \   00000000   0x002625A1         DC32     0x2625a1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_2:
   \   00000000   0x004C4B41         DC32     0x4c4b41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_3:
   \   00000000   0x00989681         DC32     0x989681

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_4:
   \   00000000   0x01312D01         DC32     0x1312d01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_5:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_6:
   \   00000000   0x00002710         DC32     0x2710

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_7:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_8:
   \   00000000   0x00009C41         DC32     0x9c41

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_9:
   \   00000000   0x002D2A7F         DC32     0x2d2a7f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_10:
   \   00000000   0x01E84801         DC32     0x1e84801

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_11:
   \   00000000   0x40065000         DC32     0x40065000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_12:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable18_13:
   \   00000000   0x007A1201         DC32     0x7a1201

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x01312D00         DC32     0x1312d00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x40064003         DC32     0x40064003

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x00004E20         DC32     0x4e20

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x017D7841         DC32     0x17d7841

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0x02625A00         DC32     0x2625a00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \   00000000   0x00000895         DC32     0x895

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_7:
   \   00000000   0x03938700         DC32     0x3938700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_8:
   \   00000000   0x047868C1         DC32     0x47868c1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_9:
   \   00000000   0x00000B71         DC32     0xb71

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_10:
   \   00000000   0x04C4B400         DC32     0x4c4b400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_11:
   \   00000000   0x05F5E101         DC32     0x5f5e101

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       24  atc
             24 -> __aeabi_f2iz
             24 -> __aeabi_fdiv
             24 -> __aeabi_fmul
             24 -> __aeabi_i2f
             24 -> __aeabi_idiv
             24 -> __aeabi_uidiv
             24 -> what_mcg_mode
        4  blpe_fbe
        4  blpi_fbi
              4 -> __aeabi_idiv
        4  clk_monitor_0
        4  fbe_blpe
        4  fbe_fbi
              4 -> __aeabi_idiv
        8  fbe_fee
              8 -> __aeabi_idiv
              8 -> fll_freq
        8  fbe_fei
              8 -> fll_freq
        4  fbi_blpi
              4 -> __aeabi_idiv
       12  fbi_fbe
       16  fbi_fee
             16 -> __aeabi_idiv
             16 -> fll_freq
        8  fbi_fei
              8 -> fll_freq
        4  fee_fbe
        4  fee_fbi
              4 -> __aeabi_idiv
        8  fee_fei
              8 -> fll_freq
       12  fei_fbe
        4  fei_fbi
              4 -> __aeabi_idiv
       16  fei_fee
             16 -> __aeabi_idiv
             16 -> fll_freq
        4  fll_freq
        4  what_mcg_mode


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable14
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_10
       4  ??DataTable18_11
       4  ??DataTable18_12
       4  ??DataTable18_13
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable18_7
       4  ??DataTable18_8
       4  ??DataTable18_9
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_10
       4  ??DataTable19_11
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable6
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
     400  atc
      52  blpe_fbe
      82  blpi_fbi
      36  clk_monitor_0
       1  dmx32_val
       1  drs_val
      52  fbe_blpe
     332  fbe_fbi
     172  fbe_fee
     180  fbe_fei
      82  fbi_blpi
     388  fbi_fbe
     428  fbi_fee
     168  fbi_fei
      96  fee_fbe
     318  fee_fbi
     114  fee_fei
     336  fei_fbe
     276  fei_fbi
     386  fei_fee
     308  fll_freq
     206  what_mcg_mode

 
     2 bytes in section .bss
 4 856 bytes in section .text
 
 4 856 bytes of CODE memory
     2 bytes of DATA memory

Errors: none
Warnings: none
