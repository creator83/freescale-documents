###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.50.3.4676/W32 for ARM      15/Jul/2015  14:11:15 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\User\Desktop\freescale\source\demo_i2s\src\hal\ #
#                    hal_dma.c                                                #
#    Command line =  C:\Users\User\Desktop\freescale\source\demo_i2s\src\hal\ #
#                    hal_dma.c -lCN C:\Users\User\Desktop\freescale\source\De #
#                    bug\List\ -o C:\Users\User\Desktop\freescale\source\Debu #
#                    g\Obj\ --no_cse --no_unroll --no_inline                  #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --char_is_signed --fpu=None --dlib_config             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    6.5\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    D:\work\prj\g_demo_k\demo_k\src\include\ -On             #
#    List file    =  C:\Users\User\Desktop\freescale\source\Debug\List\hal_dm #
#                    a.lst                                                    #
#    Object file  =  C:\Users\User\Desktop\freescale\source\Debug\Obj\hal_dma #
#                    .o                                                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\User\Desktop\freescale\source\demo_i2s\src\hal\hal_dma.c
      1          
      2          
      3          
      4          
      5          #include "..\\include\\global.h"
      6          #include "..\\include\\MKxxx.h"
      7          #include "..\\include\\hal_uart.h"
      8          #include "..\\include\\hal_config.h"
      9          #include "..\\include\\nvic.h"
     10          
     11          #define DMA_SIZE_8_BIT  0
     12          #define DMA_SIZE_16_BIT 1
     13          #define DMA_SIZE_32_BIT 2
     14          
     15          #define DMA_MUX_SRC_ADC0 40
     16          #define DMA_MUX_SRC_ADC1 41
     17          
     18          #define SRAM_SADDRESS    0x1FFFE000
     19          #define SRAM_DADDRESS    0x1FFFF000
     20          

   \                                 In section .text, align 2, keep-with-next
     21          void dma_sw_trig(int channel)
     22          {
   \                     dma_sw_trig:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     23              static int i = 0;
     24              DMA_SSRT = channel;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable8  ;; 0x4000801d
   \   00000008   0x7004             STRB     R4,[R0, #+0]
     25          
     26              printf("dma_sw_trig %d\n",i++);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0x1C48             ADDS     R0,R1,#+1
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable8_1
   \   00000016   0x6010             STR      R0,[R2, #+0]
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable8_2
   \   0000001C   0x.... 0x....      BL       q_printf
     27          }
   \   00000020   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .bss, align 4
   \                     ??i:
   \   00000000                      DS8 4

   \                                 In section .text, align 2, keep-with-next
     28          void sw_delay(void)
     29          {
     30              int i;
     31              for(i=0;i<100;i++);
   \                     sw_delay:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x0008             MOVS     R0,R1
   \                     ??sw_delay_0:
   \   00000004   0x2864             CMP      R0,#+100
   \   00000006   0xDA01             BGE.N    ??sw_delay_1
   \   00000008   0x1C40             ADDS     R0,R0,#+1
   \   0000000A   0xE7FB             B.N      ??sw_delay_0
     32          }
   \                     ??sw_delay_1:
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     33          int dma_wait(int channel)
     34          {
   \                     dma_wait:
   \   00000000   0x0001             MOVS     R1,R0
     35              int r = 0;
   \   00000002   0x2000             MOVS     R0,#+0
     36              while((( DMA_CSR(channel) & DMA_CSR_DONE_MASK) == 0) && ( DMA_ES == 0));
   \                     ??dma_wait_0:
   \   00000004   0x014A             LSLS     R2,R1,#+5
   \   00000006   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   0000000A   0xF512 0x4210      ADDS     R2,R2,#+36864
   \   0000000E   0x8B92             LDRH     R2,[R2, #+28]
   \   00000010   0x0612             LSLS     R2,R2,#+24
   \   00000012   0xD404             BMI.N    ??dma_wait_1
   \   00000014   0x.... 0x....      LDR.W    R2,??DataTable8_3  ;; 0x40008004
   \   00000018   0x6812             LDR      R2,[R2, #+0]
   \   0000001A   0x2A00             CMP      R2,#+0
   \   0000001C   0xD0F2             BEQ.N    ??dma_wait_0
     37                      
     38              if (DMA_ES)
   \                     ??dma_wait_1:
   \   0000001E   0x.... 0x....      LDR.W    R2,??DataTable8_3  ;; 0x40008004
   \   00000022   0x6812             LDR      R2,[R2, #+0]
   \   00000024   0x2A00             CMP      R2,#+0
   \   00000026   0xD002             BEQ.N    ??dma_wait_2
     39                  r = DMA_ES;
   \   00000028   0x....             LDR.N    R2,??DataTable8_3  ;; 0x40008004
   \   0000002A   0x6812             LDR      R2,[R2, #+0]
   \   0000002C   0x0010             MOVS     R0,R2
     40              return r;
   \                     ??dma_wait_2:
   \   0000002E   0x4770             BX       LR               ;; return
     41          }
     42          
     43          #if TEST_ENABLE

   \                                 In section .text, align 2, keep-with-next
     44          void mem_src_init(void)
     45          {
     46              char *p;
     47              int i = 0;
   \                     mem_src_init:
   \   00000000   0x2100             MOVS     R1,#+0
     48          
     49              p = (char*)SRAM_SADDRESS;
   \   00000002   0x....             LDR.N    R2,??DataTable8_4  ;; 0x1fffe000
   \   00000004   0x0010             MOVS     R0,R2
     50              for(i=0;i<128;i++)
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x0011             MOVS     R1,R2
   \                     ??mem_src_init_0:
   \   0000000A   0x2980             CMP      R1,#+128
   \   0000000C   0xDA03             BGE.N    ??mem_src_init_1
     51                  *p++ = i;
   \   0000000E   0x7001             STRB     R1,[R0, #+0]
   \   00000010   0x1C40             ADDS     R0,R0,#+1
   \   00000012   0x1C49             ADDS     R1,R1,#+1
   \   00000014   0xE7F9             B.N      ??mem_src_init_0
     52          
     53          
     54              p = (char*)SRAM_DADDRESS;
   \                     ??mem_src_init_1:
   \   00000016   0x....             LDR.N    R2,??DataTable8_5  ;; 0x1ffff000
   \   00000018   0x0010             MOVS     R0,R2
     55              for(i=0;i<128;i++)
   \   0000001A   0x2200             MOVS     R2,#+0
   \   0000001C   0x0011             MOVS     R1,R2
   \                     ??mem_src_init_2:
   \   0000001E   0x2980             CMP      R1,#+128
   \   00000020   0xDA04             BGE.N    ??mem_src_init_3
     56                  *p++ = 0;
   \   00000022   0x2200             MOVS     R2,#+0
   \   00000024   0x7002             STRB     R2,[R0, #+0]
   \   00000026   0x1C40             ADDS     R0,R0,#+1
   \   00000028   0x1C49             ADDS     R1,R1,#+1
   \   0000002A   0xE7F8             B.N      ??mem_src_init_2
     57          }
   \                     ??mem_src_init_3:
   \   0000002C   0x4770             BX       LR               ;; return
     58          

   \                                 In section .text, align 2, keep-with-next
     59          void dma_sw_trgger_test (void)
     60          {
   \                     dma_sw_trgger_test:
   \   00000000   0xB510             PUSH     {R4,LR}
     61              int channel = 0;
   \   00000002   0x2400             MOVS     R4,#+0
     62          
     63              SIM_SCGC6 |= SIM_SCGC6_DMAMUX_MASK;
   \   00000004   0x....             LDR.N    R0,??DataTable8_6  ;; 0x4004803c
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000000C   0x....             LDR.N    R1,??DataTable8_6  ;; 0x4004803c
   \   0000000E   0x6008             STR      R0,[R1, #+0]
     64          
     65              DMA_SADDR(channel) = SRAM_SADDRESS;
   \   00000010   0x0160             LSLS     R0,R4,#+5
   \   00000012   0x....             LDR.N    R1,??DataTable8_7  ;; 0x40009000
   \   00000014   0x....             LDR.N    R2,??DataTable8_4  ;; 0x1fffe000
   \   00000016   0x5042             STR      R2,[R0, R1]
     66              DMA_DADDR(channel) = SRAM_DADDRESS;
   \   00000018   0x0160             LSLS     R0,R4,#+5
   \   0000001A   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   0000001E   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   00000022   0x....             LDR.N    R1,??DataTable8_5  ;; 0x1ffff000
   \   00000024   0x6101             STR      R1,[R0, #+16]
     67          
     68              // 每次传送4个字节 无内层循环
     69              DMA_NBYTES_MLNO(channel) = 4;
   \   00000026   0x0160             LSLS     R0,R4,#+5
   \   00000028   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   0000002C   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   00000030   0x2104             MOVS     R1,#+4
   \   00000032   0x6081             STR      R1,[R0, #+8]
     70              DMA_ATTR(channel) = DMA_ATTR_SSIZE(DMA_SIZE_16_BIT) | DMA_ATTR_DSIZE(DMA_SIZE_16_BIT);
   \   00000034   0x0160             LSLS     R0,R4,#+5
   \   00000036   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   0000003A   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   0000003E   0xF240 0x1101      MOVW     R1,#+257
   \   00000042   0x80C1             STRH     R1,[R0, #+6]
     71          
     72              // 源、目地址每次操作后的增量，这是个有符号数，可以递增，也可以递减
     73              DMA_SOFF(channel) = 2;
   \   00000044   0x0160             LSLS     R0,R4,#+5
   \   00000046   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   0000004A   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   0000004E   0x2102             MOVS     R1,#+2
   \   00000050   0x8081             STRH     R1,[R0, #+4]
     74              DMA_DOFF(channel) = 2;
   \   00000052   0x0160             LSLS     R0,R4,#+5
   \   00000054   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000058   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   0000005C   0x2102             MOVS     R1,#+2
   \   0000005E   0x8281             STRH     R1,[R0, #+20]
     75          
     76              // 主循环完成后的地址增量
     77              DMA_SLAST(channel)     =  0;
   \   00000060   0x0160             LSLS     R0,R4,#+5
   \   00000062   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000066   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x60C1             STR      R1,[R0, #+12]
     78              DMA_DLAST_SGA(channel) = (uint)(-8);
   \   0000006E   0x0160             LSLS     R0,R4,#+5
   \   00000070   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000074   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   00000078   0xF07F 0x0107      MVNS     R1,#+7
   \   0000007C   0x6181             STR      R1,[R0, #+24]
     79          
     80              // CITER的值会在运行中进行递减，耗尽后，会重新装载BITER的值
     81              DMA_CITER_ELINKNO(channel) = 2;
   \   0000007E   0x0160             LSLS     R0,R4,#+5
   \   00000080   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000084   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   00000088   0x2102             MOVS     R1,#+2
   \   0000008A   0x82C1             STRH     R1,[R0, #+22]
     82              DMA_BITER_ELINKNO(channel) = 2;
   \   0000008C   0x0160             LSLS     R0,R4,#+5
   \   0000008E   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000092   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   00000096   0x2102             MOVS     R1,#+2
   \   00000098   0x83C1             STRH     R1,[R0, #+30]
     83          
     84          
     85              nvic_enable_irq(IRQ_DMA0);
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x.... 0x....      BL       nvic_enable_irq
     86              // major耗尽后产生中断
     87              DMA_CSR(channel) = DMA_CSR_INTMAJOR_MASK;    
   \   000000A0   0x0160             LSLS     R0,R4,#+5
   \   000000A2   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   000000A6   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   000000AA   0x2102             MOVS     R1,#+2
   \   000000AC   0x8381             STRH     R1,[R0, #+28]
     88              // enable interrupt on this channel
     89              DMA_SERQ = DMA_SERQ_SERQ(channel);
   \   000000AE   0xF014 0x000F      ANDS     R0,R4,#0xF
   \   000000B2   0x....             LDR.N    R1,??DataTable8_8  ;; 0x4000801b
   \   000000B4   0x7008             STRB     R0,[R1, #+0]
     90          
     91              mem_src_init();
   \   000000B6   0x.... 0x....      BL       mem_src_init
     92              printf("mem_src_init\n");
   \   000000BA   0x....             LDR.N    R0,??DataTable8_9
   \   000000BC   0x.... 0x....      BL       q_printf
     93              print_buf((char*)SRAM_SADDRESS, 16);
   \   000000C0   0x2110             MOVS     R1,#+16
   \   000000C2   0x....             LDR.N    R0,??DataTable8_4  ;; 0x1fffe000
   \   000000C4   0x.... 0x....      BL       print_buf
     94              print_buf((char*)SRAM_DADDRESS, 16);
   \   000000C8   0x2110             MOVS     R1,#+16
   \   000000CA   0x....             LDR.N    R0,??DataTable8_5  ;; 0x1ffff000
   \   000000CC   0x.... 0x....      BL       print_buf
     95          
     96              dma_sw_trig(channel);
   \   000000D0   0x0020             MOVS     R0,R4
   \   000000D2   0x.... 0x....      BL       dma_sw_trig
     97              dma_sw_trig(channel);
   \   000000D6   0x0020             MOVS     R0,R4
   \   000000D8   0x.... 0x....      BL       dma_sw_trig
     98              dma_wait(channel);
   \   000000DC   0x0020             MOVS     R0,R4
   \   000000DE   0x.... 0x....      BL       dma_wait
     99          
    100              printf("trig 1\n");
   \   000000E2   0x....             LDR.N    R0,??DataTable8_10
   \   000000E4   0x.... 0x....      BL       q_printf
    101              print_buf((char*)SRAM_SADDRESS, 16);
   \   000000E8   0x2110             MOVS     R1,#+16
   \   000000EA   0x....             LDR.N    R0,??DataTable8_4  ;; 0x1fffe000
   \   000000EC   0x.... 0x....      BL       print_buf
    102              print_buf((char*)SRAM_DADDRESS, 16);
   \   000000F0   0x2110             MOVS     R1,#+16
   \   000000F2   0x....             LDR.N    R0,??DataTable8_5  ;; 0x1ffff000
   \   000000F4   0x.... 0x....      BL       print_buf
    103          
    104              dma_sw_trig(channel);
   \   000000F8   0x0020             MOVS     R0,R4
   \   000000FA   0x.... 0x....      BL       dma_sw_trig
    105              dma_sw_trig(channel);
   \   000000FE   0x0020             MOVS     R0,R4
   \   00000100   0x.... 0x....      BL       dma_sw_trig
    106              dma_wait(channel);
   \   00000104   0x0020             MOVS     R0,R4
   \   00000106   0x.... 0x....      BL       dma_wait
    107              printf("trig 2\n");
   \   0000010A   0x....             LDR.N    R0,??DataTable8_11
   \   0000010C   0x.... 0x....      BL       q_printf
    108              print_buf((char*)SRAM_SADDRESS, 16);
   \   00000110   0x2110             MOVS     R1,#+16
   \   00000112   0x....             LDR.N    R0,??DataTable8_4  ;; 0x1fffe000
   \   00000114   0x.... 0x....      BL       print_buf
    109              print_buf((char*)SRAM_DADDRESS, 16);
   \   00000118   0x2110             MOVS     R1,#+16
   \   0000011A   0x....             LDR.N    R0,??DataTable8_5  ;; 0x1ffff000
   \   0000011C   0x.... 0x....      BL       print_buf
    110          
    111              dma_sw_trig(channel);
   \   00000120   0x0020             MOVS     R0,R4
   \   00000122   0x.... 0x....      BL       dma_sw_trig
    112              dma_sw_trig(channel);
   \   00000126   0x0020             MOVS     R0,R4
   \   00000128   0x.... 0x....      BL       dma_sw_trig
    113              dma_wait(channel);
   \   0000012C   0x0020             MOVS     R0,R4
   \   0000012E   0x.... 0x....      BL       dma_wait
    114              printf("trig 3\n");
   \   00000132   0x....             LDR.N    R0,??DataTable8_12
   \   00000134   0x.... 0x....      BL       q_printf
    115              print_buf((char*)SRAM_SADDRESS, 16);
   \   00000138   0x2110             MOVS     R1,#+16
   \   0000013A   0x....             LDR.N    R0,??DataTable8_4  ;; 0x1fffe000
   \   0000013C   0x.... 0x....      BL       print_buf
    116              print_buf((char*)SRAM_DADDRESS, 16);
   \   00000140   0x2110             MOVS     R1,#+16
   \   00000142   0x....             LDR.N    R0,??DataTable8_5  ;; 0x1ffff000
   \   00000144   0x.... 0x....      BL       print_buf
    117          }
   \   00000148   0xBD10             POP      {R4,PC}          ;; return
    118          #endif
    119          
    120          #if BOARD == BOARD_K10
    121          static void _init_for_adc1 (void)
    122          {
    123              int channel = 0;
    124          
    125              SIM_SCGC6     |= SIM_SCGC6_DMAMUX_MASK;
    126              DMAMUX_CHCFG0  = DMAMUX_CHCFG_ENBL_MASK | 
    127                               DMAMUX_CHCFG_SOURCE(DMA_MUX_SRC_ADC1);
    128              nvic_enable_irq(IRQ_DMA0);
    129          
    130              DMA_SADDR(channel) = (u32)(&(ADC1_RA));
    131              DMA_DADDR(channel) = SRAM_DADDRESS;
    132          
    133              // 每次传送4个字节 无内层循环
    134              DMA_NBYTES_MLNO(channel) = 4;
    135              DMA_ATTR(channel) = DMA_ATTR_SSIZE(DMA_SIZE_32_BIT) | DMA_ATTR_DSIZE(DMA_SIZE_32_BIT);
    136          
    137              // 源、目地址每次操作后的增量，这是个有符号数，可以递增，也可以递减
    138              // 这里的设置要和DMA_ATTR匹配
    139              DMA_SOFF(channel) = 0;
    140              DMA_DOFF(channel) = 4;
    141          
    142              // 主循环完成后的地址增量
    143              DMA_SLAST(channel)     =  0;
    144              DMA_DLAST_SGA(channel) = (uint)(-8);
    145          
    146              // CITER的值会在运行中进行递减，耗尽后，会重新装载BITER的值
    147              DMA_CITER_ELINKNO(channel) = 2;
    148              DMA_BITER_ELINKNO(channel) = 2;
    149          
    150              // major耗尽后产生中断
    151              DMA_CSR(channel) = DMA_CSR_INTMAJOR_MASK;
    152          
    153              // enable dma
    154              DMA_SERQ = DMA_SERQ_SERQ(channel);
    155          }
    156          #endif
    157          
    158          #if (BOARD == BOARD_K50) || (BOARD == BOARD_K60)
    159          
    160          
    161          typedef struct {
    162              int channel;
    163          	u32 saddr,daddr;     // initial address
    164          	s16 soff,doff;       // offset after each read/write
    165          	u16 attr;	         // modulo and port size
    166          	u32 nbytes;          // each minor transmission count
    167          	s32 slast,dlast_sga; // offset after major loop end
    168          	u16 citer,biter;	 // major loop, CITER decreases, then reloaded from BITER	
    169          }DMA_TCD;

   \                                 In section .text, align 2, keep-with-next
    170          static void _dma_init(DMA_TCD *tcd)
    171          {
   \                     _dma_init:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x0004             MOVS     R4,R0
    172              DMA_SADDR(tcd->channel)           = tcd->saddr;
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x0140             LSLS     R0,R0,#+5
   \   0000000A   0x....             LDR.N    R1,??DataTable8_7  ;; 0x40009000
   \   0000000C   0x6862             LDR      R2,[R4, #+4]
   \   0000000E   0x5042             STR      R2,[R0, R1]
    173              DMA_DADDR(tcd->channel)           = tcd->daddr;
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x0140             LSLS     R0,R0,#+5
   \   00000014   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000018   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   0000001C   0x68A1             LDR      R1,[R4, #+8]
   \   0000001E   0x6101             STR      R1,[R0, #+16]
    174              DMA_NBYTES_MLOFFYES(tcd->channel) = tcd->nbytes;
   \   00000020   0x6820             LDR      R0,[R4, #+0]
   \   00000022   0x0140             LSLS     R0,R0,#+5
   \   00000024   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000028   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   0000002C   0x6961             LDR      R1,[R4, #+20]
   \   0000002E   0x6081             STR      R1,[R0, #+8]
    175              DMA_ATTR(tcd->channel)            = tcd->attr;
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x0140             LSLS     R0,R0,#+5
   \   00000034   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000038   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   0000003C   0x8A21             LDRH     R1,[R4, #+16]
   \   0000003E   0x80C1             STRH     R1,[R0, #+6]
    176              DMA_SOFF(tcd->channel)            = tcd->soff;
   \   00000040   0x6820             LDR      R0,[R4, #+0]
   \   00000042   0x0140             LSLS     R0,R0,#+5
   \   00000044   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000048   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   0000004C   0x89A1             LDRH     R1,[R4, #+12]
   \   0000004E   0x8081             STRH     R1,[R0, #+4]
    177              DMA_DOFF(tcd->channel)            = tcd->doff;
   \   00000050   0x6820             LDR      R0,[R4, #+0]
   \   00000052   0x0140             LSLS     R0,R0,#+5
   \   00000054   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000058   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   0000005C   0x89E1             LDRH     R1,[R4, #+14]
   \   0000005E   0x8281             STRH     R1,[R0, #+20]
    178              DMA_SLAST(tcd->channel)           = tcd->slast;
   \   00000060   0x6820             LDR      R0,[R4, #+0]
   \   00000062   0x0140             LSLS     R0,R0,#+5
   \   00000064   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000068   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   0000006C   0x69A1             LDR      R1,[R4, #+24]
   \   0000006E   0x60C1             STR      R1,[R0, #+12]
    179              DMA_DLAST_SGA(tcd->channel)       = tcd->dlast_sga;
   \   00000070   0x6820             LDR      R0,[R4, #+0]
   \   00000072   0x0140             LSLS     R0,R0,#+5
   \   00000074   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000078   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   0000007C   0x69E1             LDR      R1,[R4, #+28]
   \   0000007E   0x6181             STR      R1,[R0, #+24]
    180              DMA_CITER_ELINKNO(tcd->channel)   = tcd->citer;
   \   00000080   0x6820             LDR      R0,[R4, #+0]
   \   00000082   0x0140             LSLS     R0,R0,#+5
   \   00000084   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000088   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   0000008C   0x8C21             LDRH     R1,[R4, #+32]
   \   0000008E   0x82C1             STRH     R1,[R0, #+22]
    181              DMA_BITER_ELINKNO(tcd->channel)   = tcd->biter;
   \   00000090   0x6820             LDR      R0,[R4, #+0]
   \   00000092   0x0140             LSLS     R0,R0,#+5
   \   00000094   0xF100 0x4080      ADD      R0,R0,#+1073741824
   \   00000098   0xF510 0x4010      ADDS     R0,R0,#+36864
   \   0000009C   0x8C61             LDRH     R1,[R4, #+34]
   \   0000009E   0x83C1             STRH     R1,[R0, #+30]
    182          
    183              printf("%x,%x,%x,%x,\n%d,%d,%d,%d,%d,%d\n",
    184              tcd->saddr,tcd->daddr,tcd->nbytes,tcd->attr,
    185              tcd->soff,tcd->doff,tcd->slast,tcd->dlast_sga,
    186              tcd->citer,tcd->biter);
   \   000000A0   0x8C60             LDRH     R0,[R4, #+34]
   \   000000A2   0x9006             STR      R0,[SP, #+24]
   \   000000A4   0x8C20             LDRH     R0,[R4, #+32]
   \   000000A6   0x9005             STR      R0,[SP, #+20]
   \   000000A8   0x69E0             LDR      R0,[R4, #+28]
   \   000000AA   0x9004             STR      R0,[SP, #+16]
   \   000000AC   0x69A0             LDR      R0,[R4, #+24]
   \   000000AE   0x9003             STR      R0,[SP, #+12]
   \   000000B0   0xF9B4 0x000E      LDRSH    R0,[R4, #+14]
   \   000000B4   0x9002             STR      R0,[SP, #+8]
   \   000000B6   0xF9B4 0x000C      LDRSH    R0,[R4, #+12]
   \   000000BA   0x9001             STR      R0,[SP, #+4]
   \   000000BC   0x8A20             LDRH     R0,[R4, #+16]
   \   000000BE   0x9000             STR      R0,[SP, #+0]
   \   000000C0   0x6963             LDR      R3,[R4, #+20]
   \   000000C2   0x68A2             LDR      R2,[R4, #+8]
   \   000000C4   0x6861             LDR      R1,[R4, #+4]
   \   000000C6   0x....             LDR.N    R0,??DataTable8_13
   \   000000C8   0x.... 0x....      BL       q_printf
    187          }
   \   000000CC   0xB008             ADD      SP,SP,#+32
   \   000000CE   0xBD10             POP      {R4,PC}          ;; return
    188          #endif
    189          

   \                                 In section .text, align 2, keep-with-next
    190          void hal_dma_init(void)
    191          {
   \                     hal_dma_init:
   \   00000000   0xB580             PUSH     {R7,LR}
    192          #if BOARD == BOARD_K10
    193              _init_for_adc1();
    194          #endif
    195          
    196          #if (BOARD == BOARD_K50) || (BOARD == BOARD_K60)
    197          /*
    198              _init_for_i2s(0, (uint)buf_i2s_r_rx, (uint)(&I2S0_RX0), false);
    199              _init_for_i2s(1, (uint)buf_i2s_l_rx, (uint)(&I2S0_RX1), false);
    200              _init_for_i2s(2, (uint)buf_i2s_r_tx, (uint)(&I2S0_TX0), true);
    201              _init_for_i2s(3, (uint)buf_i2s_l_tx, (uint)(&I2S0_TX1), true);
    202          */
    203              // when major loop end and half end, generate interrupt
    204              DMA_CSR(0) = DMA_CSR_INTHALF_MASK | DMA_CSR_INTMAJOR_MASK;
   \   00000002   0x....             LDR.N    R0,??DataTable8_14  ;; 0x4000901c
   \   00000004   0x2106             MOVS     R1,#+6
   \   00000006   0x8001             STRH     R1,[R0, #+0]
    205              nvic_enable_irq(IRQ_DMA0);
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      BL       nvic_enable_irq
    206          #endif
    207          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
    208          
    209          #define DMA_SRC_I2S_R 14
    210          #define DMA_SRC_I2S_T 15

   \                                 In section .text, align 2, keep-with-next
    211          void hal_dma_init_for_i2s(uint buf_rx, uint buf_tx, uint block_n_sample, uint sample_n_byte)
    212          {
   \                     hal_dma_init_for_i2s:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08A             SUB      SP,SP,#+40
   \   00000006   0x0004             MOVS     R4,R0
   \   00000008   0x000D             MOVS     R5,R1
   \   0000000A   0x0016             MOVS     R6,R2
   \   0000000C   0x001F             MOVS     R7,R3
    213              uint size_bit;
    214              DMA_TCD tcd;
    215          
    216              switch(sample_n_byte)
   \   0000000E   0x0038             MOVS     R0,R7
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD004             BEQ.N    ??hal_dma_init_for_i2s_0
   \   00000014   0x2802             CMP      R0,#+2
   \   00000016   0xD005             BEQ.N    ??hal_dma_init_for_i2s_1
   \   00000018   0x2804             CMP      R0,#+4
   \   0000001A   0xD006             BEQ.N    ??hal_dma_init_for_i2s_2
   \   0000001C   0xE008             B.N      ??hal_dma_init_for_i2s_3
    217              {
    218                  case 1:  size_bit = DMA_SIZE_8_BIT;  break;
   \                     ??hal_dma_init_for_i2s_0:
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x4680             MOV      R8,R0
   \   00000022   0xE007             B.N      ??hal_dma_init_for_i2s_4
    219                  case 2:  size_bit = DMA_SIZE_16_BIT; break;
   \                     ??hal_dma_init_for_i2s_1:
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x4680             MOV      R8,R0
   \   00000028   0xE004             B.N      ??hal_dma_init_for_i2s_4
    220                  case 4:  size_bit = DMA_SIZE_32_BIT; break;
   \                     ??hal_dma_init_for_i2s_2:
   \   0000002A   0x2002             MOVS     R0,#+2
   \   0000002C   0x4680             MOV      R8,R0
   \   0000002E   0xE001             B.N      ??hal_dma_init_for_i2s_4
    221                  default: size_bit = DMA_SIZE_32_BIT; break;
   \                     ??hal_dma_init_for_i2s_3:
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0x4680             MOV      R8,R0
    222              }
    223          
    224              SIM_SCGC6    |= SIM_SCGC6_DMAMUX_MASK;
   \                     ??hal_dma_init_for_i2s_4:
   \   00000034   0x....             LDR.N    R0,??DataTable8_6  ;; 0x4004803c
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000003C   0x....             LDR.N    R1,??DataTable8_6  ;; 0x4004803c
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    225              DMAMUX_CHCFG0 = DMAMUX_CHCFG_ENBL_MASK | DMAMUX_CHCFG_SOURCE(DMA_SRC_I2S_T);
   \   00000040   0x....             LDR.N    R0,??DataTable8_15  ;; 0x40021000
   \   00000042   0x218F             MOVS     R1,#+143
   \   00000044   0x7001             STRB     R1,[R0, #+0]
    226          
    227              DMA_CR       |= DMA_CR_EMLM_MASK;
   \   00000046   0x....             LDR.N    R0,??DataTable8_16  ;; 0x40008000
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000004E   0x....             LDR.N    R1,??DataTable8_16  ;; 0x40008000
   \   00000050   0x6008             STR      R0,[R1, #+0]
    228              DMA_CSR(0)    = DMA_CSR_INTHALF_MASK | DMA_CSR_INTMAJOR_MASK;
   \   00000052   0x....             LDR.N    R0,??DataTable8_14  ;; 0x4000901c
   \   00000054   0x2106             MOVS     R1,#+6
   \   00000056   0x8001             STRH     R1,[R0, #+0]
    229              nvic_enable_irq(IRQ_DMA0);
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      BL       nvic_enable_irq
    230          
    231              tcd.channel   = 0;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x9000             STR      R0,[SP, #+0]
    232              tcd.nbytes    = DMA_NBYTES_MLOFFYES_SMLOE_MASK | 
    233                              DMA_NBYTES_MLOFFYES_MLOFF(sample_n_byte - block_n_sample*2*sample_n_byte*2) | 
    234                              DMA_NBYTES_MLOFFYES_NBYTES(sample_n_byte*2);
   \   00000062   0xFB07 0xF006      MUL      R0,R7,R6
   \   00000066   0xEBB7 0x0080      SUBS     R0,R7,R0, LSL #+2
   \   0000006A   0x....             LDR.N    R1,??DataTable8_17  ;; 0x3ffffc00
   \   0000006C   0xEA11 0x2080      ANDS     R0,R1,R0, LSL #+10
   \   00000070   0x0079             LSLS     R1,R7,#+1
   \   00000072   0x0589             LSLS     R1,R1,#+22       ;; ZeroExtS R1,R1,#+22,#+22
   \   00000074   0x0D89             LSRS     R1,R1,#+22
   \   00000076   0x4308             ORRS     R0,R1,R0
   \   00000078   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   0000007C   0x9005             STR      R0,[SP, #+20]
    235              tcd.attr      = DMA_ATTR_SSIZE(size_bit) | DMA_ATTR_DSIZE(size_bit);
   \   0000007E   0xEA5F 0x2008      LSLS     R0,R8,#+8
   \   00000082   0xF410 0x60E0      ANDS     R0,R0,#0x700
   \   00000086   0xF018 0x0107      ANDS     R1,R8,#0x7
   \   0000008A   0x4308             ORRS     R0,R1,R0
   \   0000008C   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    236          
    237              tcd.saddr     = buf_tx;
   \   00000090   0x9501             STR      R5,[SP, #+4]
    238              tcd.soff      = block_n_sample*2*sample_n_byte;
   \   00000092   0xFB16 0xF007      SMULBB   R0,R6,R7
   \   00000096   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000098   0x0040             LSLS     R0,R0,#+1
   \   0000009A   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    239              tcd.slast     = -(block_n_sample*2*sample_n_byte*3 - sample_n_byte);
   \   0000009E   0xFB07 0xF006      MUL      R0,R7,R6
   \   000000A2   0x2106             MOVS     R1,#+6
   \   000000A4   0xFB01 0x7010      MLS      R0,R1,R0,R7
   \   000000A8   0x9006             STR      R0,[SP, #+24]
    240          
    241              tcd.daddr     = (uint)(&I2S0_TDR0);
   \   000000AA   0x....             LDR.N    R0,??DataTable8_18  ;; 0x4002f020
   \   000000AC   0x9002             STR      R0,[SP, #+8]
    242              tcd.doff      = 0;
   \   000000AE   0x2000             MOVS     R0,#+0
   \   000000B0   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    243              tcd.dlast_sga = 0;
   \   000000B4   0x2000             MOVS     R0,#+0
   \   000000B6   0x9007             STR      R0,[SP, #+28]
    244              
    245              tcd.citer     = block_n_sample*2;
   \   000000B8   0x0030             MOVS     R0,R6
   \   000000BA   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000BC   0x0040             LSLS     R0,R0,#+1
   \   000000BE   0xF8AD 0x0020      STRH     R0,[SP, #+32]
    246              tcd.biter     = block_n_sample*2;
   \   000000C2   0x0030             MOVS     R0,R6
   \   000000C4   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   000000C6   0x0040             LSLS     R0,R0,#+1
   \   000000C8   0xF8AD 0x0022      STRH     R0,[SP, #+34]
    247              _dma_init(&tcd);
   \   000000CC   0xA800             ADD      R0,SP,#+0
   \   000000CE   0x.... 0x....      BL       _dma_init
    248          
    249              // enable DMA channel
    250              DMA_SERQ = DMA_SERQ_SERQ(0); 
   \   000000D2   0x....             LDR.N    R0,??DataTable8_8  ;; 0x4000801b
   \   000000D4   0x2100             MOVS     R1,#+0
   \   000000D6   0x7001             STRB     R1,[R0, #+0]
    251          }
   \   000000D8   0xB00A             ADD      SP,SP,#+40
   \   000000DA   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
    252          void hal_dma_clear_int(uint channel)
    253          {
    254              channel &= 0xf;
   \                     hal_dma_clear_int:
   \   00000000   0xF010 0x000F      ANDS     R0,R0,#0xF
    255              DMA_CINT = channel;
   \   00000004   0x....             LDR.N    R1,??DataTable8_19  ;; 0x4000801f
   \   00000006   0x7008             STRB     R0,[R1, #+0]
    256          }
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    257          void check_dma_buffer(void)
    258          {
   \                     check_dma_buffer:
   \   00000000   0xB580             PUSH     {R7,LR}
    259              while(1)
    260              {
    261                  while(!(DMA_TCD0_CSR & DMA_CSR_DONE_MASK))
   \                     ??check_dma_buffer_0:
   \                     ??check_dma_buffer_1:
   \   00000002   0x....             LDR.N    R0,??DataTable8_14  ;; 0x4000901c
   \   00000004   0x8800             LDRH     R0,[R0, #+0]
   \   00000006   0x0600             LSLS     R0,R0,#+24
   \   00000008   0xD5FB             BPL.N    ??check_dma_buffer_1
    262                      ;
    263                  DMA_TCD0_CSR &= ~DMA_CSR_DONE_MASK;
   \   0000000A   0x....             LDR.N    R0,??DataTable8_14  ;; 0x4000901c
   \   0000000C   0x8800             LDRH     R0,[R0, #+0]
   \   0000000E   0xF64F 0x717F      MOVW     R1,#+65407
   \   00000012   0x4008             ANDS     R0,R1,R0
   \   00000014   0x....             LDR.N    R1,??DataTable8_14  ;; 0x4000901c
   \   00000016   0x8008             STRH     R0,[R1, #+0]
    264                  print_buf((char*)SRAM_DADDRESS, 16);
   \   00000018   0x2110             MOVS     R1,#+16
   \   0000001A   0x....             LDR.N    R0,??DataTable8_5  ;; 0x1ffff000
   \   0000001C   0x.... 0x....      BL       print_buf
   \   00000020   0xE7EF             B.N      ??check_dma_buffer_0
    265              }
    266          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x4000801D         DC32     0x4000801d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     ??i

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     `?<Constant "dma_sw_trig %d\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x40008004         DC32     0x40008004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x1FFFE000         DC32     0x1fffe000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x1FFFF000         DC32     0x1ffff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x40009000         DC32     0x40009000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x4000801B         DC32     0x4000801b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     `?<Constant "mem_src_init\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x........         DC32     `?<Constant "trig 1\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x........         DC32     `?<Constant "trig 2\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_12:
   \   00000000   0x........         DC32     `?<Constant "trig 3\\n">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_13:
   \   00000000   0x........         DC32     `?<Constant "%x,%x,%x,%x,\\n%d,%d,%d...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_14:
   \   00000000   0x4000901C         DC32     0x4000901c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_15:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_16:
   \   00000000   0x40008000         DC32     0x40008000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_17:
   \   00000000   0x3FFFFC00         DC32     0x3ffffc00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_18:
   \   00000000   0x4002F020         DC32     0x4002f020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_19:
   \   00000000   0x4000801F         DC32     0x4000801f

   \                                 In section .rodata, align 4
   \                     `?<Constant "dma_sw_trig %d\\n">`:
   \   00000000   0x64 0x6D          DC8 "dma_sw_trig %d\012"
   \              0x61 0x5F    
   \              0x73 0x77    
   \              0x5F 0x74    
   \              0x72 0x69    
   \              0x67 0x20    
   \              0x25 0x64    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "mem_src_init\\n">`:
   \   00000000   0x6D 0x65          DC8 "mem_src_init\012"
   \              0x6D 0x5F    
   \              0x73 0x72    
   \              0x63 0x5F    
   \              0x69 0x6E    
   \              0x69 0x74    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "trig 1\\n">`:
   \   00000000   0x74 0x72          DC8 "trig 1\012"
   \              0x69 0x67    
   \              0x20 0x31    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "trig 2\\n">`:
   \   00000000   0x74 0x72          DC8 "trig 2\012"
   \              0x69 0x67    
   \              0x20 0x32    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "trig 3\\n">`:
   \   00000000   0x74 0x72          DC8 "trig 3\012"
   \              0x69 0x67    
   \              0x20 0x33    
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "%x,%x,%x,%x,\\n%d,%d,%d...">`:
   \   00000000   0x25 0x78          DC8 "%x,%x,%x,%x,\012%d,%d,%d,%d,%d,%d\012"
   \              0x2C 0x25    
   \              0x78 0x2C    
   \              0x25 0x78    
   \              0x2C 0x25    
   \              0x78 0x2C    
   \              0x0A 0x25    
   \              0x64 0x2C    
   \              0x25 0x64    
   \              0x2C 0x25    
   \              0x64 0x2C    
   \              0x25 0x64    
   \              0x2C 0x25    
   \              0x64 0x2C    
   \              0x25 0x64    
   \              0x0A 0x00    
    267          
    268          
    269          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      40   _dma_init
        40   -> q_printf
       8   check_dma_buffer
         8   -> print_buf
       8   dma_sw_trgger_test
         8   -> dma_sw_trig
         8   -> dma_wait
         8   -> mem_src_init
         8   -> nvic_enable_irq
         8   -> print_buf
         8   -> q_printf
       8   dma_sw_trig
         8   -> q_printf
       0   dma_wait
       0   hal_dma_clear_int
       8   hal_dma_init
         8   -> nvic_enable_irq
      64   hal_dma_init_for_i2s
        64   -> _dma_init
        64   -> nvic_enable_irq
       0   mem_src_init
       0   sw_delay


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant "%x,%x,%x,%x,\n%d,%d,%d...">
      16  ?<Constant "dma_sw_trig %d\n">
      16  ?<Constant "mem_src_init\n">
       8  ?<Constant "trig 1\n">
       8  ?<Constant "trig 2\n">
       8  ?<Constant "trig 3\n">
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_17
       4  ??DataTable8_18
       4  ??DataTable8_19
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
     208  _dma_init
      34  check_dma_buffer
     330  dma_sw_trgger_test
      34  dma_sw_trig
      48  dma_wait
      10  hal_dma_clear_int
      16  hal_dma_init
     222  hal_dma_init_for_i2s
       4  i
      46  mem_src_init
      14  sw_delay

 
     4 bytes in section .bss
    88 bytes in section .rodata
 1 042 bytes in section .text
 
 1 042 bytes of CODE  memory
    88 bytes of CONST memory
     4 bytes of DATA  memory

Errors: none
Warnings: none
